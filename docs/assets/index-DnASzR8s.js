var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      (function() {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s);
        new MutationObserver((s) => {
          for (const r of s) if (r.type === "childList") for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function e(s) {
          const r = {};
          return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function i(s) {
          if (s.ep) return;
          s.ep = true;
          const r = e(s);
          fetch(s.href, r);
        }
      })();
      var Qa, me, nm, Ji, Fu, im, sm, rm, Lh, bc, yc, jr = {}, om = [], W_ = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Ja = Array.isArray;
      function ii(n, t) {
        for (var e in t) n[e] = t[e];
        return n;
      }
      function Ih(n) {
        n && n.parentNode && n.parentNode.removeChild(n);
      }
      function G_(n, t, e) {
        var i, s, r, o = {};
        for (r in t) r == "key" ? i = t[r] : r == "ref" ? s = t[r] : o[r] = t[r];
        if (arguments.length > 2 && (o.children = arguments.length > 3 ? Qa.call(arguments, 2) : e), typeof n == "function" && n.defaultProps != null) for (r in n.defaultProps) o[r] == null && (o[r] = n.defaultProps[r]);
        return ga(n, o, i, s, null);
      }
      function ga(n, t, e, i, s) {
        var r = {
          type: n,
          props: t,
          key: e,
          ref: i,
          __k: null,
          __: null,
          __b: 0,
          __e: null,
          __c: null,
          constructor: void 0,
          __v: s ?? ++nm,
          __i: -1,
          __u: 0
        };
        return s == null && me.vnode != null && me.vnode(r), r;
      }
      function ro(n) {
        return n.children;
      }
      function _a(n, t) {
        this.props = n, this.context = t;
      }
      function Ks(n, t) {
        if (t == null) return n.__ ? Ks(n.__, n.__i + 1) : null;
        for (var e; t < n.__k.length; t++) if ((e = n.__k[t]) != null && e.__e != null) return e.__e;
        return typeof n.type == "function" ? Ks(n) : null;
      }
      function am(n) {
        var t, e;
        if ((n = n.__) != null && n.__c != null) {
          for (n.__e = n.__c.base = null, t = 0; t < n.__k.length; t++) if ((e = n.__k[t]) != null && e.__e != null) {
            n.__e = n.__c.base = e.__e;
            break;
          }
          return am(n);
        }
      }
      function Nu(n) {
        (!n.__d && (n.__d = true) && Ji.push(n) && !Pa.__r++ || Fu != me.debounceRendering) && ((Fu = me.debounceRendering) || im)(Pa);
      }
      function Pa() {
        for (var n, t, e, i, s, r, o, a = 1; Ji.length; ) Ji.length > a && Ji.sort(sm), n = Ji.shift(), a = Ji.length, n.__d && (e = void 0, s = (i = (t = n).__v).__e, r = [], o = [], t.__P && ((e = ii({}, i)).__v = i.__v + 1, me.vnode && me.vnode(e), Oh(t.__P, e, i, t.__n, t.__P.namespaceURI, 32 & i.__u ? [
          s
        ] : null, r, s ?? Ks(i), !!(32 & i.__u), o), e.__v = i.__v, e.__.__k[e.__i] = e, hm(r, e, o), e.__e != s && am(e)));
        Pa.__r = 0;
      }
      function lm(n, t, e, i, s, r, o, a, l, c, h) {
        var u, d, f, g, _, m, p = i && i.__k || om, y = t.length;
        for (l = X_(e, t, p, l, y), u = 0; u < y; u++) (f = e.__k[u]) != null && (d = f.__i == -1 ? jr : p[f.__i] || jr, f.__i = u, m = Oh(n, f, d, s, r, o, a, l, c, h), g = f.__e, f.ref && d.ref != f.ref && (d.ref && kh(d.ref, null, f), h.push(f.ref, f.__c || g, f)), _ == null && g != null && (_ = g), 4 & f.__u || d.__k === f.__k ? l = cm(f, l, n) : typeof f.type == "function" && m !== void 0 ? l = m : g && (l = g.nextSibling), f.__u &= -7);
        return e.__e = _, l;
      }
      function X_(n, t, e, i, s) {
        var r, o, a, l, c, h = e.length, u = h, d = 0;
        for (n.__k = new Array(s), r = 0; r < s; r++) (o = t[r]) != null && typeof o != "boolean" && typeof o != "function" ? (l = r + d, (o = n.__k[r] = typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? ga(null, o, null, null, null) : Ja(o) ? ga(ro, {
          children: o
        }, null, null, null) : o.constructor == null && o.__b > 0 ? ga(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o).__ = n, o.__b = n.__b + 1, a = null, (c = o.__i = Y_(o, e, l, u)) != -1 && (u--, (a = e[c]) && (a.__u |= 2)), a == null || a.__v == null ? (c == -1 && (s > h ? d-- : s < h && d++), typeof o.type != "function" && (o.__u |= 4)) : c != l && (c == l - 1 ? d-- : c == l + 1 ? d++ : (c > l ? d-- : d++, o.__u |= 4))) : n.__k[r] = null;
        if (u) for (r = 0; r < h; r++) (a = e[r]) != null && (2 & a.__u) == 0 && (a.__e == i && (i = Ks(a)), dm(a, a));
        return i;
      }
      function cm(n, t, e) {
        var i, s;
        if (typeof n.type == "function") {
          for (i = n.__k, s = 0; i && s < i.length; s++) i[s] && (i[s].__ = n, t = cm(i[s], t, e));
          return t;
        }
        n.__e != t && (t && n.type && !e.contains(t) && (t = Ks(n)), e.insertBefore(n.__e, t || null), t = n.__e);
        do
          t = t && t.nextSibling;
        while (t != null && t.nodeType == 8);
        return t;
      }
      function Y_(n, t, e, i) {
        var s, r, o = n.key, a = n.type, l = t[e];
        if (l === null && n.key == null || l && o == l.key && a == l.type && (2 & l.__u) == 0) return e;
        if (i > (l != null && (2 & l.__u) == 0 ? 1 : 0)) for (s = e - 1, r = e + 1; s >= 0 || r < t.length; ) {
          if (s >= 0) {
            if ((l = t[s]) && (2 & l.__u) == 0 && o == l.key && a == l.type) return s;
            s--;
          }
          if (r < t.length) {
            if ((l = t[r]) && (2 & l.__u) == 0 && o == l.key && a == l.type) return r;
            r++;
          }
        }
        return -1;
      }
      function Uu(n, t, e) {
        t[0] == "-" ? n.setProperty(t, e ?? "") : n[t] = e == null ? "" : typeof e != "number" || W_.test(t) ? e : e + "px";
      }
      function Mo(n, t, e, i, s) {
        var r, o;
        t: if (t == "style") if (typeof e == "string") n.style.cssText = e;
        else {
          if (typeof i == "string" && (n.style.cssText = i = ""), i) for (t in i) e && t in e || Uu(n.style, t, "");
          if (e) for (t in e) i && e[t] == i[t] || Uu(n.style, t, e[t]);
        }
        else if (t[0] == "o" && t[1] == "n") r = t != (t = t.replace(rm, "$1")), o = t.toLowerCase(), t = o in n || t == "onFocusOut" || t == "onFocusIn" ? o.slice(2) : t.slice(2), n.l || (n.l = {}), n.l[t + r] = e, e ? i ? e.u = i.u : (e.u = Lh, n.addEventListener(t, r ? yc : bc, r)) : n.removeEventListener(t, r ? yc : bc, r);
        else {
          if (s == "http://www.w3.org/2000/svg") t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
          else if (t != "width" && t != "height" && t != "href" && t != "list" && t != "form" && t != "tabIndex" && t != "download" && t != "rowSpan" && t != "colSpan" && t != "role" && t != "popover" && t in n) try {
            n[t] = e ?? "";
            break t;
          } catch {
          }
          typeof e == "function" || (e == null || e === false && t[4] != "-" ? n.removeAttribute(t) : n.setAttribute(t, t == "popover" && e == 1 ? "" : e));
        }
      }
      function Bu(n) {
        return function(t) {
          if (this.l) {
            var e = this.l[t.type + n];
            if (t.t == null) t.t = Lh++;
            else if (t.t < e.u) return;
            return e(me.event ? me.event(t) : t);
          }
        };
      }
      function Oh(n, t, e, i, s, r, o, a, l, c) {
        var h, u, d, f, g, _, m, p, y, w, M, C, R, T, v, x, b, A = t.type;
        if (t.constructor != null) return null;
        128 & e.__u && (l = !!(32 & e.__u), r = [
          a = t.__e = e.__e
        ]), (h = me.__b) && h(t);
        t: if (typeof A == "function") try {
          if (p = t.props, y = "prototype" in A && A.prototype.render, w = (h = A.contextType) && i[h.__c], M = h ? w ? w.props.value : h.__ : i, e.__c ? m = (u = t.__c = e.__c).__ = u.__E : (y ? t.__c = u = new A(p, M) : (t.__c = u = new _a(p, M), u.constructor = A, u.render = q_), w && w.sub(u), u.props = p, u.state || (u.state = {}), u.context = M, u.__n = i, d = u.__d = true, u.__h = [], u._sb = []), y && u.__s == null && (u.__s = u.state), y && A.getDerivedStateFromProps != null && (u.__s == u.state && (u.__s = ii({}, u.__s)), ii(u.__s, A.getDerivedStateFromProps(p, u.__s))), f = u.props, g = u.state, u.__v = t, d) y && A.getDerivedStateFromProps == null && u.componentWillMount != null && u.componentWillMount(), y && u.componentDidMount != null && u.__h.push(u.componentDidMount);
          else {
            if (y && A.getDerivedStateFromProps == null && p !== f && u.componentWillReceiveProps != null && u.componentWillReceiveProps(p, M), !u.__e && u.shouldComponentUpdate != null && u.shouldComponentUpdate(p, u.__s, M) === false || t.__v == e.__v) {
              for (t.__v != e.__v && (u.props = p, u.state = u.__s, u.__d = false), t.__e = e.__e, t.__k = e.__k, t.__k.some(function(L) {
                L && (L.__ = t);
              }), C = 0; C < u._sb.length; C++) u.__h.push(u._sb[C]);
              u._sb = [], u.__h.length && o.push(u);
              break t;
            }
            u.componentWillUpdate != null && u.componentWillUpdate(p, u.__s, M), y && u.componentDidUpdate != null && u.__h.push(function() {
              u.componentDidUpdate(f, g, _);
            });
          }
          if (u.context = M, u.props = p, u.__P = n, u.__e = false, R = me.__r, T = 0, y) {
            for (u.state = u.__s, u.__d = false, R && R(t), h = u.render(u.props, u.state, u.context), v = 0; v < u._sb.length; v++) u.__h.push(u._sb[v]);
            u._sb = [];
          } else do
            u.__d = false, R && R(t), h = u.render(u.props, u.state, u.context), u.state = u.__s;
          while (u.__d && ++T < 25);
          u.state = u.__s, u.getChildContext != null && (i = ii(ii({}, i), u.getChildContext())), y && !d && u.getSnapshotBeforeUpdate != null && (_ = u.getSnapshotBeforeUpdate(f, g)), x = h, h != null && h.type === ro && h.key == null && (x = um(h.props.children)), a = lm(n, Ja(x) ? x : [
            x
          ], t, e, i, s, r, o, a, l, c), u.base = t.__e, t.__u &= -161, u.__h.length && o.push(u), m && (u.__E = u.__ = null);
        } catch (L) {
          if (t.__v = null, l || r != null) if (L.then) {
            for (t.__u |= l ? 160 : 128; a && a.nodeType == 8 && a.nextSibling; ) a = a.nextSibling;
            r[r.indexOf(a)] = null, t.__e = a;
          } else for (b = r.length; b--; ) Ih(r[b]);
          else t.__e = e.__e, t.__k = e.__k;
          me.__e(L, t, e);
        }
        else r == null && t.__v == e.__v ? (t.__k = e.__k, t.__e = e.__e) : a = t.__e = j_(e.__e, t, e, i, s, r, o, l, c);
        return (h = me.diffed) && h(t), 128 & t.__u ? void 0 : a;
      }
      function hm(n, t, e) {
        for (var i = 0; i < e.length; i++) kh(e[i], e[++i], e[++i]);
        me.__c && me.__c(t, n), n.some(function(s) {
          try {
            n = s.__h, s.__h = [], n.some(function(r) {
              r.call(s);
            });
          } catch (r) {
            me.__e(r, s.__v);
          }
        });
      }
      function um(n) {
        return typeof n != "object" || n == null || n.__b && n.__b > 0 ? n : Ja(n) ? n.map(um) : ii({}, n);
      }
      function j_(n, t, e, i, s, r, o, a, l) {
        var c, h, u, d, f, g, _, m = e.props, p = t.props, y = t.type;
        if (y == "svg" ? s = "http://www.w3.org/2000/svg" : y == "math" ? s = "http://www.w3.org/1998/Math/MathML" : s || (s = "http://www.w3.org/1999/xhtml"), r != null) {
          for (c = 0; c < r.length; c++) if ((f = r[c]) && "setAttribute" in f == !!y && (y ? f.localName == y : f.nodeType == 3)) {
            n = f, r[c] = null;
            break;
          }
        }
        if (n == null) {
          if (y == null) return document.createTextNode(p);
          n = document.createElementNS(s, y, p.is && p), a && (me.__m && me.__m(t, r), a = false), r = null;
        }
        if (y == null) m === p || a && n.data == p || (n.data = p);
        else {
          if (r = r && Qa.call(n.childNodes), m = e.props || jr, !a && r != null) for (m = {}, c = 0; c < n.attributes.length; c++) m[(f = n.attributes[c]).name] = f.value;
          for (c in m) if (f = m[c], c != "children") {
            if (c == "dangerouslySetInnerHTML") u = f;
            else if (!(c in p)) {
              if (c == "value" && "defaultValue" in p || c == "checked" && "defaultChecked" in p) continue;
              Mo(n, c, null, f, s);
            }
          }
          for (c in p) f = p[c], c == "children" ? d = f : c == "dangerouslySetInnerHTML" ? h = f : c == "value" ? g = f : c == "checked" ? _ = f : a && typeof f != "function" || m[c] === f || Mo(n, c, f, m[c], s);
          if (h) a || u && (h.__html == u.__html || h.__html == n.innerHTML) || (n.innerHTML = h.__html), t.__k = [];
          else if (u && (n.innerHTML = ""), lm(t.type == "template" ? n.content : n, Ja(d) ? d : [
            d
          ], t, e, i, y == "foreignObject" ? "http://www.w3.org/1999/xhtml" : s, r, o, r ? r[0] : e.__k && Ks(e, 0), a, l), r != null) for (c = r.length; c--; ) Ih(r[c]);
          a || (c = "value", y == "progress" && g == null ? n.removeAttribute("value") : g != null && (g !== n[c] || y == "progress" && !g || y == "option" && g != m[c]) && Mo(n, c, g, m[c], s), c = "checked", _ != null && _ != n[c] && Mo(n, c, _, m[c], s));
        }
        return n;
      }
      function kh(n, t, e) {
        try {
          if (typeof n == "function") {
            var i = typeof n.__u == "function";
            i && n.__u(), i && t == null || (n.__u = n(t));
          } else n.current = t;
        } catch (s) {
          me.__e(s, e);
        }
      }
      function dm(n, t, e) {
        var i, s;
        if (me.unmount && me.unmount(n), (i = n.ref) && (i.current && i.current != n.__e || kh(i, null, t)), (i = n.__c) != null) {
          if (i.componentWillUnmount) try {
            i.componentWillUnmount();
          } catch (r) {
            me.__e(r, t);
          }
          i.base = i.__P = null;
        }
        if (i = n.__k) for (s = 0; s < i.length; s++) i[s] && dm(i[s], t, e || typeof n.type != "function");
        e || Ih(n.__e), n.__c = n.__ = n.__e = void 0;
      }
      function q_(n, t, e) {
        return this.constructor(n, e);
      }
      function $_(n, t, e) {
        var i, s, r, o;
        t == document && (t = document.documentElement), me.__ && me.__(n, t), s = (i = false) ? null : t.__k, r = [], o = [], Oh(t, n = t.__k = G_(ro, null, [
          n
        ]), s || jr, jr, t.namespaceURI, s ? null : t.firstChild ? Qa.call(t.childNodes) : null, r, s ? s.__e : t.firstChild, i, o), hm(r, n, o);
      }
      Qa = om.slice, me = {
        __e: function(n, t, e, i) {
          for (var s, r, o; t = t.__; ) if ((s = t.__c) && !s.__) try {
            if ((r = s.constructor) && r.getDerivedStateFromError != null && (s.setState(r.getDerivedStateFromError(n)), o = s.__d), s.componentDidCatch != null && (s.componentDidCatch(n, i || {}), o = s.__d), o) return s.__E = s;
          } catch (a) {
            n = a;
          }
          throw n;
        }
      }, nm = 0, _a.prototype.setState = function(n, t) {
        var e;
        e = this.__s != null && this.__s != this.state ? this.__s : this.__s = ii({}, this.state), typeof n == "function" && (n = n(ii({}, e), this.props)), n && ii(e, n), n != null && this.__v && (t && this._sb.push(t), Nu(this));
      }, _a.prototype.forceUpdate = function(n) {
        this.__v && (this.__e = true, n && this.__h.push(n), Nu(this));
      }, _a.prototype.render = ro, Ji = [], im = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, sm = function(n, t) {
        return n.__v.__b - t.__v.__b;
      }, Pa.__r = 0, rm = /(PointerCapture)$|Capture$/i, Lh = 0, bc = Bu(false), yc = Bu(true);
      var K_ = 0;
      function $(n, t, e, i, s, r) {
        t || (t = {});
        var o, a, l = t;
        if ("ref" in l) for (a in l = {}, t) a == "ref" ? o = t[a] : l[a] = t[a];
        var c = {
          type: n,
          props: l,
          key: e,
          ref: o,
          __k: null,
          __: null,
          __b: 0,
          __e: null,
          __c: null,
          constructor: void 0,
          __v: --K_,
          __i: -1,
          __u: 0,
          __source: s,
          __self: r
        };
        if (typeof n == "function" && (o = n.defaultProps)) for (a in o) l[a] === void 0 && (l[a] = o[a]);
        return me.vnode && me.vnode(c), c;
      }
      var qr, Re, yl, zu, Da = 0, fm = [], Oe = me, Hu = Oe.__b, Vu = Oe.__r, Wu = Oe.diffed, Gu = Oe.__c, Xu = Oe.unmount, Yu = Oe.__;
      function Fh(n, t) {
        Oe.__h && Oe.__h(Re, n, Da || t), Da = 0;
        var e = Re.__H || (Re.__H = {
          __: [],
          __h: []
        });
        return n >= e.__.length && e.__.push({}), e.__[n];
      }
      function Vs(n) {
        return Da = 1, Z_(mm, n);
      }
      function Z_(n, t, e) {
        var i = Fh(qr++, 2);
        if (i.t = n, !i.__c && (i.__ = [
          mm(void 0, t),
          function(a) {
            var l = i.__N ? i.__N[0] : i.__[0], c = i.t(l, a);
            l !== c && (i.__N = [
              c,
              i.__[1]
            ], i.__c.setState({}));
          }
        ], i.__c = Re, !Re.__f)) {
          var s = function(a, l, c) {
            if (!i.__c.__H) return true;
            var h = i.__c.__H.__.filter(function(d) {
              return !!d.__c;
            });
            if (h.every(function(d) {
              return !d.__N;
            })) return !r || r.call(this, a, l, c);
            var u = i.__c.props !== a;
            return h.forEach(function(d) {
              if (d.__N) {
                var f = d.__[0];
                d.__ = d.__N, d.__N = void 0, f !== d.__[0] && (u = true);
              }
            }), r && r.call(this, a, l, c) || u;
          };
          Re.__f = true;
          var r = Re.shouldComponentUpdate, o = Re.componentWillUpdate;
          Re.componentWillUpdate = function(a, l, c) {
            if (this.__e) {
              var h = r;
              r = void 0, s(a, l, c), r = h;
            }
            o && o.call(this, a, l, c);
          }, Re.shouldComponentUpdate = s;
        }
        return i.__N || i.__;
      }
      function Xs(n, t) {
        var e = Fh(qr++, 3);
        !Oe.__s && pm(e.__H, t) && (e.__ = n, e.u = t, Re.__H.__h.push(e));
      }
      function Zs(n) {
        return Da = 5, Q_(function() {
          return {
            current: n
          };
        }, []);
      }
      function Q_(n, t) {
        var e = Fh(qr++, 7);
        return pm(e.__H, t) && (e.__ = n(), e.__H = t, e.__h = n), e.__;
      }
      function J_() {
        for (var n; n = fm.shift(); ) if (n.__P && n.__H) try {
          n.__H.__h.forEach(xa), n.__H.__h.forEach(vc), n.__H.__h = [];
        } catch (t) {
          n.__H.__h = [], Oe.__e(t, n.__v);
        }
      }
      Oe.__b = function(n) {
        Re = null, Hu && Hu(n);
      }, Oe.__ = function(n, t) {
        n && t.__k && t.__k.__m && (n.__m = t.__k.__m), Yu && Yu(n, t);
      }, Oe.__r = function(n) {
        Vu && Vu(n), qr = 0;
        var t = (Re = n.__c).__H;
        t && (yl === Re ? (t.__h = [], Re.__h = [], t.__.forEach(function(e) {
          e.__N && (e.__ = e.__N), e.u = e.__N = void 0;
        })) : (t.__h.forEach(xa), t.__h.forEach(vc), t.__h = [], qr = 0)), yl = Re;
      }, Oe.diffed = function(n) {
        Wu && Wu(n);
        var t = n.__c;
        t && t.__H && (t.__H.__h.length && (fm.push(t) !== 1 && zu === Oe.requestAnimationFrame || ((zu = Oe.requestAnimationFrame) || t0)(J_)), t.__H.__.forEach(function(e) {
          e.u && (e.__H = e.u), e.u = void 0;
        })), yl = Re = null;
      }, Oe.__c = function(n, t) {
        t.some(function(e) {
          try {
            e.__h.forEach(xa), e.__h = e.__h.filter(function(i) {
              return !i.__ || vc(i);
            });
          } catch (i) {
            t.some(function(s) {
              s.__h && (s.__h = []);
            }), t = [], Oe.__e(i, e.__v);
          }
        }), Gu && Gu(n, t);
      }, Oe.unmount = function(n) {
        Xu && Xu(n);
        var t, e = n.__c;
        e && e.__H && (e.__H.__.forEach(function(i) {
          try {
            xa(i);
          } catch (s) {
            t = s;
          }
        }), e.__H = void 0, t && Oe.__e(t, e.__v));
      };
      var ju = typeof requestAnimationFrame == "function";
      function t0(n) {
        var t, e = function() {
          clearTimeout(i), ju && cancelAnimationFrame(t), setTimeout(n);
        }, i = setTimeout(e, 35);
        ju && (t = requestAnimationFrame(e));
      }
      function xa(n) {
        var t = Re, e = n.__c;
        typeof e == "function" && (n.__c = void 0, e()), Re = t;
      }
      function vc(n) {
        var t = Re;
        n.__c = n.__(), Re = t;
      }
      function pm(n, t) {
        return !n || n.length !== t.length || t.some(function(e, i) {
          return e !== n[i];
        });
      }
      function mm(n, t) {
        return typeof t == "function" ? t(n) : t;
      }
      const e0 = "/assets/black_scholes_bg-iksvb1Ok.wasm", n0 = async (n = {}, t) => {
        let e;
        if (t.startsWith("data:")) {
          const i = t.replace(/^data:.*?base64,/, "");
          let s;
          if (typeof Buffer == "function" && typeof Buffer.from == "function") s = Buffer.from(i, "base64");
          else if (typeof atob == "function") {
            const r = atob(i);
            s = new Uint8Array(r.length);
            for (let o = 0; o < r.length; o++) s[o] = r.charCodeAt(o);
          } else throw new Error("Cannot decode base64-encoded data URL");
          e = await WebAssembly.instantiate(s, n);
        } else {
          const i = await fetch(t), s = i.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && s.startsWith("application/wasm")) e = await WebAssembly.instantiateStreaming(i, n);
          else {
            const r = await i.arrayBuffer();
            e = await WebAssembly.instantiate(r, n);
          }
        }
        return e.instance.exports;
      };
      let He;
      function i0(n) {
        He = n;
      }
      const s0 = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let gm = new s0("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      gm.decode();
      let So = null;
      function r0() {
        return (So === null || So.byteLength === 0) && (So = new Uint8Array(He.memory.buffer)), So;
      }
      function _m(n, t) {
        return n = n >>> 0, gm.decode(r0().subarray(n, n + t));
      }
      function pr(n, t, e, i, s, r) {
        return He.calculate_option_price(n, t, e, i, s, r);
      }
      function Mc(n, t, e, i, s, r) {
        const o = He.calculate_greeks(n, t, e, i, s, r);
        return Nh.__wrap(o);
      }
      const Yn = Object.freeze({
        Call: 0,
        0: "Call",
        Put: 1,
        1: "Put"
      });
      typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => He.__wbg_blackscholes_free(n >>> 0, 1));
      const qu = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((n) => He.__wbg_greeks_free(n >>> 0, 1));
      class Nh {
        static __wrap(t) {
          t = t >>> 0;
          const e = Object.create(Nh.prototype);
          return e.__wbg_ptr = t, qu.register(e, e.__wbg_ptr, e), e;
        }
        __destroy_into_raw() {
          const t = this.__wbg_ptr;
          return this.__wbg_ptr = 0, qu.unregister(this), t;
        }
        free() {
          const t = this.__destroy_into_raw();
          He.__wbg_greeks_free(t, 0);
        }
        get delta() {
          return He.__wbg_get_greeks_delta(this.__wbg_ptr);
        }
        set delta(t) {
          He.__wbg_set_greeks_delta(this.__wbg_ptr, t);
        }
        get gamma() {
          return He.__wbg_get_greeks_gamma(this.__wbg_ptr);
        }
        set gamma(t) {
          He.__wbg_set_greeks_gamma(this.__wbg_ptr, t);
        }
        get theta() {
          return He.__wbg_get_greeks_theta(this.__wbg_ptr);
        }
        set theta(t) {
          He.__wbg_set_greeks_theta(this.__wbg_ptr, t);
        }
        get vega() {
          return He.__wbg_get_greeks_vega(this.__wbg_ptr);
        }
        set vega(t) {
          He.__wbg_set_greeks_vega(this.__wbg_ptr, t);
        }
        get rho() {
          return He.__wbg_get_greeks_rho(this.__wbg_ptr);
        }
        set rho(t) {
          He.__wbg_set_greeks_rho(this.__wbg_ptr, t);
        }
      }
      function o0() {
        const n = He.__wbindgen_export_0, t = n.grow(4);
        n.set(0, void 0), n.set(t + 0, void 0), n.set(t + 1, null), n.set(t + 2, true), n.set(t + 3, false);
      }
      function a0(n, t) {
        return _m(n, t);
      }
      function l0(n, t) {
        throw new Error(_m(n, t));
      }
      URL = globalThis.URL;
      const ne = await n0({
        "./black_scholes_bg.js": {
          __wbindgen_string_new: a0,
          __wbindgen_throw: l0,
          __wbindgen_init_externref_table: o0
        }
      }, e0), c0 = ne.memory, h0 = ne.__wbg_blackscholes_free, u0 = ne.__wbg_greeks_free, d0 = ne.__wbg_get_greeks_delta, f0 = ne.__wbg_set_greeks_delta, p0 = ne.__wbg_get_greeks_gamma, m0 = ne.__wbg_set_greeks_gamma, g0 = ne.__wbg_get_greeks_theta, _0 = ne.__wbg_set_greeks_theta, x0 = ne.__wbg_get_greeks_vega, b0 = ne.__wbg_set_greeks_vega, y0 = ne.__wbg_get_greeks_rho, v0 = ne.__wbg_set_greeks_rho, M0 = ne.blackscholes_new, S0 = ne.blackscholes_set_spot_price, w0 = ne.blackscholes_set_strike_price, E0 = ne.blackscholes_set_time_to_expiry, T0 = ne.blackscholes_set_risk_free_rate, A0 = ne.blackscholes_set_standard_deviation, C0 = ne.blackscholes_d1, R0 = ne.blackscholes_d2, P0 = ne.blackscholes_norm_cdf, D0 = ne.blackscholes_norm_pdf, L0 = ne.blackscholes_price, I0 = ne.blackscholes_greeks, O0 = ne.blackscholes_implied_volatility, k0 = ne.erf, F0 = ne.calculate_option_price, N0 = ne.calculate_greeks, U0 = ne.__wbindgen_export_0, B0 = ne.__externref_table_dealloc, xm = ne.__wbindgen_start, z0 = Object.freeze(Object.defineProperty({
        __proto__: null,
        __externref_table_dealloc: B0,
        __wbg_blackscholes_free: h0,
        __wbg_get_greeks_delta: d0,
        __wbg_get_greeks_gamma: p0,
        __wbg_get_greeks_rho: y0,
        __wbg_get_greeks_theta: g0,
        __wbg_get_greeks_vega: x0,
        __wbg_greeks_free: u0,
        __wbg_set_greeks_delta: f0,
        __wbg_set_greeks_gamma: m0,
        __wbg_set_greeks_rho: v0,
        __wbg_set_greeks_theta: _0,
        __wbg_set_greeks_vega: b0,
        __wbindgen_export_0: U0,
        __wbindgen_start: xm,
        blackscholes_d1: C0,
        blackscholes_d2: R0,
        blackscholes_greeks: I0,
        blackscholes_implied_volatility: O0,
        blackscholes_new: M0,
        blackscholes_norm_cdf: P0,
        blackscholes_norm_pdf: D0,
        blackscholes_price: L0,
        blackscholes_set_risk_free_rate: T0,
        blackscholes_set_spot_price: S0,
        blackscholes_set_standard_deviation: A0,
        blackscholes_set_strike_price: w0,
        blackscholes_set_time_to_expiry: E0,
        calculate_greeks: N0,
        calculate_option_price: F0,
        erf: k0,
        memory: c0
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      i0(z0);
      xm();
      const Uh = "176", Ys = {
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      }, Ws = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      }, H0 = 0, $u = 1, V0 = 2, bm = 1, W0 = 2, Jn = 3, Di = 0, an = 1, Nn = 2, wi = 0, js = 1, Ku = 2, Zu = 3, Qu = 4, G0 = 5, ts = 100, X0 = 101, Y0 = 102, j0 = 103, q0 = 104, $0 = 200, K0 = 201, Z0 = 202, Q0 = 203, Sc = 204, wc = 205, J0 = 206, tx = 207, ex = 208, nx = 209, ix = 210, sx = 211, rx = 212, ox = 213, ax = 214, Ec = 0, Tc = 1, Ac = 2, Qs = 3, Cc = 4, Rc = 5, Pc = 6, Dc = 7, Bh = 0, lx = 1, cx = 2, Ei = 0, hx = 1, ux = 2, dx = 3, fx = 4, px = 5, mx = 6, gx = 7, ym = 300, Js = 301, tr = 302, Lc = 303, Ic = 304, tl = 306, Oc = 1e3, ns = 1001, kc = 1002, Ln = 1003, _x = 1004, wo = 1005, _n = 1006, vl = 1007, is = 1008, Vn = 1009, vm = 1010, Mm = 1011, $r = 1012, zh = 1013, os = 1014, si = 1015, oo = 1016, Hh = 1017, Vh = 1018, Kr = 1020, Sm = 35902, wm = 1021, Em = 1022, Pn = 1023, Zr = 1026, Qr = 1027, Tm = 1028, Wh = 1029, Am = 1030, Gh = 1031, Xh = 1033, ba = 33776, ya = 33777, va = 33778, Ma = 33779, Fc = 35840, Nc = 35841, Uc = 35842, Bc = 35843, zc = 36196, Hc = 37492, Vc = 37496, Wc = 37808, Gc = 37809, Xc = 37810, Yc = 37811, jc = 37812, qc = 37813, $c = 37814, Kc = 37815, Zc = 37816, Qc = 37817, Jc = 37818, th = 37819, eh = 37820, nh = 37821, Sa = 36492, ih = 36494, sh = 36495, Cm = 36283, rh = 36284, oh = 36285, ah = 36286, xx = 3200, bx = 3201, Rm = 0, yx = 1, yi = "", Sn = "srgb", er = "srgb-linear", La = "linear", ue = "srgb", vs = 7680, Ju = 519, vx = 512, Mx = 513, Sx = 514, Pm = 515, wx = 516, Ex = 517, Tx = 518, Ax = 519, lh = 35044, td = "300 es", ri = 2e3, Ia = 2001;
      class fs {
        addEventListener(t, e) {
          this._listeners === void 0 && (this._listeners = {});
          const i = this._listeners;
          i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
        }
        hasEventListener(t, e) {
          const i = this._listeners;
          return i === void 0 ? false : i[t] !== void 0 && i[t].indexOf(e) !== -1;
        }
        removeEventListener(t, e) {
          const i = this._listeners;
          if (i === void 0) return;
          const s = i[t];
          if (s !== void 0) {
            const r = s.indexOf(e);
            r !== -1 && s.splice(r, 1);
          }
        }
        dispatchEvent(t) {
          const e = this._listeners;
          if (e === void 0) return;
          const i = e[t.type];
          if (i !== void 0) {
            t.target = this;
            const s = i.slice(0);
            for (let r = 0, o = s.length; r < o; r++) s[r].call(this, t);
            t.target = null;
          }
        }
      }
      const Xe = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
      ], Hr = Math.PI / 180, ch = 180 / Math.PI;
      function Ti() {
        const n = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
        return (Xe[n & 255] + Xe[n >> 8 & 255] + Xe[n >> 16 & 255] + Xe[n >> 24 & 255] + "-" + Xe[t & 255] + Xe[t >> 8 & 255] + "-" + Xe[t >> 16 & 15 | 64] + Xe[t >> 24 & 255] + "-" + Xe[e & 63 | 128] + Xe[e >> 8 & 255] + "-" + Xe[e >> 16 & 255] + Xe[e >> 24 & 255] + Xe[i & 255] + Xe[i >> 8 & 255] + Xe[i >> 16 & 255] + Xe[i >> 24 & 255]).toLowerCase();
      }
      function $t(n, t, e) {
        return Math.max(t, Math.min(e, n));
      }
      function Cx(n, t) {
        return (n % t + t) % t;
      }
      function Ml(n, t, e) {
        return (1 - e) * n + e * t;
      }
      function Un(n, t) {
        switch (t.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return n / 4294967295;
          case Uint16Array:
            return n / 65535;
          case Uint8Array:
            return n / 255;
          case Int32Array:
            return Math.max(n / 2147483647, -1);
          case Int16Array:
            return Math.max(n / 32767, -1);
          case Int8Array:
            return Math.max(n / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function de(n, t) {
        switch (t.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return Math.round(n * 4294967295);
          case Uint16Array:
            return Math.round(n * 65535);
          case Uint8Array:
            return Math.round(n * 255);
          case Int32Array:
            return Math.round(n * 2147483647);
          case Int16Array:
            return Math.round(n * 32767);
          case Int8Array:
            return Math.round(n * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const Rx = {
        DEG2RAD: Hr
      };
      class Ft {
        constructor(t = 0, e = 0) {
          Ft.prototype.isVector2 = true, this.x = t, this.y = e;
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return this.x = t, this.y = e, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this;
        }
        addVectors(t, e) {
          return this.x = t.x + e.x, this.y = t.y + e.y, this;
        }
        addScaledVector(t, e) {
          return this.x += t.x * e, this.y += t.y * e, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this;
        }
        subVectors(t, e) {
          return this.x = t.x - e.x, this.y = t.y - e.y, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this;
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const e = this.x, i = this.y, s = t.elements;
          return this.x = s[0] * e + s[3] * i + s[6], this.y = s[1] * e + s[4] * i + s[7], this;
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
        }
        clamp(t, e) {
          return this.x = $t(this.x, t.x, e.x), this.y = $t(this.y, t.y, e.y), this;
        }
        clampScalar(t, e) {
          return this.x = $t(this.x, t, e), this.y = $t(this.y, t, e), this;
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar($t(i, t, e));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (e === 0) return Math.PI / 2;
          const i = this.dot(t) / e;
          return Math.acos($t(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x, i = this.y - t.y;
          return e * e + i * i;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
        }
        lerpVectors(t, e, i) {
          return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return this.x = t[e], this.y = t[e + 1], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.x, t[e + 1] = this.y, t;
        }
        fromBufferAttribute(t, e) {
          return this.x = t.getX(e), this.y = t.getY(e), this;
        }
        rotateAround(t, e) {
          const i = Math.cos(e), s = Math.sin(e), r = this.x - t.x, o = this.y - t.y;
          return this.x = r * i - o * s + t.x, this.y = r * s + o * i + t.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Xt {
        constructor(t, e, i, s, r, o, a, l, c) {
          Xt.prototype.isMatrix3 = true, this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], t !== void 0 && this.set(t, e, i, s, r, o, a, l, c);
        }
        set(t, e, i, s, r, o, a, l, c) {
          const h = this.elements;
          return h[0] = t, h[1] = s, h[2] = a, h[3] = e, h[4] = r, h[5] = l, h[6] = i, h[7] = o, h[8] = c, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const e = this.elements, i = t.elements;
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
        }
        extractBasis(t, e, i) {
          return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(t) {
          const e = t.elements;
          return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const i = t.elements, s = e.elements, r = this.elements, o = i[0], a = i[3], l = i[6], c = i[1], h = i[4], u = i[7], d = i[2], f = i[5], g = i[8], _ = s[0], m = s[3], p = s[6], y = s[1], w = s[4], M = s[7], C = s[2], R = s[5], T = s[8];
          return r[0] = o * _ + a * y + l * C, r[3] = o * m + a * w + l * R, r[6] = o * p + a * M + l * T, r[1] = c * _ + h * y + u * C, r[4] = c * m + h * w + u * R, r[7] = c * p + h * M + u * T, r[2] = d * _ + f * y + g * C, r[5] = d * m + f * w + g * R, r[8] = d * p + f * M + g * T, this;
        }
        multiplyScalar(t) {
          const e = this.elements;
          return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
        }
        determinant() {
          const t = this.elements, e = t[0], i = t[1], s = t[2], r = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8];
          return e * o * h - e * a * c - i * r * h + i * a * l + s * r * c - s * o * l;
        }
        invert() {
          const t = this.elements, e = t[0], i = t[1], s = t[2], r = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8], u = h * o - a * c, d = a * l - h * r, f = c * r - o * l, g = e * u + i * d + s * f;
          if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const _ = 1 / g;
          return t[0] = u * _, t[1] = (s * c - h * i) * _, t[2] = (a * i - s * o) * _, t[3] = d * _, t[4] = (h * e - s * l) * _, t[5] = (s * r - a * e) * _, t[6] = f * _, t[7] = (i * l - c * e) * _, t[8] = (o * e - i * r) * _, this;
        }
        transpose() {
          let t;
          const e = this.elements;
          return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const e = this.elements;
          return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
        }
        setUvTransform(t, e, i, s, r, o, a) {
          const l = Math.cos(r), c = Math.sin(r);
          return this.set(i * l, i * c, -i * (l * o + c * a) + o + t, -s * c, s * l, -s * (-c * o + l * a) + a + e, 0, 0, 1), this;
        }
        scale(t, e) {
          return this.premultiply(Sl.makeScale(t, e)), this;
        }
        rotate(t) {
          return this.premultiply(Sl.makeRotation(-t)), this;
        }
        translate(t, e) {
          return this.premultiply(Sl.makeTranslation(t, e)), this;
        }
        makeTranslation(t, e) {
          return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
        }
        makeRotation(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this;
        }
        makeScale(t, e) {
          return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
        }
        equals(t) {
          const e = this.elements, i = t.elements;
          for (let s = 0; s < 9; s++) if (e[s] !== i[s]) return false;
          return true;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const i = this.elements;
          return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Sl = new Xt();
      function Dm(n) {
        for (let t = n.length - 1; t >= 0; --t) if (n[t] >= 65535) return true;
        return false;
      }
      function Oa(n) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", n);
      }
      function Px() {
        const n = Oa("canvas");
        return n.style.display = "block", n;
      }
      const ed = {};
      function wa(n) {
        n in ed || (ed[n] = true, console.warn(n));
      }
      function Dx(n, t, e) {
        return new Promise(function(i, s) {
          function r() {
            switch (n.clientWaitSync(t, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case n.WAIT_FAILED:
                s();
                break;
              case n.TIMEOUT_EXPIRED:
                setTimeout(r, e);
                break;
              default:
                i();
            }
          }
          setTimeout(r, e);
        });
      }
      function Lx(n) {
        const t = n.elements;
        t[2] = 0.5 * t[2] + 0.5 * t[3], t[6] = 0.5 * t[6] + 0.5 * t[7], t[10] = 0.5 * t[10] + 0.5 * t[11], t[14] = 0.5 * t[14] + 0.5 * t[15];
      }
      function Ix(n) {
        const t = n.elements;
        t[11] === -1 ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = -t[14] + 1);
      }
      const nd = new Xt().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), id = new Xt().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
      function Ox() {
        const n = {
          enabled: true,
          workingColorSpace: er,
          spaces: {},
          convert: function(s, r, o) {
            return this.enabled === false || r === o || !r || !o || (this.spaces[r].transfer === ue && (s.r = ci(s.r), s.g = ci(s.g), s.b = ci(s.b)), this.spaces[r].primaries !== this.spaces[o].primaries && (s.applyMatrix3(this.spaces[r].toXYZ), s.applyMatrix3(this.spaces[o].fromXYZ)), this.spaces[o].transfer === ue && (s.r = qs(s.r), s.g = qs(s.g), s.b = qs(s.b))), s;
          },
          fromWorkingColorSpace: function(s, r) {
            return this.convert(s, this.workingColorSpace, r);
          },
          toWorkingColorSpace: function(s, r) {
            return this.convert(s, r, this.workingColorSpace);
          },
          getPrimaries: function(s) {
            return this.spaces[s].primaries;
          },
          getTransfer: function(s) {
            return s === yi ? La : this.spaces[s].transfer;
          },
          getLuminanceCoefficients: function(s, r = this.workingColorSpace) {
            return s.fromArray(this.spaces[r].luminanceCoefficients);
          },
          define: function(s) {
            Object.assign(this.spaces, s);
          },
          _getMatrix: function(s, r, o) {
            return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[o].fromXYZ);
          },
          _getDrawingBufferColorSpace: function(s) {
            return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
          },
          _getUnpackColorSpace: function(s = this.workingColorSpace) {
            return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
          }
        }, t = [
          0.64,
          0.33,
          0.3,
          0.6,
          0.15,
          0.06
        ], e = [
          0.2126,
          0.7152,
          0.0722
        ], i = [
          0.3127,
          0.329
        ];
        return n.define({
          [er]: {
            primaries: t,
            whitePoint: i,
            transfer: La,
            toXYZ: nd,
            fromXYZ: id,
            luminanceCoefficients: e,
            workingColorSpaceConfig: {
              unpackColorSpace: Sn
            },
            outputColorSpaceConfig: {
              drawingBufferColorSpace: Sn
            }
          },
          [Sn]: {
            primaries: t,
            whitePoint: i,
            transfer: ue,
            toXYZ: nd,
            fromXYZ: id,
            luminanceCoefficients: e,
            outputColorSpaceConfig: {
              drawingBufferColorSpace: Sn
            }
          }
        }), n;
      }
      const ee = Ox();
      function ci(n) {
        return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
      }
      function qs(n) {
        return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
      }
      let Ms;
      class kx {
        static getDataURL(t, e = "image/png") {
          if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
          let i;
          if (t instanceof HTMLCanvasElement) i = t;
          else {
            Ms === void 0 && (Ms = Oa("canvas")), Ms.width = t.width, Ms.height = t.height;
            const s = Ms.getContext("2d");
            t instanceof ImageData ? s.putImageData(t, 0, 0) : s.drawImage(t, 0, 0, t.width, t.height), i = Ms;
          }
          return i.toDataURL(e);
        }
        static sRGBToLinear(t) {
          if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
            const e = Oa("canvas");
            e.width = t.width, e.height = t.height;
            const i = e.getContext("2d");
            i.drawImage(t, 0, 0, t.width, t.height);
            const s = i.getImageData(0, 0, t.width, t.height), r = s.data;
            for (let o = 0; o < r.length; o++) r[o] = ci(r[o] / 255) * 255;
            return i.putImageData(s, 0, 0), e;
          } else if (t.data) {
            const e = t.data.slice(0);
            for (let i = 0; i < e.length; i++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[i] = Math.floor(ci(e[i] / 255) * 255) : e[i] = ci(e[i]);
            return {
              data: e,
              width: t.width,
              height: t.height
            };
          } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
        }
      }
      let Fx = 0;
      class Yh {
        constructor(t = null) {
          this.isSource = true, Object.defineProperty(this, "id", {
            value: Fx++
          }), this.uuid = Ti(), this.data = t, this.dataReady = true, this.version = 0;
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
          const i = {
            uuid: this.uuid,
            url: ""
          }, s = this.data;
          if (s !== null) {
            let r;
            if (Array.isArray(s)) {
              r = [];
              for (let o = 0, a = s.length; o < a; o++) s[o].isDataTexture ? r.push(wl(s[o].image)) : r.push(wl(s[o]));
            } else r = wl(s);
            i.url = r;
          }
          return e || (t.images[this.uuid] = i), i;
        }
      }
      function wl(n) {
        return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? kx.getDataURL(n) : n.data ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let Nx = 0;
      class tn extends fs {
        constructor(t = tn.DEFAULT_IMAGE, e = tn.DEFAULT_MAPPING, i = ns, s = ns, r = _n, o = is, a = Pn, l = Vn, c = tn.DEFAULT_ANISOTROPY, h = yi) {
          super(), this.isTexture = true, Object.defineProperty(this, "id", {
            value: Nx++
          }), this.uuid = Ti(), this.name = "", this.source = new Yh(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = i, this.wrapT = s, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Ft(0, 0), this.repeat = new Ft(1, 1), this.center = new Ft(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Xt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.isTextureArray = false, this.pmremVersion = 0;
        }
        get image() {
          return this.source.data;
        }
        set image(t = null) {
          this.source.data = t;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.isTextureArray = t.isTextureArray, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = true, this;
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [
              this.repeat.x,
              this.repeat.y
            ],
            offset: [
              this.offset.x,
              this.offset.y
            ],
            center: [
              this.center.x,
              this.center.y
            ],
            rotation: this.rotation,
            wrap: [
              this.wrapS,
              this.wrapT
            ],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(t) {
          if (this.mapping !== ym) return t;
          if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
            case Oc:
              t.x = t.x - Math.floor(t.x);
              break;
            case ns:
              t.x = t.x < 0 ? 0 : 1;
              break;
            case kc:
              Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
              break;
          }
          if (t.y < 0 || t.y > 1) switch (this.wrapT) {
            case Oc:
              t.y = t.y - Math.floor(t.y);
              break;
            case ns:
              t.y = t.y < 0 ? 0 : 1;
              break;
            case kc:
              Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
              break;
          }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          t === true && (this.version++, this.source.needsUpdate = true);
        }
        set needsPMREMUpdate(t) {
          t === true && this.pmremVersion++;
        }
      }
      tn.DEFAULT_IMAGE = null;
      tn.DEFAULT_MAPPING = ym;
      tn.DEFAULT_ANISOTROPY = 1;
      class pe {
        constructor(t = 0, e = 0, i = 0, s = 1) {
          pe.prototype.isVector4 = true, this.x = t, this.y = e, this.z = i, this.w = s;
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, i, s) {
          return this.x = t, this.y = e, this.z = i, this.w = s, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this.z = t, this.w = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setZ(t) {
          return this.z = t, this;
        }
        setW(t) {
          return this.w = t, this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this.z += t, this.w += t, this;
        }
        addVectors(t, e) {
          return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
        }
        addScaledVector(t, e) {
          return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
        }
        subVectors(t, e) {
          return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
        }
        applyMatrix4(t) {
          const e = this.x, i = this.y, s = this.z, r = this.w, o = t.elements;
          return this.x = o[0] * e + o[4] * i + o[8] * s + o[12] * r, this.y = o[1] * e + o[5] * i + o[9] * s + o[13] * r, this.z = o[2] * e + o[6] * i + o[10] * s + o[14] * r, this.w = o[3] * e + o[7] * i + o[11] * s + o[15] * r, this;
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, i, s, r;
          const l = t.elements, c = l[0], h = l[4], u = l[8], d = l[1], f = l[5], g = l[9], _ = l[2], m = l[6], p = l[10];
          if (Math.abs(h - d) < 0.01 && Math.abs(u - _) < 0.01 && Math.abs(g - m) < 0.01) {
            if (Math.abs(h + d) < 0.1 && Math.abs(u + _) < 0.1 && Math.abs(g + m) < 0.1 && Math.abs(c + f + p - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const w = (c + 1) / 2, M = (f + 1) / 2, C = (p + 1) / 2, R = (h + d) / 4, T = (u + _) / 4, v = (g + m) / 4;
            return w > M && w > C ? w < 0.01 ? (i = 0, s = 0.707106781, r = 0.707106781) : (i = Math.sqrt(w), s = R / i, r = T / i) : M > C ? M < 0.01 ? (i = 0.707106781, s = 0, r = 0.707106781) : (s = Math.sqrt(M), i = R / s, r = v / s) : C < 0.01 ? (i = 0.707106781, s = 0.707106781, r = 0) : (r = Math.sqrt(C), i = T / r, s = v / r), this.set(i, s, r, e), this;
          }
          let y = Math.sqrt((m - g) * (m - g) + (u - _) * (u - _) + (d - h) * (d - h));
          return Math.abs(y) < 1e-3 && (y = 1), this.x = (m - g) / y, this.y = (u - _) / y, this.z = (d - h) / y, this.w = Math.acos((c + f + p - 1) / 2), this;
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this;
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
        }
        clamp(t, e) {
          return this.x = $t(this.x, t.x, e.x), this.y = $t(this.y, t.y, e.y), this.z = $t(this.z, t.z, e.z), this.w = $t(this.w, t.w, e.w), this;
        }
        clampScalar(t, e) {
          return this.x = $t(this.x, t, e), this.y = $t(this.y, t, e), this.z = $t(this.z, t, e), this.w = $t(this.w, t, e), this;
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar($t(i, t, e));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
        }
        lerpVectors(t, e, i) {
          return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
        }
        fromArray(t, e = 0) {
          return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
        }
        fromBufferAttribute(t, e) {
          return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class Ux extends fs {
        constructor(t = 1, e = 1, i = {}) {
          super(), this.isRenderTarget = true, this.width = t, this.height = e, this.depth = i.depth ? i.depth : 1, this.scissor = new pe(0, 0, t, e), this.scissorTest = false, this.viewport = new pe(0, 0, t, e);
          const s = {
            width: t,
            height: e,
            depth: this.depth
          };
          i = Object.assign({
            generateMipmaps: false,
            internalFormat: null,
            minFilter: _n,
            depthBuffer: true,
            stencilBuffer: false,
            resolveDepthBuffer: true,
            resolveStencilBuffer: true,
            depthTexture: null,
            samples: 0,
            count: 1,
            multiview: false
          }, i);
          const r = new tn(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
          r.flipY = false, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
          const o = i.count;
          for (let a = 0; a < o; a++) this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = true, this.textures[a].renderTarget = this;
          this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples, this.multiview = i.multiview;
        }
        get texture() {
          return this.textures[0];
        }
        set texture(t) {
          this.textures[0] = t;
        }
        set depthTexture(t) {
          this._depthTexture !== null && (this._depthTexture.renderTarget = null), t !== null && (t.renderTarget = this), this._depthTexture = t;
        }
        get depthTexture() {
          return this._depthTexture;
        }
        setSize(t, e, i = 1) {
          if (this.width !== t || this.height !== e || this.depth !== i) {
            this.width = t, this.height = e, this.depth = i;
            for (let s = 0, r = this.textures.length; s < r; s++) this.textures[s].image.width = t, this.textures[s].image.height = e, this.textures[s].image.depth = i;
            this.dispose();
          }
          this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
          for (let e = 0, i = t.textures.length; e < i; e++) {
            this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = true, this.textures[e].renderTarget = this;
            const s = Object.assign({}, t.textures[e].image);
            this.textures[e].source = new Yh(s);
          }
          return this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class as extends Ux {
        constructor(t = 1, e = 1, i = {}) {
          super(t, e, i), this.isWebGLRenderTarget = true;
        }
      }
      class Lm extends tn {
        constructor(t = null, e = 1, i = 1, s = 1) {
          super(null), this.isDataArrayTexture = true, this.image = {
            data: t,
            width: e,
            height: i,
            depth: s
          }, this.magFilter = Ln, this.minFilter = Ln, this.wrapR = ns, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(t) {
          this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class Bx extends tn {
        constructor(t = null, e = 1, i = 1, s = 1) {
          super(null), this.isData3DTexture = true, this.image = {
            data: t,
            width: e,
            height: i,
            depth: s
          }, this.magFilter = Ln, this.minFilter = Ln, this.wrapR = ns, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      class ls {
        constructor(t = 0, e = 0, i = 0, s = 1) {
          this.isQuaternion = true, this._x = t, this._y = e, this._z = i, this._w = s;
        }
        static slerpFlat(t, e, i, s, r, o, a) {
          let l = i[s + 0], c = i[s + 1], h = i[s + 2], u = i[s + 3];
          const d = r[o + 0], f = r[o + 1], g = r[o + 2], _ = r[o + 3];
          if (a === 0) {
            t[e + 0] = l, t[e + 1] = c, t[e + 2] = h, t[e + 3] = u;
            return;
          }
          if (a === 1) {
            t[e + 0] = d, t[e + 1] = f, t[e + 2] = g, t[e + 3] = _;
            return;
          }
          if (u !== _ || l !== d || c !== f || h !== g) {
            let m = 1 - a;
            const p = l * d + c * f + h * g + u * _, y = p >= 0 ? 1 : -1, w = 1 - p * p;
            if (w > Number.EPSILON) {
              const C = Math.sqrt(w), R = Math.atan2(C, p * y);
              m = Math.sin(m * R) / C, a = Math.sin(a * R) / C;
            }
            const M = a * y;
            if (l = l * m + d * M, c = c * m + f * M, h = h * m + g * M, u = u * m + _ * M, m === 1 - a) {
              const C = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
              l *= C, c *= C, h *= C, u *= C;
            }
          }
          t[e] = l, t[e + 1] = c, t[e + 2] = h, t[e + 3] = u;
        }
        static multiplyQuaternionsFlat(t, e, i, s, r, o) {
          const a = i[s], l = i[s + 1], c = i[s + 2], h = i[s + 3], u = r[o], d = r[o + 1], f = r[o + 2], g = r[o + 3];
          return t[e] = a * g + h * u + l * f - c * d, t[e + 1] = l * g + h * d + c * u - a * f, t[e + 2] = c * g + h * f + a * d - l * u, t[e + 3] = h * g - a * u - l * d - c * f, t;
        }
        get x() {
          return this._x;
        }
        set x(t) {
          this._x = t, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          this._y = t, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          this._z = t, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          this._w = t, this._onChangeCallback();
        }
        set(t, e, i, s) {
          return this._x = t, this._y = e, this._z = i, this._w = s, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
        }
        setFromEuler(t, e = true) {
          const i = t._x, s = t._y, r = t._z, o = t._order, a = Math.cos, l = Math.sin, c = a(i / 2), h = a(s / 2), u = a(r / 2), d = l(i / 2), f = l(s / 2), g = l(r / 2);
          switch (o) {
            case "XYZ":
              this._x = d * h * u + c * f * g, this._y = c * f * u - d * h * g, this._z = c * h * g + d * f * u, this._w = c * h * u - d * f * g;
              break;
            case "YXZ":
              this._x = d * h * u + c * f * g, this._y = c * f * u - d * h * g, this._z = c * h * g - d * f * u, this._w = c * h * u + d * f * g;
              break;
            case "ZXY":
              this._x = d * h * u - c * f * g, this._y = c * f * u + d * h * g, this._z = c * h * g + d * f * u, this._w = c * h * u - d * f * g;
              break;
            case "ZYX":
              this._x = d * h * u - c * f * g, this._y = c * f * u + d * h * g, this._z = c * h * g - d * f * u, this._w = c * h * u + d * f * g;
              break;
            case "YZX":
              this._x = d * h * u + c * f * g, this._y = c * f * u + d * h * g, this._z = c * h * g - d * f * u, this._w = c * h * u - d * f * g;
              break;
            case "XZY":
              this._x = d * h * u - c * f * g, this._y = c * f * u - d * h * g, this._z = c * h * g + d * f * u, this._w = c * h * u + d * f * g;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
          }
          return e === true && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          const i = e / 2, s = Math.sin(i);
          return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(i), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t) {
          const e = t.elements, i = e[0], s = e[4], r = e[8], o = e[1], a = e[5], l = e[9], c = e[2], h = e[6], u = e[10], d = i + a + u;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            this._w = 0.25 / f, this._x = (h - l) * f, this._y = (r - c) * f, this._z = (o - s) * f;
          } else if (i > a && i > u) {
            const f = 2 * Math.sqrt(1 + i - a - u);
            this._w = (h - l) / f, this._x = 0.25 * f, this._y = (s + o) / f, this._z = (r + c) / f;
          } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - i - u);
            this._w = (r - c) / f, this._x = (s + o) / f, this._y = 0.25 * f, this._z = (l + h) / f;
          } else {
            const f = 2 * Math.sqrt(1 + u - i - a);
            this._w = (o - s) / f, this._x = (r + c) / f, this._y = (l + h) / f, this._z = 0.25 * f;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let i = t.dot(e) + 1;
          return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs($t(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          const i = this.angleTo(t);
          if (i === 0) return this;
          const s = Math.min(1, e / i);
          return this.slerp(t, s), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(t) {
          return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let t = this.length();
          return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
        }
        multiply(t) {
          return this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          const i = t._x, s = t._y, r = t._z, o = t._w, a = e._x, l = e._y, c = e._z, h = e._w;
          return this._x = i * h + o * a + s * c - r * l, this._y = s * h + o * l + r * a - i * c, this._z = r * h + o * c + i * l - s * a, this._w = o * h - i * a - s * l - r * c, this._onChangeCallback(), this;
        }
        slerp(t, e) {
          if (e === 0) return this;
          if (e === 1) return this.copy(t);
          const i = this._x, s = this._y, r = this._z, o = this._w;
          let a = o * t._w + i * t._x + s * t._y + r * t._z;
          if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = i, this._y = s, this._z = r, this;
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - e;
            return this._w = f * o + e * this._w, this._x = f * i + e * this._x, this._y = f * s + e * this._y, this._z = f * r + e * this._z, this.normalize(), this;
          }
          const c = Math.sqrt(l), h = Math.atan2(c, a), u = Math.sin((1 - e) * h) / c, d = Math.sin(e * h) / c;
          return this._w = o * u + this._w * d, this._x = i * u + this._x * d, this._y = s * u + this._y * d, this._z = r * u + this._z * d, this._onChangeCallback(), this;
        }
        slerpQuaternions(t, e, i) {
          return this.copy(t).slerp(e, i);
        }
        random() {
          const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), i = Math.random(), s = Math.sqrt(1 - i), r = Math.sqrt(i);
          return this.set(s * Math.sin(t), s * Math.cos(t), r * Math.sin(e), r * Math.cos(e));
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
        }
        fromArray(t, e = 0) {
          return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
        }
        fromBufferAttribute(t, e) {
          return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(t) {
          return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class O {
        constructor(t = 0, e = 0, i = 0) {
          O.prototype.isVector3 = true, this.x = t, this.y = e, this.z = i;
        }
        set(t, e, i) {
          return i === void 0 && (i = this.z), this.x = t, this.y = e, this.z = i, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this.z = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setZ(t) {
          return this.z = t, this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this.z += t.z, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this.z += t, this;
        }
        addVectors(t, e) {
          return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
        }
        addScaledVector(t, e) {
          return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this.z -= t, this;
        }
        subVectors(t, e) {
          return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this.z *= t, this;
        }
        multiplyVectors(t, e) {
          return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
        }
        applyEuler(t) {
          return this.applyQuaternion(sd.setFromEuler(t));
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(sd.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          const e = this.x, i = this.y, s = this.z, r = t.elements;
          return this.x = r[0] * e + r[3] * i + r[6] * s, this.y = r[1] * e + r[4] * i + r[7] * s, this.z = r[2] * e + r[5] * i + r[8] * s, this;
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const e = this.x, i = this.y, s = this.z, r = t.elements, o = 1 / (r[3] * e + r[7] * i + r[11] * s + r[15]);
          return this.x = (r[0] * e + r[4] * i + r[8] * s + r[12]) * o, this.y = (r[1] * e + r[5] * i + r[9] * s + r[13]) * o, this.z = (r[2] * e + r[6] * i + r[10] * s + r[14]) * o, this;
        }
        applyQuaternion(t) {
          const e = this.x, i = this.y, s = this.z, r = t.x, o = t.y, a = t.z, l = t.w, c = 2 * (o * s - a * i), h = 2 * (a * e - r * s), u = 2 * (r * i - o * e);
          return this.x = e + l * c + o * u - a * h, this.y = i + l * h + a * c - r * u, this.z = s + l * u + r * h - o * c, this;
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
        }
        transformDirection(t) {
          const e = this.x, i = this.y, s = this.z, r = t.elements;
          return this.x = r[0] * e + r[4] * i + r[8] * s, this.y = r[1] * e + r[5] * i + r[9] * s, this.z = r[2] * e + r[6] * i + r[10] * s, this.normalize();
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
        }
        clamp(t, e) {
          return this.x = $t(this.x, t.x, e.x), this.y = $t(this.y, t.y, e.y), this.z = $t(this.z, t.z, e.z), this;
        }
        clampScalar(t, e) {
          return this.x = $t(this.x, t, e), this.y = $t(this.y, t, e), this.z = $t(this.z, t, e), this;
        }
        clampLength(t, e) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar($t(i, t, e));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
        }
        lerpVectors(t, e, i) {
          return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
        }
        cross(t) {
          return this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          const i = t.x, s = t.y, r = t.z, o = e.x, a = e.y, l = e.z;
          return this.x = s * l - r * a, this.y = r * o - i * l, this.z = i * a - s * o, this;
        }
        projectOnVector(t) {
          const e = t.lengthSq();
          if (e === 0) return this.set(0, 0, 0);
          const i = t.dot(this) / e;
          return this.copy(t).multiplyScalar(i);
        }
        projectOnPlane(t) {
          return El.copy(this).projectOnVector(t), this.sub(El);
        }
        reflect(t) {
          return this.sub(El.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (e === 0) return Math.PI / 2;
          const i = this.dot(t) / e;
          return Math.acos($t(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x, i = this.y - t.y, s = this.z - t.z;
          return e * e + i * i + s * s;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, i) {
          const s = Math.sin(e) * t;
          return this.x = s * Math.sin(i), this.y = Math.cos(e) * t, this.z = s * Math.cos(i), this;
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, i) {
          return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return this.x = e[12], this.y = e[13], this.z = e[14], this;
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), s = this.setFromMatrixColumn(t, 2).length();
          return this.x = e, this.y = i, this.z = s, this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, e * 4);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, e * 3);
        }
        setFromEuler(t) {
          return this.x = t._x, this.y = t._y, this.z = t._z, this;
        }
        setFromColor(t) {
          return this.x = t.r, this.y = t.g, this.z = t.b, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
        }
        fromBufferAttribute(t, e) {
          return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, i = Math.sqrt(1 - e * e);
          return this.x = i * Math.cos(t), this.y = e, this.z = i * Math.sin(t), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const El = new O(), sd = new ls();
      class ao {
        constructor(t = new O(1 / 0, 1 / 0, 1 / 0), e = new O(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = true, this.min = t, this.max = e;
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e += 3) this.expandByPoint(An.fromArray(t, e));
          return this;
        }
        setFromBufferAttribute(t) {
          this.makeEmpty();
          for (let e = 0, i = t.count; e < i; e++) this.expandByPoint(An.fromBufferAttribute(t, e));
          return this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const i = An.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }
        setFromObject(t, e = false) {
          return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = false) {
          t.updateWorldMatrix(false, false);
          const i = t.geometry;
          if (i !== void 0) {
            const r = i.getAttribute("position");
            if (e === true && r !== void 0 && t.isInstancedMesh !== true) for (let o = 0, a = r.count; o < a; o++) t.isMesh === true ? t.getVertexPosition(o, An) : An.fromBufferAttribute(r, o), An.applyMatrix4(t.matrixWorld), this.expandByPoint(An);
            else t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), Eo.copy(t.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Eo.copy(i.boundingBox)), Eo.applyMatrix4(t.matrixWorld), this.union(Eo);
          }
          const s = t.children;
          for (let r = 0, o = s.length; r < o; r++) this.expandByObject(s[r], e);
          return this;
        }
        containsPoint(t) {
          return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
        }
        containsBox(t) {
          return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
        }
        getParameter(t, e) {
          return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(t) {
          return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z;
        }
        intersectsSphere(t) {
          return this.clampPoint(t.center, An), An.distanceToSquared(t.center) <= t.radius * t.radius;
        }
        intersectsPlane(t) {
          let e, i;
          return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return false;
          this.getCenter(mr), To.subVectors(this.max, mr), Ss.subVectors(t.a, mr), ws.subVectors(t.b, mr), Es.subVectors(t.c, mr), ui.subVectors(ws, Ss), di.subVectors(Es, ws), zi.subVectors(Ss, Es);
          let e = [
            0,
            -ui.z,
            ui.y,
            0,
            -di.z,
            di.y,
            0,
            -zi.z,
            zi.y,
            ui.z,
            0,
            -ui.x,
            di.z,
            0,
            -di.x,
            zi.z,
            0,
            -zi.x,
            -ui.y,
            ui.x,
            0,
            -di.y,
            di.x,
            0,
            -zi.y,
            zi.x,
            0
          ];
          return !Tl(e, Ss, ws, Es, To) || (e = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], !Tl(e, Ss, ws, Es, To)) ? false : (Ao.crossVectors(ui, di), e = [
            Ao.x,
            Ao.y,
            Ao.z
          ], Tl(e, Ss, ws, Es, To));
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return this.clampPoint(t, An).distanceTo(t);
        }
        getBoundingSphere(t) {
          return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(An).length() * 0.5), t;
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return this.isEmpty() ? this : (jn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), jn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), jn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), jn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), jn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), jn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), jn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), jn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(jn), this);
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      const jn = [
        new O(),
        new O(),
        new O(),
        new O(),
        new O(),
        new O(),
        new O(),
        new O()
      ], An = new O(), Eo = new ao(), Ss = new O(), ws = new O(), Es = new O(), ui = new O(), di = new O(), zi = new O(), mr = new O(), To = new O(), Ao = new O(), Hi = new O();
      function Tl(n, t, e, i, s) {
        for (let r = 0, o = n.length - 3; r <= o; r += 3) {
          Hi.fromArray(n, r);
          const a = s.x * Math.abs(Hi.x) + s.y * Math.abs(Hi.y) + s.z * Math.abs(Hi.z), l = t.dot(Hi), c = e.dot(Hi), h = i.dot(Hi);
          if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return false;
        }
        return true;
      }
      const zx = new ao(), gr = new O(), Al = new O();
      class el {
        constructor(t = new O(), e = -1) {
          this.isSphere = true, this.center = t, this.radius = e;
        }
        set(t, e) {
          return this.center.copy(t), this.radius = e, this;
        }
        setFromPoints(t, e) {
          const i = this.center;
          e !== void 0 ? i.copy(e) : zx.setFromPoints(t).getCenter(i);
          let s = 0;
          for (let r = 0, o = t.length; r < o; r++) s = Math.max(s, i.distanceToSquared(t[r]));
          return this.radius = Math.sqrt(s), this;
        }
        copy(t) {
          return this.center.copy(t.center), this.radius = t.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          const i = this.center.distanceToSquared(t);
          return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
        }
        getBoundingBox(t) {
          return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
        }
        applyMatrix4(t) {
          return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
          gr.subVectors(t, this.center);
          const e = gr.lengthSq();
          if (e > this.radius * this.radius) {
            const i = Math.sqrt(e), s = (i - this.radius) * 0.5;
            this.center.addScaledVector(gr, s / i), this.radius += s;
          }
          return this;
        }
        union(t) {
          return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === true ? this.radius = Math.max(this.radius, t.radius) : (Al.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(gr.copy(t.center).add(Al)), this.expandByPoint(gr.copy(t.center).sub(Al))), this);
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const qn = new O(), Cl = new O(), Co = new O(), fi = new O(), Rl = new O(), Ro = new O(), Pl = new O();
      class jh {
        constructor(t = new O(), e = new O(0, 0, -1)) {
          this.origin = t, this.direction = e;
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
        }
        at(t, e) {
          return e.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, qn)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          const i = e.dot(this.direction);
          return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = qn.subVectors(t, this.origin).dot(this.direction);
          return e < 0 ? this.origin.distanceToSquared(t) : (qn.copy(this.origin).addScaledVector(this.direction, e), qn.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, i, s) {
          Cl.copy(t).add(e).multiplyScalar(0.5), Co.copy(e).sub(t).normalize(), fi.copy(this.origin).sub(Cl);
          const r = t.distanceTo(e) * 0.5, o = -this.direction.dot(Co), a = fi.dot(this.direction), l = -fi.dot(Co), c = fi.lengthSq(), h = Math.abs(1 - o * o);
          let u, d, f, g;
          if (h > 0) if (u = o * l - a, d = o * a - l, g = r * h, u >= 0) if (d >= -g) if (d <= g) {
            const _ = 1 / h;
            u *= _, d *= _, f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c;
          } else d = r, u = Math.max(0, -(o * d + a)), f = -u * u + d * (d + 2 * l) + c;
          else d = -r, u = Math.max(0, -(o * d + a)), f = -u * u + d * (d + 2 * l) + c;
          else d <= -g ? (u = Math.max(0, -(-o * r + a)), d = u > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -u * u + d * (d + 2 * l) + c) : d <= g ? (u = 0, d = Math.min(Math.max(-r, -l), r), f = d * (d + 2 * l) + c) : (u = Math.max(0, -(o * r + a)), d = u > 0 ? r : Math.min(Math.max(-r, -l), r), f = -u * u + d * (d + 2 * l) + c);
          else d = o > 0 ? -r : r, u = Math.max(0, -(o * d + a)), f = -u * u + d * (d + 2 * l) + c;
          return i && i.copy(this.origin).addScaledVector(this.direction, u), s && s.copy(Cl).addScaledVector(Co, d), f;
        }
        intersectSphere(t, e) {
          qn.subVectors(t.center, this.origin);
          const i = qn.dot(this.direction), s = qn.dot(qn) - i * i, r = t.radius * t.radius;
          if (s > r) return null;
          const o = Math.sqrt(r - s), a = i - o, l = i + o;
          return l < 0 ? null : a < 0 ? this.at(l, e) : this.at(a, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
          const i = -(this.origin.dot(t.normal) + t.constant) / e;
          return i >= 0 ? i : null;
        }
        intersectPlane(t, e) {
          const i = this.distanceToPlane(t);
          return i === null ? null : this.at(i, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          return e === 0 || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
          let i, s, r, o, a, l;
          const c = 1 / this.direction.x, h = 1 / this.direction.y, u = 1 / this.direction.z, d = this.origin;
          return c >= 0 ? (i = (t.min.x - d.x) * c, s = (t.max.x - d.x) * c) : (i = (t.max.x - d.x) * c, s = (t.min.x - d.x) * c), h >= 0 ? (r = (t.min.y - d.y) * h, o = (t.max.y - d.y) * h) : (r = (t.max.y - d.y) * h, o = (t.min.y - d.y) * h), i > o || r > s || ((r > i || isNaN(i)) && (i = r), (o < s || isNaN(s)) && (s = o), u >= 0 ? (a = (t.min.z - d.z) * u, l = (t.max.z - d.z) * u) : (a = (t.max.z - d.z) * u, l = (t.min.z - d.z) * u), i > l || a > s) || ((a > i || i !== i) && (i = a), (l < s || s !== s) && (s = l), s < 0) ? null : this.at(i >= 0 ? i : s, e);
        }
        intersectsBox(t) {
          return this.intersectBox(t, qn) !== null;
        }
        intersectTriangle(t, e, i, s, r) {
          Rl.subVectors(e, t), Ro.subVectors(i, t), Pl.crossVectors(Rl, Ro);
          let o = this.direction.dot(Pl), a;
          if (o > 0) {
            if (s) return null;
            a = 1;
          } else if (o < 0) a = -1, o = -o;
          else return null;
          fi.subVectors(this.origin, t);
          const l = a * this.direction.dot(Ro.crossVectors(fi, Ro));
          if (l < 0) return null;
          const c = a * this.direction.dot(Rl.cross(fi));
          if (c < 0 || l + c > o) return null;
          const h = -a * fi.dot(Pl);
          return h < 0 ? null : this.at(h / o, r);
        }
        applyMatrix4(t) {
          return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
        }
        equals(t) {
          return t.origin.equals(this.origin) && t.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ye {
        constructor(t, e, i, s, r, o, a, l, c, h, u, d, f, g, _, m) {
          ye.prototype.isMatrix4 = true, this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ], t !== void 0 && this.set(t, e, i, s, r, o, a, l, c, h, u, d, f, g, _, m);
        }
        set(t, e, i, s, r, o, a, l, c, h, u, d, f, g, _, m) {
          const p = this.elements;
          return p[0] = t, p[4] = e, p[8] = i, p[12] = s, p[1] = r, p[5] = o, p[9] = a, p[13] = l, p[2] = c, p[6] = h, p[10] = u, p[14] = d, p[3] = f, p[7] = g, p[11] = _, p[15] = m, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ye().fromArray(this.elements);
        }
        copy(t) {
          const e = this.elements, i = t.elements;
          return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this;
        }
        copyPosition(t) {
          const e = this.elements, i = t.elements;
          return e[12] = i[12], e[13] = i[13], e[14] = i[14], this;
        }
        setFromMatrix3(t) {
          const e = t.elements;
          return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(t, e, i) {
          return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(t, e, i) {
          return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(t) {
          const e = this.elements, i = t.elements, s = 1 / Ts.setFromMatrixColumn(t, 0).length(), r = 1 / Ts.setFromMatrixColumn(t, 1).length(), o = 1 / Ts.setFromMatrixColumn(t, 2).length();
          return e[0] = i[0] * s, e[1] = i[1] * s, e[2] = i[2] * s, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * o, e[9] = i[9] * o, e[10] = i[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
        }
        makeRotationFromEuler(t) {
          const e = this.elements, i = t.x, s = t.y, r = t.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(s), c = Math.sin(s), h = Math.cos(r), u = Math.sin(r);
          if (t.order === "XYZ") {
            const d = o * h, f = o * u, g = a * h, _ = a * u;
            e[0] = l * h, e[4] = -l * u, e[8] = c, e[1] = f + g * c, e[5] = d - _ * c, e[9] = -a * l, e[2] = _ - d * c, e[6] = g + f * c, e[10] = o * l;
          } else if (t.order === "YXZ") {
            const d = l * h, f = l * u, g = c * h, _ = c * u;
            e[0] = d + _ * a, e[4] = g * a - f, e[8] = o * c, e[1] = o * u, e[5] = o * h, e[9] = -a, e[2] = f * a - g, e[6] = _ + d * a, e[10] = o * l;
          } else if (t.order === "ZXY") {
            const d = l * h, f = l * u, g = c * h, _ = c * u;
            e[0] = d - _ * a, e[4] = -o * u, e[8] = g + f * a, e[1] = f + g * a, e[5] = o * h, e[9] = _ - d * a, e[2] = -o * c, e[6] = a, e[10] = o * l;
          } else if (t.order === "ZYX") {
            const d = o * h, f = o * u, g = a * h, _ = a * u;
            e[0] = l * h, e[4] = g * c - f, e[8] = d * c + _, e[1] = l * u, e[5] = _ * c + d, e[9] = f * c - g, e[2] = -c, e[6] = a * l, e[10] = o * l;
          } else if (t.order === "YZX") {
            const d = o * l, f = o * c, g = a * l, _ = a * c;
            e[0] = l * h, e[4] = _ - d * u, e[8] = g * u + f, e[1] = u, e[5] = o * h, e[9] = -a * h, e[2] = -c * h, e[6] = f * u + g, e[10] = d - _ * u;
          } else if (t.order === "XZY") {
            const d = o * l, f = o * c, g = a * l, _ = a * c;
            e[0] = l * h, e[4] = -u, e[8] = c * h, e[1] = d * u + _, e[5] = o * h, e[9] = f * u - g, e[2] = g * u - f, e[6] = a * h, e[10] = _ * u + d;
          }
          return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
        }
        makeRotationFromQuaternion(t) {
          return this.compose(Hx, t, Vx);
        }
        lookAt(t, e, i) {
          const s = this.elements;
          return un.subVectors(t, e), un.lengthSq() === 0 && (un.z = 1), un.normalize(), pi.crossVectors(i, un), pi.lengthSq() === 0 && (Math.abs(i.z) === 1 ? un.x += 1e-4 : un.z += 1e-4, un.normalize(), pi.crossVectors(i, un)), pi.normalize(), Po.crossVectors(un, pi), s[0] = pi.x, s[4] = Po.x, s[8] = un.x, s[1] = pi.y, s[5] = Po.y, s[9] = un.y, s[2] = pi.z, s[6] = Po.z, s[10] = un.z, this;
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const i = t.elements, s = e.elements, r = this.elements, o = i[0], a = i[4], l = i[8], c = i[12], h = i[1], u = i[5], d = i[9], f = i[13], g = i[2], _ = i[6], m = i[10], p = i[14], y = i[3], w = i[7], M = i[11], C = i[15], R = s[0], T = s[4], v = s[8], x = s[12], b = s[1], A = s[5], L = s[9], I = s[13], H = s[2], j = s[6], z = s[10], V = s[14], U = s[3], q = s[7], rt = s[11], et = s[15];
          return r[0] = o * R + a * b + l * H + c * U, r[4] = o * T + a * A + l * j + c * q, r[8] = o * v + a * L + l * z + c * rt, r[12] = o * x + a * I + l * V + c * et, r[1] = h * R + u * b + d * H + f * U, r[5] = h * T + u * A + d * j + f * q, r[9] = h * v + u * L + d * z + f * rt, r[13] = h * x + u * I + d * V + f * et, r[2] = g * R + _ * b + m * H + p * U, r[6] = g * T + _ * A + m * j + p * q, r[10] = g * v + _ * L + m * z + p * rt, r[14] = g * x + _ * I + m * V + p * et, r[3] = y * R + w * b + M * H + C * U, r[7] = y * T + w * A + M * j + C * q, r[11] = y * v + w * L + M * z + C * rt, r[15] = y * x + w * I + M * V + C * et, this;
        }
        multiplyScalar(t) {
          const e = this.elements;
          return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
        }
        determinant() {
          const t = this.elements, e = t[0], i = t[4], s = t[8], r = t[12], o = t[1], a = t[5], l = t[9], c = t[13], h = t[2], u = t[6], d = t[10], f = t[14], g = t[3], _ = t[7], m = t[11], p = t[15];
          return g * (+r * l * u - s * c * u - r * a * d + i * c * d + s * a * f - i * l * f) + _ * (+e * l * f - e * c * d + r * o * d - s * o * f + s * c * h - r * l * h) + m * (+e * c * u - e * a * f - r * o * u + i * o * f + r * a * h - i * c * h) + p * (-s * a * h - e * l * u + e * a * d + s * o * u - i * o * d + i * l * h);
        }
        transpose() {
          const t = this.elements;
          let e;
          return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
        }
        setPosition(t, e, i) {
          const s = this.elements;
          return t.isVector3 ? (s[12] = t.x, s[13] = t.y, s[14] = t.z) : (s[12] = t, s[13] = e, s[14] = i), this;
        }
        invert() {
          const t = this.elements, e = t[0], i = t[1], s = t[2], r = t[3], o = t[4], a = t[5], l = t[6], c = t[7], h = t[8], u = t[9], d = t[10], f = t[11], g = t[12], _ = t[13], m = t[14], p = t[15], y = u * m * c - _ * d * c + _ * l * f - a * m * f - u * l * p + a * d * p, w = g * d * c - h * m * c - g * l * f + o * m * f + h * l * p - o * d * p, M = h * _ * c - g * u * c + g * a * f - o * _ * f - h * a * p + o * u * p, C = g * u * l - h * _ * l - g * a * d + o * _ * d + h * a * m - o * u * m, R = e * y + i * w + s * M + r * C;
          if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const T = 1 / R;
          return t[0] = y * T, t[1] = (_ * d * r - u * m * r - _ * s * f + i * m * f + u * s * p - i * d * p) * T, t[2] = (a * m * r - _ * l * r + _ * s * c - i * m * c - a * s * p + i * l * p) * T, t[3] = (u * l * r - a * d * r - u * s * c + i * d * c + a * s * f - i * l * f) * T, t[4] = w * T, t[5] = (h * m * r - g * d * r + g * s * f - e * m * f - h * s * p + e * d * p) * T, t[6] = (g * l * r - o * m * r - g * s * c + e * m * c + o * s * p - e * l * p) * T, t[7] = (o * d * r - h * l * r + h * s * c - e * d * c - o * s * f + e * l * f) * T, t[8] = M * T, t[9] = (g * u * r - h * _ * r - g * i * f + e * _ * f + h * i * p - e * u * p) * T, t[10] = (o * _ * r - g * a * r + g * i * c - e * _ * c - o * i * p + e * a * p) * T, t[11] = (h * a * r - o * u * r - h * i * c + e * u * c + o * i * f - e * a * f) * T, t[12] = C * T, t[13] = (h * _ * s - g * u * s + g * i * d - e * _ * d - h * i * m + e * u * m) * T, t[14] = (g * a * s - o * _ * s - g * i * l + e * _ * l + o * i * m - e * a * m) * T, t[15] = (o * u * s - h * a * s + h * i * l - e * u * l - o * i * d + e * a * d) * T, this;
        }
        scale(t) {
          const e = this.elements, i = t.x, s = t.y, r = t.z;
          return e[0] *= i, e[4] *= s, e[8] *= r, e[1] *= i, e[5] *= s, e[9] *= r, e[2] *= i, e[6] *= s, e[10] *= r, e[3] *= i, e[7] *= s, e[11] *= r, this;
        }
        getMaxScaleOnAxis() {
          const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, i, s));
        }
        makeTranslation(t, e, i) {
          return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(t) {
          const e = Math.cos(t), i = Math.sin(t);
          return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(t, e) {
          const i = Math.cos(e), s = Math.sin(e), r = 1 - i, o = t.x, a = t.y, l = t.z, c = r * o, h = r * a;
          return this.set(c * o + i, c * a - s * l, c * l + s * a, 0, c * a + s * l, h * a + i, h * l - s * o, 0, c * l - s * a, h * l + s * o, r * l * l + i, 0, 0, 0, 0, 1), this;
        }
        makeScale(t, e, i) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, i, s, r, o) {
          return this.set(1, i, r, 0, t, 1, o, 0, e, s, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, i) {
          const s = this.elements, r = e._x, o = e._y, a = e._z, l = e._w, c = r + r, h = o + o, u = a + a, d = r * c, f = r * h, g = r * u, _ = o * h, m = o * u, p = a * u, y = l * c, w = l * h, M = l * u, C = i.x, R = i.y, T = i.z;
          return s[0] = (1 - (_ + p)) * C, s[1] = (f + M) * C, s[2] = (g - w) * C, s[3] = 0, s[4] = (f - M) * R, s[5] = (1 - (d + p)) * R, s[6] = (m + y) * R, s[7] = 0, s[8] = (g + w) * T, s[9] = (m - y) * T, s[10] = (1 - (d + _)) * T, s[11] = 0, s[12] = t.x, s[13] = t.y, s[14] = t.z, s[15] = 1, this;
        }
        decompose(t, e, i) {
          const s = this.elements;
          let r = Ts.set(s[0], s[1], s[2]).length();
          const o = Ts.set(s[4], s[5], s[6]).length(), a = Ts.set(s[8], s[9], s[10]).length();
          this.determinant() < 0 && (r = -r), t.x = s[12], t.y = s[13], t.z = s[14], Cn.copy(this);
          const c = 1 / r, h = 1 / o, u = 1 / a;
          return Cn.elements[0] *= c, Cn.elements[1] *= c, Cn.elements[2] *= c, Cn.elements[4] *= h, Cn.elements[5] *= h, Cn.elements[6] *= h, Cn.elements[8] *= u, Cn.elements[9] *= u, Cn.elements[10] *= u, e.setFromRotationMatrix(Cn), i.x = r, i.y = o, i.z = a, this;
        }
        makePerspective(t, e, i, s, r, o, a = ri) {
          const l = this.elements, c = 2 * r / (e - t), h = 2 * r / (i - s), u = (e + t) / (e - t), d = (i + s) / (i - s);
          let f, g;
          if (a === ri) f = -(o + r) / (o - r), g = -2 * o * r / (o - r);
          else if (a === Ia) f = -o / (o - r), g = -o * r / (o - r);
          else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
          return l[0] = c, l[4] = 0, l[8] = u, l[12] = 0, l[1] = 0, l[5] = h, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = g, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
        }
        makeOrthographic(t, e, i, s, r, o, a = ri) {
          const l = this.elements, c = 1 / (e - t), h = 1 / (i - s), u = 1 / (o - r), d = (e + t) * c, f = (i + s) * h;
          let g, _;
          if (a === ri) g = (o + r) * u, _ = -2 * u;
          else if (a === Ia) g = r * u, _ = -1 * u;
          else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
          return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -g, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
        }
        equals(t) {
          const e = this.elements, i = t.elements;
          for (let s = 0; s < 16; s++) if (e[s] !== i[s]) return false;
          return true;
        }
        fromArray(t, e = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const i = this.elements;
          return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
        }
      }
      const Ts = new O(), Cn = new ye(), Hx = new O(0, 0, 0), Vx = new O(1, 1, 1), pi = new O(), Po = new O(), un = new O(), rd = new ye(), od = new ls();
      class Wn {
        constructor(t = 0, e = 0, i = 0, s = Wn.DEFAULT_ORDER) {
          this.isEuler = true, this._x = t, this._y = e, this._z = i, this._order = s;
        }
        get x() {
          return this._x;
        }
        set x(t) {
          this._x = t, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          this._y = t, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          this._z = t, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          this._order = t, this._onChangeCallback();
        }
        set(t, e, i, s = this._order) {
          return this._x = t, this._y = e, this._z = i, this._order = s, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t, e = this._order, i = true) {
          const s = t.elements, r = s[0], o = s[4], a = s[8], l = s[1], c = s[5], h = s[9], u = s[2], d = s[6], f = s[10];
          switch (e) {
            case "XYZ":
              this._y = Math.asin($t(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(d, c), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-$t(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin($t(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
              break;
            case "ZYX":
              this._y = Math.asin(-$t(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
              break;
            case "YZX":
              this._z = Math.asin($t(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, f));
              break;
            case "XZY":
              this._z = Math.asin(-$t(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
          }
          return this._order = e, i === true && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, i) {
          return rd.makeRotationFromQuaternion(t), this.setFromRotationMatrix(rd, e, i);
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return od.setFromEuler(this), this.setFromQuaternion(od, t);
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
        }
        fromArray(t) {
          return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
        }
        _onChange(t) {
          return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      Wn.DEFAULT_ORDER = "XYZ";
      class Im {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = (1 << t | 0) >>> 0;
        }
        enable(t) {
          this.mask |= 1 << t | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= 1 << t | 0;
        }
        disable(t) {
          this.mask &= ~(1 << t | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return (this.mask & t.mask) !== 0;
        }
        isEnabled(t) {
          return (this.mask & (1 << t | 0)) !== 0;
        }
      }
      let Wx = 0;
      const ad = new O(), As = new ls(), $n = new ye(), Do = new O(), _r = new O(), Gx = new O(), Xx = new ls(), ld = new O(1, 0, 0), cd = new O(0, 1, 0), hd = new O(0, 0, 1), ud = {
        type: "added"
      }, Yx = {
        type: "removed"
      }, Cs = {
        type: "childadded",
        child: null
      }, Dl = {
        type: "childremoved",
        child: null
      };
      class $e extends fs {
        constructor() {
          super(), this.isObject3D = true, Object.defineProperty(this, "id", {
            value: Wx++
          }), this.uuid = Ti(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = $e.DEFAULT_UP.clone();
          const t = new O(), e = new Wn(), i = new ls(), s = new O(1, 1, 1);
          function r() {
            i.setFromEuler(e, false);
          }
          function o() {
            e.setFromQuaternion(i, void 0, false);
          }
          e._onChange(r), i._onChange(o), Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: t
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: e
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: i
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: s
            },
            modelViewMatrix: {
              value: new ye()
            },
            normalMatrix: {
              value: new Xt()
            }
          }), this.matrix = new ye(), this.matrixWorld = new ye(), this.matrixAutoUpdate = $e.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = $e.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Im(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
        }
        onBeforeShadow() {
        }
        onAfterShadow() {
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, true);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return As.setFromAxisAngle(t, e), this.quaternion.multiply(As), this;
        }
        rotateOnWorldAxis(t, e) {
          return As.setFromAxisAngle(t, e), this.quaternion.premultiply(As), this;
        }
        rotateX(t) {
          return this.rotateOnAxis(ld, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(cd, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(hd, t);
        }
        translateOnAxis(t, e) {
          return ad.copy(t).applyQuaternion(this.quaternion), this.position.add(ad.multiplyScalar(e)), this;
        }
        translateX(t) {
          return this.translateOnAxis(ld, t);
        }
        translateY(t) {
          return this.translateOnAxis(cd, t);
        }
        translateZ(t) {
          return this.translateOnAxis(hd, t);
        }
        localToWorld(t) {
          return this.updateWorldMatrix(true, false), t.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t) {
          return this.updateWorldMatrix(true, false), t.applyMatrix4($n.copy(this.matrixWorld).invert());
        }
        lookAt(t, e, i) {
          t.isVector3 ? Do.copy(t) : Do.set(t, e, i);
          const s = this.parent;
          this.updateWorldMatrix(true, false), _r.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? $n.lookAt(_r, Do, this.up) : $n.lookAt(Do, _r, this.up), this.quaternion.setFromRotationMatrix($n), s && ($n.extractRotation(s.matrixWorld), As.setFromRotationMatrix($n), this.quaternion.premultiply(As.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(ud), Cs.child = t, this.dispatchEvent(Cs), Cs.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
          }
          const e = this.children.indexOf(t);
          return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Yx), Dl.child = t, this.dispatchEvent(Dl), Dl.child = null), this;
        }
        removeFromParent() {
          const t = this.parent;
          return t !== null && t.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(t) {
          return this.updateWorldMatrix(true, false), $n.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(true, false), $n.multiply(t.parent.matrixWorld)), t.applyMatrix4($n), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(false, true), t.dispatchEvent(ud), Cs.child = t, this.dispatchEvent(Cs), Cs.child = null, this;
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let i = 0, s = this.children.length; i < s; i++) {
            const o = this.children[i].getObjectByProperty(t, e);
            if (o !== void 0) return o;
          }
        }
        getObjectsByProperty(t, e, i = []) {
          this[t] === e && i.push(this);
          const s = this.children;
          for (let r = 0, o = s.length; r < o; r++) s[r].getObjectsByProperty(t, e, i);
          return i;
        }
        getWorldPosition(t) {
          return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(t) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(_r, t, Gx), t;
        }
        getWorldScale(t) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(_r, Xx, t), t;
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {
        }
        traverse(t) {
          t(this);
          const e = this.children;
          for (let i = 0, s = e.length; i < s; i++) e[i].traverse(t);
        }
        traverseVisible(t) {
          if (this.visible === false) return;
          t(this);
          const e = this.children;
          for (let i = 0, s = e.length; i < s; i++) e[i].traverseVisible(t);
        }
        traverseAncestors(t) {
          const e = this.parent;
          e !== null && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, t = true);
          const e = this.children;
          for (let i = 0, s = e.length; i < s; i++) e[i].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, e) {
          const i = this.parent;
          if (t === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), e === true) {
            const s = this.children;
            for (let r = 0, o = s.length; r < o; r++) s[r].updateWorldMatrix(false, true);
          }
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string", i = {};
          e && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
          });
          const s = {};
          s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === true && (s.castShadow = true), this.receiveShadow === true && (s.receiveShadow = true), this.visible === false && (s.visible = false), this.frustumCulled === false && (s.frustumCulled = false), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === false && (s.matrixAutoUpdate = false), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.geometryInfo = this._geometryInfo.map((a) => ({
            ...a,
            boundingBox: a.boundingBox ? {
              min: a.boundingBox.min.toArray(),
              max: a.boundingBox.max.toArray()
            } : void 0,
            boundingSphere: a.boundingSphere ? {
              radius: a.boundingSphere.radius,
              center: a.boundingSphere.center.toArray()
            } : void 0
          })), s.instanceInfo = this._instanceInfo.map((a) => ({
            ...a
          })), s.availableInstanceIds = this._availableInstanceIds.slice(), s.availableGeometryIds = this._availableGeometryIds.slice(), s.nextIndexStart = this._nextIndexStart, s.nextVertexStart = this._nextVertexStart, s.geometryCount = this._geometryCount, s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.matricesTexture = this._matricesTexture.toJSON(t), s.indirectTexture = this._indirectTexture.toJSON(t), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (s.boundingSphere = {
            center: this.boundingSphere.center.toArray(),
            radius: this.boundingSphere.radius
          }), this.boundingBox !== null && (s.boundingBox = {
            min: this.boundingBox.min.toArray(),
            max: this.boundingBox.max.toArray()
          }));
          function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid;
          }
          if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (s.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            s.geometry = r(t.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
              const l = a.shapes;
              if (Array.isArray(l)) for (let c = 0, h = l.length; c < h; c++) {
                const u = l[c];
                r(t.shapes, u);
              }
              else r(t.shapes, l);
            }
          }
          if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(t.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const a = [];
            for (let l = 0, c = this.material.length; l < c; l++) a.push(r(t.materials, this.material[l]));
            s.material = a;
          } else s.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            s.children = [];
            for (let a = 0; a < this.children.length; a++) s.children.push(this.children[a].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            s.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
              const l = this.animations[a];
              s.animations.push(r(t.animations, l));
            }
          }
          if (e) {
            const a = o(t.geometries), l = o(t.materials), c = o(t.textures), h = o(t.images), u = o(t.shapes), d = o(t.skeletons), f = o(t.animations), g = o(t.nodes);
            a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), h.length > 0 && (i.images = h), u.length > 0 && (i.shapes = u), d.length > 0 && (i.skeletons = d), f.length > 0 && (i.animations = f), g.length > 0 && (i.nodes = g);
          }
          return i.object = s, i;
          function o(a) {
            const l = [];
            for (const c in a) {
              const h = a[c];
              delete h.metadata, l.push(h);
            }
            return l;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = true) {
          if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === true) for (let i = 0; i < t.children.length; i++) {
            const s = t.children[i];
            this.add(s.clone());
          }
          return this;
        }
      }
      $e.DEFAULT_UP = new O(0, 1, 0);
      $e.DEFAULT_MATRIX_AUTO_UPDATE = true;
      $e.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      const Rn = new O(), Kn = new O(), Ll = new O(), Zn = new O(), Rs = new O(), Ps = new O(), dd = new O(), Il = new O(), Ol = new O(), kl = new O(), Fl = new pe(), Nl = new pe(), Ul = new pe();
      class gn {
        constructor(t = new O(), e = new O(), i = new O()) {
          this.a = t, this.b = e, this.c = i;
        }
        static getNormal(t, e, i, s) {
          s.subVectors(i, e), Rn.subVectors(t, e), s.cross(Rn);
          const r = s.lengthSq();
          return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
        }
        static getBarycoord(t, e, i, s, r) {
          Rn.subVectors(s, e), Kn.subVectors(i, e), Ll.subVectors(t, e);
          const o = Rn.dot(Rn), a = Rn.dot(Kn), l = Rn.dot(Ll), c = Kn.dot(Kn), h = Kn.dot(Ll), u = o * c - a * a;
          if (u === 0) return r.set(0, 0, 0), null;
          const d = 1 / u, f = (c * l - a * h) * d, g = (o * h - a * l) * d;
          return r.set(1 - f - g, g, f);
        }
        static containsPoint(t, e, i, s) {
          return this.getBarycoord(t, e, i, s, Zn) === null ? false : Zn.x >= 0 && Zn.y >= 0 && Zn.x + Zn.y <= 1;
        }
        static getInterpolation(t, e, i, s, r, o, a, l) {
          return this.getBarycoord(t, e, i, s, Zn) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, Zn.x), l.addScaledVector(o, Zn.y), l.addScaledVector(a, Zn.z), l);
        }
        static getInterpolatedAttribute(t, e, i, s, r, o) {
          return Fl.setScalar(0), Nl.setScalar(0), Ul.setScalar(0), Fl.fromBufferAttribute(t, e), Nl.fromBufferAttribute(t, i), Ul.fromBufferAttribute(t, s), o.setScalar(0), o.addScaledVector(Fl, r.x), o.addScaledVector(Nl, r.y), o.addScaledVector(Ul, r.z), o;
        }
        static isFrontFacing(t, e, i, s) {
          return Rn.subVectors(i, e), Kn.subVectors(t, e), Rn.cross(Kn).dot(s) < 0;
        }
        set(t, e, i) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
        }
        setFromPointsAndIndices(t, e, i, s) {
          return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[s]), this;
        }
        setFromAttributeAndIndices(t, e, i, s) {
          return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, s), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return Rn.subVectors(this.c, this.b), Kn.subVectors(this.a, this.b), Rn.cross(Kn).length() * 0.5;
        }
        getMidpoint(t) {
          return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return gn.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return gn.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getInterpolation(t, e, i, s, r) {
          return gn.getInterpolation(t, this.a, this.b, this.c, e, i, s, r);
        }
        containsPoint(t) {
          return gn.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return gn.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          const i = this.a, s = this.b, r = this.c;
          let o, a;
          Rs.subVectors(s, i), Ps.subVectors(r, i), Il.subVectors(t, i);
          const l = Rs.dot(Il), c = Ps.dot(Il);
          if (l <= 0 && c <= 0) return e.copy(i);
          Ol.subVectors(t, s);
          const h = Rs.dot(Ol), u = Ps.dot(Ol);
          if (h >= 0 && u <= h) return e.copy(s);
          const d = l * u - h * c;
          if (d <= 0 && l >= 0 && h <= 0) return o = l / (l - h), e.copy(i).addScaledVector(Rs, o);
          kl.subVectors(t, r);
          const f = Rs.dot(kl), g = Ps.dot(kl);
          if (g >= 0 && f <= g) return e.copy(r);
          const _ = f * c - l * g;
          if (_ <= 0 && c >= 0 && g <= 0) return a = c / (c - g), e.copy(i).addScaledVector(Ps, a);
          const m = h * g - f * u;
          if (m <= 0 && u - h >= 0 && f - g >= 0) return dd.subVectors(r, s), a = (u - h) / (u - h + (f - g)), e.copy(s).addScaledVector(dd, a);
          const p = 1 / (m + _ + d);
          return o = _ * p, a = d * p, e.copy(i).addScaledVector(Rs, o).addScaledVector(Ps, a);
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      }
      const Om = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      }, mi = {
        h: 0,
        s: 0,
        l: 0
      }, Lo = {
        h: 0,
        s: 0,
        l: 0
      };
      function Bl(n, t, e) {
        return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? n + (t - n) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? n + (t - n) * 6 * (2 / 3 - e) : n;
      }
      let qt = class {
        constructor(t, e, i) {
          return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, i);
        }
        set(t, e, i) {
          if (e === void 0 && i === void 0) {
            const s = t;
            s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
          } else this.setRGB(t, e, i);
          return this;
        }
        setScalar(t) {
          return this.r = t, this.g = t, this.b = t, this;
        }
        setHex(t, e = Sn) {
          return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, ee.toWorkingColorSpace(this, e), this;
        }
        setRGB(t, e, i, s = ee.workingColorSpace) {
          return this.r = t, this.g = e, this.b = i, ee.toWorkingColorSpace(this, s), this;
        }
        setHSL(t, e, i, s = ee.workingColorSpace) {
          if (t = Cx(t, 1), e = $t(e, 0, 1), i = $t(i, 0, 1), e === 0) this.r = this.g = this.b = i;
          else {
            const r = i <= 0.5 ? i * (1 + e) : i + e - i * e, o = 2 * i - r;
            this.r = Bl(o, r, t + 1 / 3), this.g = Bl(o, r, t), this.b = Bl(o, r, t - 1 / 3);
          }
          return ee.toWorkingColorSpace(this, s), this;
        }
        setStyle(t, e = Sn) {
          function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
          }
          let s;
          if (s = /^(\w+)\(([^\)]*)\)/.exec(t)) {
            let r;
            const o = s[1], a = s[2];
            switch (o) {
              case "rgb":
              case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                break;
              case "hsl":
              case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + t);
            }
          } else if (s = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const r = s[1], o = r.length;
            if (o === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, e);
            if (o === 6) return this.setHex(parseInt(r, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t);
          } else if (t && t.length > 0) return this.setColorName(t, e);
          return this;
        }
        setColorName(t, e = Sn) {
          const i = Om[t.toLowerCase()];
          return i !== void 0 ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return this.r = t.r, this.g = t.g, this.b = t.b, this;
        }
        copySRGBToLinear(t) {
          return this.r = ci(t.r), this.g = ci(t.g), this.b = ci(t.b), this;
        }
        copyLinearToSRGB(t) {
          return this.r = qs(t.r), this.g = qs(t.g), this.b = qs(t.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(t = Sn) {
          return ee.fromWorkingColorSpace(Ye.copy(this), t), Math.round($t(Ye.r * 255, 0, 255)) * 65536 + Math.round($t(Ye.g * 255, 0, 255)) * 256 + Math.round($t(Ye.b * 255, 0, 255));
        }
        getHexString(t = Sn) {
          return ("000000" + this.getHex(t).toString(16)).slice(-6);
        }
        getHSL(t, e = ee.workingColorSpace) {
          ee.fromWorkingColorSpace(Ye.copy(this), e);
          const i = Ye.r, s = Ye.g, r = Ye.b, o = Math.max(i, s, r), a = Math.min(i, s, r);
          let l, c;
          const h = (a + o) / 2;
          if (a === o) l = 0, c = 0;
          else {
            const u = o - a;
            switch (c = h <= 0.5 ? u / (o + a) : u / (2 - o - a), o) {
              case i:
                l = (s - r) / u + (s < r ? 6 : 0);
                break;
              case s:
                l = (r - i) / u + 2;
                break;
              case r:
                l = (i - s) / u + 4;
                break;
            }
            l /= 6;
          }
          return t.h = l, t.s = c, t.l = h, t;
        }
        getRGB(t, e = ee.workingColorSpace) {
          return ee.fromWorkingColorSpace(Ye.copy(this), e), t.r = Ye.r, t.g = Ye.g, t.b = Ye.b, t;
        }
        getStyle(t = Sn) {
          ee.fromWorkingColorSpace(Ye.copy(this), t);
          const e = Ye.r, i = Ye.g, s = Ye.b;
          return t !== Sn ? `color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(i * 255)},${Math.round(s * 255)})`;
        }
        offsetHSL(t, e, i) {
          return this.getHSL(mi), this.setHSL(mi.h + t, mi.s + e, mi.l + i);
        }
        add(t) {
          return this.r += t.r, this.g += t.g, this.b += t.b, this;
        }
        addColors(t, e) {
          return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
        }
        addScalar(t) {
          return this.r += t, this.g += t, this.b += t, this;
        }
        sub(t) {
          return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
        }
        multiply(t) {
          return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
        }
        multiplyScalar(t) {
          return this.r *= t, this.g *= t, this.b *= t, this;
        }
        lerp(t, e) {
          return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
        }
        lerpColors(t, e, i) {
          return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this;
        }
        lerpHSL(t, e) {
          this.getHSL(mi), t.getHSL(Lo);
          const i = Ml(mi.h, Lo.h, e), s = Ml(mi.s, Lo.s, e), r = Ml(mi.l, Lo.l, e);
          return this.setHSL(i, s, r), this;
        }
        setFromVector3(t) {
          return this.r = t.x, this.g = t.y, this.b = t.z, this;
        }
        applyMatrix3(t) {
          const e = this.r, i = this.g, s = this.b, r = t.elements;
          return this.r = r[0] * e + r[3] * i + r[6] * s, this.g = r[1] * e + r[4] * i + r[7] * s, this.b = r[2] * e + r[5] * i + r[8] * s, this;
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
        }
        toArray(t = [], e = 0) {
          return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
        }
        fromBufferAttribute(t, e) {
          return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      };
      const Ye = new qt();
      qt.NAMES = Om;
      let jx = 0;
      class ps extends fs {
        constructor() {
          super(), this.isMaterial = true, Object.defineProperty(this, "id", {
            value: jx++
          }), this.uuid = Ti(), this.name = "", this.type = "Material", this.blending = js, this.side = Di, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = Sc, this.blendDst = wc, this.blendEquation = ts, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new qt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Qs, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Ju, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = vs, this.stencilZFail = vs, this.stencilZPass = vs, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.allowOverride = true, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (t !== void 0) for (const e in t) {
            const i = t[e];
            if (i === void 0) {
              console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
              continue;
            }
            const s = this[e];
            if (s === void 0) {
              console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
              continue;
            }
            s && s.isColor ? s.set(i) : s && s.isVector3 && i && i.isVector3 ? s.copy(i) : this[e] = i;
          }
        }
        toJSON(t) {
          const e = t === void 0 || typeof t == "string";
          e && (t = {
            textures: {},
            images: {}
          });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== js && (i.blending = this.blending), this.side !== Di && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== Sc && (i.blendSrc = this.blendSrc), this.blendDst !== wc && (i.blendDst = this.blendDst), this.blendEquation !== ts && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Qs && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Ju && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== vs && (i.stencilFail = this.stencilFail), this.stencilZFail !== vs && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== vs && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
          function s(r) {
            const o = [];
            for (const a in r) {
              const l = r[a];
              delete l.metadata, o.push(l);
            }
            return o;
          }
          if (e) {
            const r = s(t.textures), o = s(t.images);
            r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
          const e = t.clippingPlanes;
          let i = null;
          if (e !== null) {
            const s = e.length;
            i = new Array(s);
            for (let r = 0; r !== s; ++r) i[r] = e[r].clone();
          }
          return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
      }
      class qh extends ps {
        constructor(t) {
          super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new qt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Wn(), this.combine = Bh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
        }
      }
      const Ie = new O(), Io = new Ft();
      let qx = 0;
      class In {
        constructor(t, e, i = false) {
          if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = true, Object.defineProperty(this, "id", {
            value: qx++
          }), this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = i, this.usage = lh, this.updateRanges = [], this.gpuType = si, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        setUsage(t) {
          return this.usage = t, this;
        }
        addUpdateRange(t, e) {
          this.updateRanges.push({
            start: t,
            count: e
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
        }
        copyAt(t, e, i) {
          t *= this.itemSize, i *= e.itemSize;
          for (let s = 0, r = this.itemSize; s < r; s++) this.array[t + s] = e.array[i + s];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        applyMatrix3(t) {
          if (this.itemSize === 2) for (let e = 0, i = this.count; e < i; e++) Io.fromBufferAttribute(this, e), Io.applyMatrix3(t), this.setXY(e, Io.x, Io.y);
          else if (this.itemSize === 3) for (let e = 0, i = this.count; e < i; e++) Ie.fromBufferAttribute(this, e), Ie.applyMatrix3(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.count; e < i; e++) Ie.fromBufferAttribute(this, e), Ie.applyMatrix4(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++) Ie.fromBufferAttribute(this, e), Ie.applyNormalMatrix(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++) Ie.fromBufferAttribute(this, e), Ie.transformDirection(t), this.setXYZ(e, Ie.x, Ie.y, Ie.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getComponent(t, e) {
          let i = this.array[t * this.itemSize + e];
          return this.normalized && (i = Un(i, this.array)), i;
        }
        setComponent(t, e, i) {
          return this.normalized && (i = de(i, this.array)), this.array[t * this.itemSize + e] = i, this;
        }
        getX(t) {
          let e = this.array[t * this.itemSize];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        setX(t, e) {
          return this.normalized && (e = de(e, this.array)), this.array[t * this.itemSize] = e, this;
        }
        getY(t) {
          let e = this.array[t * this.itemSize + 1];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        setY(t, e) {
          return this.normalized && (e = de(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
        }
        getZ(t) {
          let e = this.array[t * this.itemSize + 2];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        setZ(t, e) {
          return this.normalized && (e = de(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
        }
        getW(t) {
          let e = this.array[t * this.itemSize + 3];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        setW(t, e) {
          return this.normalized && (e = de(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
        }
        setXY(t, e, i) {
          return t *= this.itemSize, this.normalized && (e = de(e, this.array), i = de(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this;
        }
        setXYZ(t, e, i, s) {
          return t *= this.itemSize, this.normalized && (e = de(e, this.array), i = de(i, this.array), s = de(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = s, this;
        }
        setXYZW(t, e, i, s, r) {
          return t *= this.itemSize, this.normalized && (e = de(e, this.array), i = de(i, this.array), s = de(s, this.array), r = de(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = s, this.array[t + 3] = r, this;
        }
        onUpload(t) {
          return this.onUploadCallback = t, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          return this.name !== "" && (t.name = this.name), this.usage !== lh && (t.usage = this.usage), t;
        }
      }
      class km extends In {
        constructor(t, e, i) {
          super(new Uint16Array(t), e, i);
        }
      }
      class Fm extends In {
        constructor(t, e, i) {
          super(new Uint32Array(t), e, i);
        }
      }
      class en extends In {
        constructor(t, e, i) {
          super(new Float32Array(t), e, i);
        }
      }
      let $x = 0;
      const vn = new ye(), zl = new $e(), Ds = new O(), dn = new ao(), xr = new ao(), ze = new O();
      class xn extends fs {
        constructor() {
          super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
            value: $x++
          }), this.uuid = Ti(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
          }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return Array.isArray(t) ? this.index = new (Dm(t) ? Fm : km)(t, 1) : this.index = t, this;
        }
        setIndirect(t) {
          return this.indirect = t, this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return this.attributes[t] = e, this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return this.attributes[t] !== void 0;
        }
        addGroup(t, e, i = 0) {
          this.groups.push({
            start: t,
            count: e,
            materialIndex: i
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          this.drawRange.start = t, this.drawRange.count = e;
        }
        applyMatrix4(t) {
          const e = this.attributes.position;
          e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = true);
          const i = this.attributes.normal;
          if (i !== void 0) {
            const r = new Xt().getNormalMatrix(t);
            i.applyNormalMatrix(r), i.needsUpdate = true;
          }
          const s = this.attributes.tangent;
          return s !== void 0 && (s.transformDirection(t), s.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(t) {
          return vn.makeRotationFromQuaternion(t), this.applyMatrix4(vn), this;
        }
        rotateX(t) {
          return vn.makeRotationX(t), this.applyMatrix4(vn), this;
        }
        rotateY(t) {
          return vn.makeRotationY(t), this.applyMatrix4(vn), this;
        }
        rotateZ(t) {
          return vn.makeRotationZ(t), this.applyMatrix4(vn), this;
        }
        translate(t, e, i) {
          return vn.makeTranslation(t, e, i), this.applyMatrix4(vn), this;
        }
        scale(t, e, i) {
          return vn.makeScale(t, e, i), this.applyMatrix4(vn), this;
        }
        lookAt(t) {
          return zl.lookAt(t), zl.updateMatrix(), this.applyMatrix4(zl.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(Ds).negate(), this.translate(Ds.x, Ds.y, Ds.z), this;
        }
        setFromPoints(t) {
          const e = this.getAttribute("position");
          if (e === void 0) {
            const i = [];
            for (let s = 0, r = t.length; s < r; s++) {
              const o = t[s];
              i.push(o.x, o.y, o.z || 0);
            }
            this.setAttribute("position", new en(i, 3));
          } else {
            const i = Math.min(t.length, e.count);
            for (let s = 0; s < i; s++) {
              const r = t[s];
              e.setXYZ(s, r.x, r.y, r.z || 0);
            }
            t.length > e.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), e.needsUpdate = true;
          }
          return this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new ao());
          const t = this.attributes.position, e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new O(-1 / 0, -1 / 0, -1 / 0), new O(1 / 0, 1 / 0, 1 / 0));
            return;
          }
          if (t !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(t), e) for (let i = 0, s = e.length; i < s; i++) {
              const r = e[i];
              dn.setFromBufferAttribute(r), this.morphTargetsRelative ? (ze.addVectors(this.boundingBox.min, dn.min), this.boundingBox.expandByPoint(ze), ze.addVectors(this.boundingBox.max, dn.max), this.boundingBox.expandByPoint(ze)) : (this.boundingBox.expandByPoint(dn.min), this.boundingBox.expandByPoint(dn.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new el());
          const t = this.attributes.position, e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new O(), 1 / 0);
            return;
          }
          if (t) {
            const i = this.boundingSphere.center;
            if (dn.setFromBufferAttribute(t), e) for (let r = 0, o = e.length; r < o; r++) {
              const a = e[r];
              xr.setFromBufferAttribute(a), this.morphTargetsRelative ? (ze.addVectors(dn.min, xr.min), dn.expandByPoint(ze), ze.addVectors(dn.max, xr.max), dn.expandByPoint(ze)) : (dn.expandByPoint(xr.min), dn.expandByPoint(xr.max));
            }
            dn.getCenter(i);
            let s = 0;
            for (let r = 0, o = t.count; r < o; r++) ze.fromBufferAttribute(t, r), s = Math.max(s, i.distanceToSquared(ze));
            if (e) for (let r = 0, o = e.length; r < o; r++) {
              const a = e[r], l = this.morphTargetsRelative;
              for (let c = 0, h = a.count; c < h; c++) ze.fromBufferAttribute(a, c), l && (Ds.fromBufferAttribute(t, c), ze.add(Ds)), s = Math.max(s, i.distanceToSquared(ze));
            }
            this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const t = this.index, e = this.attributes;
          if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = e.position, s = e.normal, r = e.uv;
          this.hasAttribute("tangent") === false && this.setAttribute("tangent", new In(new Float32Array(4 * i.count), 4));
          const o = this.getAttribute("tangent"), a = [], l = [];
          for (let v = 0; v < i.count; v++) a[v] = new O(), l[v] = new O();
          const c = new O(), h = new O(), u = new O(), d = new Ft(), f = new Ft(), g = new Ft(), _ = new O(), m = new O();
          function p(v, x, b) {
            c.fromBufferAttribute(i, v), h.fromBufferAttribute(i, x), u.fromBufferAttribute(i, b), d.fromBufferAttribute(r, v), f.fromBufferAttribute(r, x), g.fromBufferAttribute(r, b), h.sub(c), u.sub(c), f.sub(d), g.sub(d);
            const A = 1 / (f.x * g.y - g.x * f.y);
            isFinite(A) && (_.copy(h).multiplyScalar(g.y).addScaledVector(u, -f.y).multiplyScalar(A), m.copy(u).multiplyScalar(f.x).addScaledVector(h, -g.x).multiplyScalar(A), a[v].add(_), a[x].add(_), a[b].add(_), l[v].add(m), l[x].add(m), l[b].add(m));
          }
          let y = this.groups;
          y.length === 0 && (y = [
            {
              start: 0,
              count: t.count
            }
          ]);
          for (let v = 0, x = y.length; v < x; ++v) {
            const b = y[v], A = b.start, L = b.count;
            for (let I = A, H = A + L; I < H; I += 3) p(t.getX(I + 0), t.getX(I + 1), t.getX(I + 2));
          }
          const w = new O(), M = new O(), C = new O(), R = new O();
          function T(v) {
            C.fromBufferAttribute(s, v), R.copy(C);
            const x = a[v];
            w.copy(x), w.sub(C.multiplyScalar(C.dot(x))).normalize(), M.crossVectors(R, x);
            const A = M.dot(l[v]) < 0 ? -1 : 1;
            o.setXYZW(v, w.x, w.y, w.z, A);
          }
          for (let v = 0, x = y.length; v < x; ++v) {
            const b = y[v], A = b.start, L = b.count;
            for (let I = A, H = A + L; I < H; I += 3) T(t.getX(I + 0)), T(t.getX(I + 1)), T(t.getX(I + 2));
          }
        }
        computeVertexNormals() {
          const t = this.index, e = this.getAttribute("position");
          if (e !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new In(new Float32Array(e.count * 3), 3), this.setAttribute("normal", i);
            else for (let d = 0, f = i.count; d < f; d++) i.setXYZ(d, 0, 0, 0);
            const s = new O(), r = new O(), o = new O(), a = new O(), l = new O(), c = new O(), h = new O(), u = new O();
            if (t) for (let d = 0, f = t.count; d < f; d += 3) {
              const g = t.getX(d + 0), _ = t.getX(d + 1), m = t.getX(d + 2);
              s.fromBufferAttribute(e, g), r.fromBufferAttribute(e, _), o.fromBufferAttribute(e, m), h.subVectors(o, r), u.subVectors(s, r), h.cross(u), a.fromBufferAttribute(i, g), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, m), a.add(h), l.add(h), c.add(h), i.setXYZ(g, a.x, a.y, a.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(m, c.x, c.y, c.z);
            }
            else for (let d = 0, f = e.count; d < f; d += 3) s.fromBufferAttribute(e, d + 0), r.fromBufferAttribute(e, d + 1), o.fromBufferAttribute(e, d + 2), h.subVectors(o, r), u.subVectors(s, r), h.cross(u), i.setXYZ(d + 0, h.x, h.y, h.z), i.setXYZ(d + 1, h.x, h.y, h.z), i.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(), i.needsUpdate = true;
          }
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let e = 0, i = t.count; e < i; e++) ze.fromBufferAttribute(t, e), ze.normalize(), t.setXYZ(e, ze.x, ze.y, ze.z);
        }
        toNonIndexed() {
          function t(a, l) {
            const c = a.array, h = a.itemSize, u = a.normalized, d = new c.constructor(l.length * h);
            let f = 0, g = 0;
            for (let _ = 0, m = l.length; _ < m; _++) {
              a.isInterleavedBufferAttribute ? f = l[_] * a.data.stride + a.offset : f = l[_] * h;
              for (let p = 0; p < h; p++) d[g++] = c[f++];
            }
            return new In(d, h, u);
          }
          if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const e = new xn(), i = this.index.array, s = this.attributes;
          for (const a in s) {
            const l = s[a], c = t(l, i);
            e.setAttribute(a, c);
          }
          const r = this.morphAttributes;
          for (const a in r) {
            const l = [], c = r[a];
            for (let h = 0, u = c.length; h < u; h++) {
              const d = c[h], f = t(d, i);
              l.push(f);
            }
            e.morphAttributes[a] = l;
          }
          e.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            e.addGroup(c.start, c.count, c.materialIndex);
          }
          return e;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (t[c] = l[c]);
            return t;
          }
          t.data = {
            attributes: {}
          };
          const e = this.index;
          e !== null && (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array)
          });
          const i = this.attributes;
          for (const l in i) {
            const c = i[l];
            t.data.attributes[l] = c.toJSON(t.data);
          }
          const s = {};
          let r = false;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l], h = [];
            for (let u = 0, d = c.length; u < d; u++) {
              const f = c[u];
              h.push(f.toJSON(t.data));
            }
            h.length > 0 && (s[l] = h, r = true);
          }
          r && (t.data.morphAttributes = s, t.data.morphTargetsRelative = this.morphTargetsRelative);
          const o = this.groups;
          o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return a !== null && (t.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
          }), t;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const e = {};
          this.name = t.name;
          const i = t.index;
          i !== null && this.setIndex(i.clone());
          const s = t.attributes;
          for (const c in s) {
            const h = s[c];
            this.setAttribute(c, h.clone(e));
          }
          const r = t.morphAttributes;
          for (const c in r) {
            const h = [], u = r[c];
            for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(e));
            this.morphAttributes[c] = h;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const o = t.groups;
          for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex);
          }
          const a = t.boundingBox;
          a !== null && (this.boundingBox = a.clone());
          const l = t.boundingSphere;
          return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const fd = new ye(), Vi = new jh(), Oo = new el(), pd = new O(), ko = new O(), Fo = new O(), No = new O(), Hl = new O(), Uo = new O(), md = new O(), Bo = new O();
      class Dn extends $e {
        constructor(t = new xn(), e = new qh()) {
          super(), this.isMesh = true, this.type = "Mesh", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
          return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const s = e[i[0]];
            if (s !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, o = s.length; r < o; r++) {
                const a = s[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
              }
            }
          }
        }
        getVertexPosition(t, e) {
          const i = this.geometry, s = i.attributes.position, r = i.morphAttributes.position, o = i.morphTargetsRelative;
          e.fromBufferAttribute(s, t);
          const a = this.morphTargetInfluences;
          if (r && a) {
            Uo.set(0, 0, 0);
            for (let l = 0, c = r.length; l < c; l++) {
              const h = a[l], u = r[l];
              h !== 0 && (Hl.fromBufferAttribute(u, t), o ? Uo.addScaledVector(Hl, h) : Uo.addScaledVector(Hl.sub(e), h));
            }
            e.add(Uo);
          }
          return e;
        }
        raycast(t, e) {
          const i = this.geometry, s = this.material, r = this.matrixWorld;
          s !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Oo.copy(i.boundingSphere), Oo.applyMatrix4(r), Vi.copy(t.ray).recast(t.near), !(Oo.containsPoint(Vi.origin) === false && (Vi.intersectSphere(Oo, pd) === null || Vi.origin.distanceToSquared(pd) > (t.far - t.near) ** 2)) && (fd.copy(r).invert(), Vi.copy(t.ray).applyMatrix4(fd), !(i.boundingBox !== null && Vi.intersectsBox(i.boundingBox) === false) && this._computeIntersections(t, e, Vi)));
        }
        _computeIntersections(t, e, i) {
          let s;
          const r = this.geometry, o = this.material, a = r.index, l = r.attributes.position, c = r.attributes.uv, h = r.attributes.uv1, u = r.attributes.normal, d = r.groups, f = r.drawRange;
          if (a !== null) if (Array.isArray(o)) for (let g = 0, _ = d.length; g < _; g++) {
            const m = d[g], p = o[m.materialIndex], y = Math.max(m.start, f.start), w = Math.min(a.count, Math.min(m.start + m.count, f.start + f.count));
            for (let M = y, C = w; M < C; M += 3) {
              const R = a.getX(M), T = a.getX(M + 1), v = a.getX(M + 2);
              s = zo(this, p, t, i, c, h, u, R, T, v), s && (s.faceIndex = Math.floor(M / 3), s.face.materialIndex = m.materialIndex, e.push(s));
            }
          }
          else {
            const g = Math.max(0, f.start), _ = Math.min(a.count, f.start + f.count);
            for (let m = g, p = _; m < p; m += 3) {
              const y = a.getX(m), w = a.getX(m + 1), M = a.getX(m + 2);
              s = zo(this, o, t, i, c, h, u, y, w, M), s && (s.faceIndex = Math.floor(m / 3), e.push(s));
            }
          }
          else if (l !== void 0) if (Array.isArray(o)) for (let g = 0, _ = d.length; g < _; g++) {
            const m = d[g], p = o[m.materialIndex], y = Math.max(m.start, f.start), w = Math.min(l.count, Math.min(m.start + m.count, f.start + f.count));
            for (let M = y, C = w; M < C; M += 3) {
              const R = M, T = M + 1, v = M + 2;
              s = zo(this, p, t, i, c, h, u, R, T, v), s && (s.faceIndex = Math.floor(M / 3), s.face.materialIndex = m.materialIndex, e.push(s));
            }
          }
          else {
            const g = Math.max(0, f.start), _ = Math.min(l.count, f.start + f.count);
            for (let m = g, p = _; m < p; m += 3) {
              const y = m, w = m + 1, M = m + 2;
              s = zo(this, o, t, i, c, h, u, y, w, M), s && (s.faceIndex = Math.floor(m / 3), e.push(s));
            }
          }
        }
      }
      function Kx(n, t, e, i, s, r, o, a) {
        let l;
        if (t.side === an ? l = i.intersectTriangle(o, r, s, true, a) : l = i.intersectTriangle(s, r, o, t.side === Di, a), l === null) return null;
        Bo.copy(a), Bo.applyMatrix4(n.matrixWorld);
        const c = e.ray.origin.distanceTo(Bo);
        return c < e.near || c > e.far ? null : {
          distance: c,
          point: Bo.clone(),
          object: n
        };
      }
      function zo(n, t, e, i, s, r, o, a, l, c) {
        n.getVertexPosition(a, ko), n.getVertexPosition(l, Fo), n.getVertexPosition(c, No);
        const h = Kx(n, t, e, i, ko, Fo, No, md);
        if (h) {
          const u = new O();
          gn.getBarycoord(md, ko, Fo, No, u), s && (h.uv = gn.getInterpolatedAttribute(s, a, l, c, u, new Ft())), r && (h.uv1 = gn.getInterpolatedAttribute(r, a, l, c, u, new Ft())), o && (h.normal = gn.getInterpolatedAttribute(o, a, l, c, u, new O()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
          const d = {
            a,
            b: l,
            c,
            normal: new O(),
            materialIndex: 0
          };
          gn.getNormal(ko, Fo, No, d.normal), h.face = d, h.barycoord = u;
        }
        return h;
      }
      class cs extends xn {
        constructor(t = 1, e = 1, i = 1, s = 1, r = 1, o = 1) {
          super(), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: s,
            heightSegments: r,
            depthSegments: o
          };
          const a = this;
          s = Math.floor(s), r = Math.floor(r), o = Math.floor(o);
          const l = [], c = [], h = [], u = [];
          let d = 0, f = 0;
          g("z", "y", "x", -1, -1, i, e, t, o, r, 0), g("z", "y", "x", 1, -1, i, e, -t, o, r, 1), g("x", "z", "y", 1, 1, t, i, e, s, o, 2), g("x", "z", "y", 1, -1, t, i, -e, s, o, 3), g("x", "y", "z", 1, -1, t, e, i, s, r, 4), g("x", "y", "z", -1, -1, t, e, -i, s, r, 5), this.setIndex(l), this.setAttribute("position", new en(c, 3)), this.setAttribute("normal", new en(h, 3)), this.setAttribute("uv", new en(u, 2));
          function g(_, m, p, y, w, M, C, R, T, v, x) {
            const b = M / T, A = C / v, L = M / 2, I = C / 2, H = R / 2, j = T + 1, z = v + 1;
            let V = 0, U = 0;
            const q = new O();
            for (let rt = 0; rt < z; rt++) {
              const et = rt * A - I;
              for (let ut = 0; ut < j; ut++) {
                const ot = ut * b - L;
                q[_] = ot * y, q[m] = et * w, q[p] = H, c.push(q.x, q.y, q.z), q[_] = 0, q[m] = 0, q[p] = R > 0 ? 1 : -1, h.push(q.x, q.y, q.z), u.push(ut / T), u.push(1 - rt / v), V += 1;
              }
            }
            for (let rt = 0; rt < v; rt++) for (let et = 0; et < T; et++) {
              const ut = d + et + j * rt, ot = d + et + j * (rt + 1), W = d + (et + 1) + j * (rt + 1), J = d + (et + 1) + j * rt;
              l.push(ut, ot, J), l.push(ot, W, J), U += 6;
            }
            a.addGroup(f, U, x), f += U, d += V;
          }
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new cs(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
        }
      }
      function nr(n) {
        const t = {};
        for (const e in n) {
          t[e] = {};
          for (const i in n[e]) {
            const s = n[e][i];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][i] = null) : t[e][i] = s.clone() : Array.isArray(s) ? t[e][i] = s.slice() : t[e][i] = s;
          }
        }
        return t;
      }
      function Je(n) {
        const t = {};
        for (let e = 0; e < n.length; e++) {
          const i = nr(n[e]);
          for (const s in i) t[s] = i[s];
        }
        return t;
      }
      function Zx(n) {
        const t = [];
        for (let e = 0; e < n.length; e++) t.push(n[e].clone());
        return t;
      }
      function Nm(n) {
        const t = n.getRenderTarget();
        return t === null ? n.outputColorSpace : t.isXRRenderTarget === true ? t.texture.colorSpace : ee.workingColorSpace;
      }
      const Qx = {
        clone: nr,
        merge: Je
      };
      var Jx = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, tb = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class Li extends ps {
        constructor(t) {
          super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Jx, this.fragmentShader = tb, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
            clipCullDistance: false,
            multiDraw: false
          }, this.defaultAttributeValues = {
            color: [
              1,
              1,
              1
            ],
            uv: [
              0,
              0
            ],
            uv1: [
              0,
              0
            ]
          }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t !== void 0 && this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = nr(t.uniforms), this.uniformsGroups = Zx(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          e.glslVersion = this.glslVersion, e.uniforms = {};
          for (const s in this.uniforms) {
            const o = this.uniforms[s].value;
            o && o.isTexture ? e.uniforms[s] = {
              type: "t",
              value: o.toJSON(t).uuid
            } : o && o.isColor ? e.uniforms[s] = {
              type: "c",
              value: o.getHex()
            } : o && o.isVector2 ? e.uniforms[s] = {
              type: "v2",
              value: o.toArray()
            } : o && o.isVector3 ? e.uniforms[s] = {
              type: "v3",
              value: o.toArray()
            } : o && o.isVector4 ? e.uniforms[s] = {
              type: "v4",
              value: o.toArray()
            } : o && o.isMatrix3 ? e.uniforms[s] = {
              type: "m3",
              value: o.toArray()
            } : o && o.isMatrix4 ? e.uniforms[s] = {
              type: "m4",
              value: o.toArray()
            } : e.uniforms[s] = {
              value: o
            };
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
          const i = {};
          for (const s in this.extensions) this.extensions[s] === true && (i[s] = true);
          return Object.keys(i).length > 0 && (e.extensions = i), e;
        }
      }
      class Um extends $e {
        constructor() {
          super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new ye(), this.projectionMatrix = new ye(), this.projectionMatrixInverse = new ye(), this.coordinateSystem = ri;
        }
        copy(t, e) {
          return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
        }
        getWorldDirection(t) {
          return super.getWorldDirection(t).negate();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const gi = new O(), gd = new Ft(), _d = new Ft();
      class mn extends Um {
        constructor(t = 50, e = 1, i = 0.1, s = 2e3) {
          super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = s, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(t, e) {
          return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
        }
        setFocalLength(t) {
          const e = 0.5 * this.getFilmHeight() / t;
          this.fov = ch * 2 * Math.atan(e), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(Hr * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / t;
        }
        getEffectiveFOV() {
          return ch * 2 * Math.atan(Math.tan(Hr * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(t, e, i) {
          gi.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(gi.x, gi.y).multiplyScalar(-t / gi.z), gi.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(gi.x, gi.y).multiplyScalar(-t / gi.z);
        }
        getViewSize(t, e) {
          return this.getViewBounds(t, gd, _d), e.subVectors(_d, gd);
        }
        setViewOffset(t, e, i, s, r, o) {
          this.aspect = t / e, this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let e = t * Math.tan(Hr * 0.5 * this.fov) / this.zoom, i = 2 * e, s = this.aspect * i, r = -0.5 * s;
          const o = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth, c = o.fullHeight;
            r += o.offsetX * s / l, e -= o.offsetY * i / c, s *= o.width / l, i *= o.height / c;
          }
          const a = this.filmOffset;
          a !== 0 && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, e, e - i, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
        }
      }
      const Ls = -90, Is = 1;
      class eb extends $e {
        constructor(t, e, i) {
          super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
          const s = new mn(Ls, Is, t, e);
          s.layers = this.layers, this.add(s);
          const r = new mn(Ls, Is, t, e);
          r.layers = this.layers, this.add(r);
          const o = new mn(Ls, Is, t, e);
          o.layers = this.layers, this.add(o);
          const a = new mn(Ls, Is, t, e);
          a.layers = this.layers, this.add(a);
          const l = new mn(Ls, Is, t, e);
          l.layers = this.layers, this.add(l);
          const c = new mn(Ls, Is, t, e);
          c.layers = this.layers, this.add(c);
        }
        updateCoordinateSystem() {
          const t = this.coordinateSystem, e = this.children.concat(), [i, s, r, o, a, l] = e;
          for (const c of e) this.remove(c);
          if (t === ri) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
          else if (t === Ia) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
          else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
          for (const c of e) this.add(c), c.updateMatrixWorld();
        }
        update(t, e) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: i, activeMipmapLevel: s } = this;
          this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
          const [r, o, a, l, c, h] = this.children, u = t.getRenderTarget(), d = t.getActiveCubeFace(), f = t.getActiveMipmapLevel(), g = t.xr.enabled;
          t.xr.enabled = false;
          const _ = i.texture.generateMipmaps;
          i.texture.generateMipmaps = false, t.setRenderTarget(i, 0, s), t.render(e, r), t.setRenderTarget(i, 1, s), t.render(e, o), t.setRenderTarget(i, 2, s), t.render(e, a), t.setRenderTarget(i, 3, s), t.render(e, l), t.setRenderTarget(i, 4, s), t.render(e, c), i.texture.generateMipmaps = _, t.setRenderTarget(i, 5, s), t.render(e, h), t.setRenderTarget(u, d, f), t.xr.enabled = g, i.texture.needsPMREMUpdate = true;
        }
      }
      class Bm extends tn {
        constructor(t = [], e = Js, i, s, r, o, a, l, c, h) {
          super(t, e, i, s, r, o, a, l, c, h), this.isCubeTexture = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      class nb extends as {
        constructor(t = 1, e = {}) {
          super(t, t, e), this.isWebGLCubeRenderTarget = true;
          const i = {
            width: t,
            height: t,
            depth: 1
          }, s = [
            i,
            i,
            i,
            i,
            i,
            i
          ];
          this.texture = new Bm(s, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : false, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : _n;
        }
        fromEquirectangularTexture(t, e) {
          this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
          const i = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          }, s = new cs(5, 5, 5), r = new Li({
            name: "CubemapFromEquirect",
            uniforms: nr(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: an,
            blending: wi
          });
          r.uniforms.tEquirect.value = e;
          const o = new Dn(s, r), a = e.minFilter;
          return e.minFilter === is && (e.minFilter = _n), new eb(1, 10, this).update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
        }
        clear(t, e = true, i = true, s = true) {
          const r = t.getRenderTarget();
          for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, i, s);
          t.setRenderTarget(r);
        }
      }
      class Or extends $e {
        constructor() {
          super(), this.isGroup = true, this.type = "Group";
        }
      }
      const ib = {
        type: "move"
      };
      class Vl {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return this._hand === null && (this._hand = new Or(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
            pinching: false
          }), this._hand;
        }
        getTargetRaySpace() {
          return this._targetRay === null && (this._targetRay = new Or(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new O(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new O()), this._targetRay;
        }
        getGripSpace() {
          return this._grip === null && (this._grip = new Or(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new O(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new O()), this._grip;
        }
        dispatchEvent(t) {
          return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
        }
        connect(t) {
          if (t && t.hand) {
            const e = this._hand;
            if (e) for (const i of t.hand.values()) this._getHandJoint(e, i);
          }
          return this.dispatchEvent({
            type: "connected",
            data: t
          }), this;
        }
        disconnect(t) {
          return this.dispatchEvent({
            type: "disconnected",
            data: t
          }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
        }
        update(t, e, i) {
          let s = null, r = null, o = null;
          const a = this._targetRay, l = this._grip, c = this._hand;
          if (t && e.session.visibilityState !== "visible-blurred") {
            if (c && t.hand) {
              o = true;
              for (const _ of t.hand.values()) {
                const m = e.getJointPose(_, i), p = this._getHandJoint(c, _);
                m !== null && (p.matrix.fromArray(m.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = true, p.jointRadius = m.radius), p.visible = m !== null;
              }
              const h = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], d = h.position.distanceTo(u.position), f = 0.02, g = 5e-3;
              c.inputState.pinching && d > f + g ? (c.inputState.pinching = false, this.dispatchEvent({
                type: "pinchend",
                handedness: t.handedness,
                target: this
              })) : !c.inputState.pinching && d <= f - g && (c.inputState.pinching = true, this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this
              }));
            } else l !== null && t.gripSpace && (r = e.getPose(t.gripSpace, i), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, r.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = false, r.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = false));
            a !== null && (s = e.getPose(t.targetRaySpace, i), s === null && r !== null && (s = r), s !== null && (a.matrix.fromArray(s.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = true, s.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(s.linearVelocity)) : a.hasLinearVelocity = false, s.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(s.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(ib)));
          }
          return a !== null && (a.visible = s !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this;
        }
        _getHandJoint(t, e) {
          if (t.joints[e.jointName] === void 0) {
            const i = new Or();
            i.matrixAutoUpdate = false, i.visible = false, t.joints[e.jointName] = i, t.add(i);
          }
          return t.joints[e.jointName];
        }
      }
      class sb extends $e {
        constructor() {
          super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Wn(), this.environmentIntensity = 1, this.environmentRotation = new Wn(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        copy(t, e) {
          return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
        }
      }
      class rb {
        constructor(t, e) {
          this.isInterleavedBuffer = true, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = lh, this.updateRanges = [], this.version = 0, this.uuid = Ti();
        }
        onUploadCallback() {
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        setUsage(t) {
          return this.usage = t, this;
        }
        addUpdateRange(t, e) {
          this.updateRanges.push({
            start: t,
            count: e
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
        }
        copyAt(t, e, i) {
          t *= this.stride, i *= e.stride;
          for (let s = 0, r = this.stride; s < r; s++) this.array[t + s] = e.array[i + s];
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        clone(t) {
          t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ti()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(e, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(t) {
          return this.onUploadCallback = t, this;
        }
        toJSON(t) {
          return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ti()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      const Qe = new O();
      class ka {
        constructor(t, e, i, s = false) {
          this.isInterleavedBufferAttribute = true, this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = s;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t) {
          this.data.needsUpdate = t;
        }
        applyMatrix4(t) {
          for (let e = 0, i = this.data.count; e < i; e++) Qe.fromBufferAttribute(this, e), Qe.applyMatrix4(t), this.setXYZ(e, Qe.x, Qe.y, Qe.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, i = this.count; e < i; e++) Qe.fromBufferAttribute(this, e), Qe.applyNormalMatrix(t), this.setXYZ(e, Qe.x, Qe.y, Qe.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, i = this.count; e < i; e++) Qe.fromBufferAttribute(this, e), Qe.transformDirection(t), this.setXYZ(e, Qe.x, Qe.y, Qe.z);
          return this;
        }
        getComponent(t, e) {
          let i = this.array[t * this.data.stride + this.offset + e];
          return this.normalized && (i = Un(i, this.array)), i;
        }
        setComponent(t, e, i) {
          return this.normalized && (i = de(i, this.array)), this.data.array[t * this.data.stride + this.offset + e] = i, this;
        }
        setX(t, e) {
          return this.normalized && (e = de(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this;
        }
        setY(t, e) {
          return this.normalized && (e = de(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this;
        }
        setZ(t, e) {
          return this.normalized && (e = de(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this;
        }
        setW(t, e) {
          return this.normalized && (e = de(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this;
        }
        getX(t) {
          let e = this.data.array[t * this.data.stride + this.offset];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        getY(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 1];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        getZ(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 2];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        getW(t) {
          let e = this.data.array[t * this.data.stride + this.offset + 3];
          return this.normalized && (e = Un(e, this.array)), e;
        }
        setXY(t, e, i) {
          return t = t * this.data.stride + this.offset, this.normalized && (e = de(e, this.array), i = de(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this;
        }
        setXYZ(t, e, i, s) {
          return t = t * this.data.stride + this.offset, this.normalized && (e = de(e, this.array), i = de(i, this.array), s = de(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = s, this;
        }
        setXYZW(t, e, i, s, r) {
          return t = t * this.data.stride + this.offset, this.normalized && (e = de(e, this.array), i = de(i, this.array), s = de(s, this.array), r = de(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = s, this.data.array[t + 3] = r, this;
        }
        clone(t) {
          if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let i = 0; i < this.count; i++) {
              const s = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[s + r]);
            }
            return new In(new this.array.constructor(e), this.itemSize, this.normalized);
          } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ka(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(t) {
          if (t === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const e = [];
            for (let i = 0; i < this.count; i++) {
              const s = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[s + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: e,
              normalized: this.normalized
            };
          } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
      class hh extends ps {
        constructor(t) {
          super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new qt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
        }
      }
      let Os;
      const br = new O(), ks = new O(), Fs = new O(), Ns = new Ft(), yr = new Ft(), zm = new ye(), Ho = new O(), vr = new O(), Vo = new O(), xd = new Ft(), Wl = new Ft(), bd = new Ft();
      class yd extends $e {
        constructor(t = new hh()) {
          if (super(), this.isSprite = true, this.type = "Sprite", Os === void 0) {
            Os = new xn();
            const e = new Float32Array([
              -0.5,
              -0.5,
              0,
              0,
              0,
              0.5,
              -0.5,
              0,
              1,
              0,
              0.5,
              0.5,
              0,
              1,
              1,
              -0.5,
              0.5,
              0,
              0,
              1
            ]), i = new rb(e, 5);
            Os.setIndex([
              0,
              1,
              2,
              0,
              2,
              3
            ]), Os.setAttribute("position", new ka(i, 3, 0, false)), Os.setAttribute("uv", new ka(i, 2, 3, false));
          }
          this.geometry = Os, this.material = t, this.center = new Ft(0.5, 0.5);
        }
        raycast(t, e) {
          t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ks.setFromMatrixScale(this.matrixWorld), zm.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Fs.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && ks.multiplyScalar(-Fs.z);
          const i = this.material.rotation;
          let s, r;
          i !== 0 && (r = Math.cos(i), s = Math.sin(i));
          const o = this.center;
          Wo(Ho.set(-0.5, -0.5, 0), Fs, o, ks, s, r), Wo(vr.set(0.5, -0.5, 0), Fs, o, ks, s, r), Wo(Vo.set(0.5, 0.5, 0), Fs, o, ks, s, r), xd.set(0, 0), Wl.set(1, 0), bd.set(1, 1);
          let a = t.ray.intersectTriangle(Ho, vr, Vo, false, br);
          if (a === null && (Wo(vr.set(-0.5, 0.5, 0), Fs, o, ks, s, r), Wl.set(0, 1), a = t.ray.intersectTriangle(Ho, Vo, vr, false, br), a === null)) return;
          const l = t.ray.origin.distanceTo(br);
          l < t.near || l > t.far || e.push({
            distance: l,
            point: br.clone(),
            uv: gn.getInterpolation(br, Ho, vr, Vo, xd, Wl, bd, new Ft()),
            face: null,
            object: this
          });
        }
        copy(t, e) {
          return super.copy(t, e), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
        }
      }
      function Wo(n, t, e, i, s, r) {
        Ns.subVectors(n, e).addScalar(0.5).multiply(i), s !== void 0 ? (yr.x = r * Ns.x - s * Ns.y, yr.y = s * Ns.x + r * Ns.y) : yr.copy(Ns), n.copy(t), n.x += yr.x, n.y += yr.y, n.applyMatrix4(zm);
      }
      const Gl = new O(), ob = new O(), ab = new Xt();
      class bi {
        constructor(t = new O(1, 0, 0), e = 0) {
          this.isPlane = true, this.normal = t, this.constant = e;
        }
        set(t, e) {
          return this.normal.copy(t), this.constant = e, this;
        }
        setComponents(t, e, i, s) {
          return this.normal.set(t, e, i), this.constant = s, this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
        }
        setFromCoplanarPoints(t, e, i) {
          const s = Gl.subVectors(i, e).cross(ob.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(s, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), this.constant = t.constant, this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), this.constant *= t, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
        }
        intersectLine(t, e) {
          const i = t.delta(Gl), s = this.normal.dot(i);
          if (s === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
          const r = -(t.start.dot(this.normal) + this.constant) / s;
          return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(i, r);
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
          return e < 0 && i > 0 || i < 0 && e > 0;
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          const i = e || ab.getNormalMatrix(t), s = this.coplanarPoint(Gl).applyMatrix4(t), r = this.normal.applyMatrix3(i).normalize();
          return this.constant = -s.dot(r), this;
        }
        translate(t) {
          return this.constant -= t.dot(this.normal), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Wi = new el(), Go = new O();
      class $h {
        constructor(t = new bi(), e = new bi(), i = new bi(), s = new bi(), r = new bi(), o = new bi()) {
          this.planes = [
            t,
            e,
            i,
            s,
            r,
            o
          ];
        }
        set(t, e, i, s, r, o) {
          const a = this.planes;
          return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(s), a[4].copy(r), a[5].copy(o), this;
        }
        copy(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
          return this;
        }
        setFromProjectionMatrix(t, e = ri) {
          const i = this.planes, s = t.elements, r = s[0], o = s[1], a = s[2], l = s[3], c = s[4], h = s[5], u = s[6], d = s[7], f = s[8], g = s[9], _ = s[10], m = s[11], p = s[12], y = s[13], w = s[14], M = s[15];
          if (i[0].setComponents(l - r, d - c, m - f, M - p).normalize(), i[1].setComponents(l + r, d + c, m + f, M + p).normalize(), i[2].setComponents(l + o, d + h, m + g, M + y).normalize(), i[3].setComponents(l - o, d - h, m - g, M - y).normalize(), i[4].setComponents(l - a, d - u, m - _, M - w).normalize(), e === ri) i[5].setComponents(l + a, d + u, m + _, M + w).normalize();
          else if (e === Ia) i[5].setComponents(a, u, _, w).normalize();
          else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
          return this;
        }
        intersectsObject(t) {
          if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), Wi.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
          else {
            const e = t.geometry;
            e.boundingSphere === null && e.computeBoundingSphere(), Wi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
          }
          return this.intersectsSphere(Wi);
        }
        intersectsSprite(t) {
          return Wi.center.set(0, 0, 0), Wi.radius = 0.7071067811865476, Wi.applyMatrix4(t.matrixWorld), this.intersectsSphere(Wi);
        }
        intersectsSphere(t) {
          const e = this.planes, i = t.center, s = -t.radius;
          for (let r = 0; r < 6; r++) if (e[r].distanceToPoint(i) < s) return false;
          return true;
        }
        intersectsBox(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) {
            const s = e[i];
            if (Go.x = s.normal.x > 0 ? t.max.x : t.min.x, Go.y = s.normal.y > 0 ? t.max.y : t.min.y, Go.z = s.normal.z > 0 ? t.max.z : t.min.z, s.distanceToPoint(Go) < 0) return false;
          }
          return true;
        }
        containsPoint(t) {
          const e = this.planes;
          for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Jr extends ps {
        constructor(t) {
          super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new qt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
        }
      }
      const Fa = new O(), Na = new O(), vd = new ye(), Mr = new jh(), Xo = new el(), Xl = new O(), Md = new O();
      class lb extends $e {
        constructor(t = new xn(), e = new Jr()) {
          super(), this.isLine = true, this.type = "Line", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(t, e) {
          return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const e = t.attributes.position, i = [
              0
            ];
            for (let s = 1, r = e.count; s < r; s++) Fa.fromBufferAttribute(e, s - 1), Na.fromBufferAttribute(e, s), i[s] = i[s - 1], i[s] += Fa.distanceTo(Na);
            t.setAttribute("lineDistance", new en(i, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(t, e) {
          const i = this.geometry, s = this.matrixWorld, r = t.params.Line.threshold, o = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), Xo.copy(i.boundingSphere), Xo.applyMatrix4(s), Xo.radius += r, t.ray.intersectsSphere(Xo) === false) return;
          vd.copy(s).invert(), Mr.copy(t.ray).applyMatrix4(vd);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = this.isLineSegments ? 2 : 1, h = i.index, d = i.attributes.position;
          if (h !== null) {
            const f = Math.max(0, o.start), g = Math.min(h.count, o.start + o.count);
            for (let _ = f, m = g - 1; _ < m; _ += c) {
              const p = h.getX(_), y = h.getX(_ + 1), w = Yo(this, t, Mr, l, p, y, _);
              w && e.push(w);
            }
            if (this.isLineLoop) {
              const _ = h.getX(g - 1), m = h.getX(f), p = Yo(this, t, Mr, l, _, m, g - 1);
              p && e.push(p);
            }
          } else {
            const f = Math.max(0, o.start), g = Math.min(d.count, o.start + o.count);
            for (let _ = f, m = g - 1; _ < m; _ += c) {
              const p = Yo(this, t, Mr, l, _, _ + 1, _);
              p && e.push(p);
            }
            if (this.isLineLoop) {
              const _ = Yo(this, t, Mr, l, g - 1, f, g - 1);
              _ && e.push(_);
            }
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, i = Object.keys(e);
          if (i.length > 0) {
            const s = e[i[0]];
            if (s !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, o = s.length; r < o; r++) {
                const a = s[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
              }
            }
          }
        }
      }
      function Yo(n, t, e, i, s, r, o) {
        const a = n.geometry.attributes.position;
        if (Fa.fromBufferAttribute(a, s), Na.fromBufferAttribute(a, r), e.distanceSqToSegment(Fa, Na, Xl, Md) > i) return;
        Xl.applyMatrix4(n.matrixWorld);
        const c = t.ray.origin.distanceTo(Xl);
        if (!(c < t.near || c > t.far)) return {
          distance: c,
          point: Md.clone().applyMatrix4(n.matrixWorld),
          index: o,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: n
        };
      }
      const Sd = new O(), wd = new O();
      class Ua extends lb {
        constructor(t, e) {
          super(t, e), this.isLineSegments = true, this.type = "LineSegments";
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const e = t.attributes.position, i = [];
            for (let s = 0, r = e.count; s < r; s += 2) Sd.fromBufferAttribute(e, s), wd.fromBufferAttribute(e, s + 1), i[s] = s === 0 ? 0 : i[s - 1], i[s + 1] = i[s] + Sd.distanceTo(wd);
            t.setAttribute("lineDistance", new en(i, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class Yl extends tn {
        constructor(t, e, i, s, r, o, a, l, c) {
          super(t, e, i, s, r, o, a, l, c), this.isCanvasTexture = true, this.needsUpdate = true;
        }
      }
      class Hm extends tn {
        constructor(t, e, i = os, s, r, o, a = Ln, l = Ln, c, h = Zr) {
          if (h !== Zr && h !== Qr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          super(null, s, r, o, a, l, h, i, c), this.isDepthTexture = true, this.image = {
            width: t,
            height: e
          }, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
        }
        copy(t) {
          return super.copy(t), this.source = new Yh(Object.assign({}, t.image)), this.compareFunction = t.compareFunction, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
        }
      }
      const jo = new O(), qo = new O(), jl = new O(), $o = new gn();
      class cb extends xn {
        constructor(t = null, e = 1) {
          if (super(), this.type = "EdgesGeometry", this.parameters = {
            geometry: t,
            thresholdAngle: e
          }, t !== null) {
            const s = Math.pow(10, 4), r = Math.cos(Hr * e), o = t.getIndex(), a = t.getAttribute("position"), l = o ? o.count : a.count, c = [
              0,
              0,
              0
            ], h = [
              "a",
              "b",
              "c"
            ], u = new Array(3), d = {}, f = [];
            for (let g = 0; g < l; g += 3) {
              o ? (c[0] = o.getX(g), c[1] = o.getX(g + 1), c[2] = o.getX(g + 2)) : (c[0] = g, c[1] = g + 1, c[2] = g + 2);
              const { a: _, b: m, c: p } = $o;
              if (_.fromBufferAttribute(a, c[0]), m.fromBufferAttribute(a, c[1]), p.fromBufferAttribute(a, c[2]), $o.getNormal(jl), u[0] = `${Math.round(_.x * s)},${Math.round(_.y * s)},${Math.round(_.z * s)}`, u[1] = `${Math.round(m.x * s)},${Math.round(m.y * s)},${Math.round(m.z * s)}`, u[2] = `${Math.round(p.x * s)},${Math.round(p.y * s)},${Math.round(p.z * s)}`, !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0])) for (let y = 0; y < 3; y++) {
                const w = (y + 1) % 3, M = u[y], C = u[w], R = $o[h[y]], T = $o[h[w]], v = `${M}_${C}`, x = `${C}_${M}`;
                x in d && d[x] ? (jl.dot(d[x].normal) <= r && (f.push(R.x, R.y, R.z), f.push(T.x, T.y, T.z)), d[x] = null) : v in d || (d[v] = {
                  index0: c[y],
                  index1: c[w],
                  normal: jl.clone()
                });
              }
            }
            for (const g in d) if (d[g]) {
              const { index0: _, index1: m } = d[g];
              jo.fromBufferAttribute(a, _), qo.fromBufferAttribute(a, m), f.push(jo.x, jo.y, jo.z), f.push(qo.x, qo.y, qo.z);
            }
            this.setAttribute("position", new en(f, 3));
          }
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
      }
      class lo extends xn {
        constructor(t = 1, e = 1, i = 1, s = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: s
          };
          const r = t / 2, o = e / 2, a = Math.floor(i), l = Math.floor(s), c = a + 1, h = l + 1, u = t / a, d = e / l, f = [], g = [], _ = [], m = [];
          for (let p = 0; p < h; p++) {
            const y = p * d - o;
            for (let w = 0; w < c; w++) {
              const M = w * u - r;
              g.push(M, -y, 0), _.push(0, 0, 1), m.push(w / a), m.push(1 - p / l);
            }
          }
          for (let p = 0; p < l; p++) for (let y = 0; y < a; y++) {
            const w = y + c * p, M = y + c * (p + 1), C = y + 1 + c * (p + 1), R = y + 1 + c * p;
            f.push(w, M, R), f.push(M, C, R);
          }
          this.setIndex(f), this.setAttribute("position", new en(g, 3)), this.setAttribute("normal", new en(_, 3)), this.setAttribute("uv", new en(m, 2));
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new lo(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      class hb extends xn {
        constructor(t = null) {
          if (super(), this.type = "WireframeGeometry", this.parameters = {
            geometry: t
          }, t !== null) {
            const e = [], i = /* @__PURE__ */ new Set(), s = new O(), r = new O();
            if (t.index !== null) {
              const o = t.attributes.position, a = t.index;
              let l = t.groups;
              l.length === 0 && (l = [
                {
                  start: 0,
                  count: a.count,
                  materialIndex: 0
                }
              ]);
              for (let c = 0, h = l.length; c < h; ++c) {
                const u = l[c], d = u.start, f = u.count;
                for (let g = d, _ = d + f; g < _; g += 3) for (let m = 0; m < 3; m++) {
                  const p = a.getX(g + m), y = a.getX(g + (m + 1) % 3);
                  s.fromBufferAttribute(o, p), r.fromBufferAttribute(o, y), Ed(s, r, i) === true && (e.push(s.x, s.y, s.z), e.push(r.x, r.y, r.z));
                }
              }
            } else {
              const o = t.attributes.position;
              for (let a = 0, l = o.count / 3; a < l; a++) for (let c = 0; c < 3; c++) {
                const h = 3 * a + c, u = 3 * a + (c + 1) % 3;
                s.fromBufferAttribute(o, h), r.fromBufferAttribute(o, u), Ed(s, r, i) === true && (e.push(s.x, s.y, s.z), e.push(r.x, r.y, r.z));
              }
            }
            this.setAttribute("position", new en(e, 3));
          }
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
      }
      function Ed(n, t, e) {
        const i = `${n.x},${n.y},${n.z}-${t.x},${t.y},${t.z}`, s = `${t.x},${t.y},${t.z}-${n.x},${n.y},${n.z}`;
        return e.has(i) === true || e.has(s) === true ? false : (e.add(i), e.add(s), true);
      }
      class ub extends ps {
        constructor(t) {
          super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new qt(16777215), this.specular = new qt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rm, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Wn(), this.combine = Bh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
        }
      }
      class db extends ps {
        constructor(t) {
          super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = xx, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
        }
      }
      class fb extends ps {
        constructor(t) {
          super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
        }
      }
      class Vm extends $e {
        constructor(t, e = 1) {
          super(), this.isLight = true, this.type = "Light", this.color = new qt(t), this.intensity = e;
        }
        dispose() {
        }
        copy(t, e) {
          return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
        }
      }
      const ql = new ye(), Td = new O(), Ad = new O();
      class pb {
        constructor(t) {
          this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ft(512, 512), this.mapType = Vn, this.map = null, this.mapPass = null, this.matrix = new ye(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new $h(), this._frameExtents = new Ft(1, 1), this._viewportCount = 1, this._viewports = [
            new pe(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          const e = this.camera, i = this.matrix;
          Td.setFromMatrixPosition(t.matrixWorld), e.position.copy(Td), Ad.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Ad), e.updateMatrixWorld(), ql.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ql), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(ql);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.autoUpdate = t.autoUpdate, this.needsUpdate = t.needsUpdate, this.normalBias = t.normalBias, this.blurSamples = t.blurSamples, this.mapSize.copy(t.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = {};
          return this.intensity !== 1 && (t.intensity = this.intensity), this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
        }
      }
      const Cd = new ye(), Sr = new O(), $l = new O();
      class mb extends pb {
        constructor() {
          super(new mn(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new Ft(4, 2), this._viewportCount = 6, this._viewports = [
            new pe(2, 1, 1, 1),
            new pe(0, 1, 1, 1),
            new pe(3, 1, 1, 1),
            new pe(1, 1, 1, 1),
            new pe(3, 0, 1, 1),
            new pe(1, 0, 1, 1)
          ], this._cubeDirections = [
            new O(1, 0, 0),
            new O(-1, 0, 0),
            new O(0, 0, 1),
            new O(0, 0, -1),
            new O(0, 1, 0),
            new O(0, -1, 0)
          ], this._cubeUps = [
            new O(0, 1, 0),
            new O(0, 1, 0),
            new O(0, 1, 0),
            new O(0, 1, 0),
            new O(0, 0, 1),
            new O(0, 0, -1)
          ];
        }
        updateMatrices(t, e = 0) {
          const i = this.camera, s = this.matrix, r = t.distance || i.far;
          r !== i.far && (i.far = r, i.updateProjectionMatrix()), Sr.setFromMatrixPosition(t.matrixWorld), i.position.copy(Sr), $l.copy(i.position), $l.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt($l), i.updateMatrixWorld(), s.makeTranslation(-Sr.x, -Sr.y, -Sr.z), Cd.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Cd);
        }
      }
      class gb extends Vm {
        constructor(t, e, i = 0, s = 2) {
          super(t, e), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = s, this.shadow = new mb();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(t) {
          this.intensity = t / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t, e) {
          return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
        }
      }
      class _b extends Um {
        constructor(t = -1, e = 1, i = 1, s = -1, r = 0.1, o = 2e3) {
          super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = s, this.near = r, this.far = o, this.updateProjectionMatrix();
        }
        copy(t, e) {
          return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
        }
        setViewOffset(t, e, i, s, r, o) {
          this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
          let r = i - t, o = i + t, a = s + e, l = s - e;
          if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += c * this.view.offsetX, o = r + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
        }
      }
      class xb extends Vm {
        constructor(t, e) {
          super(t, e), this.isAmbientLight = true, this.type = "AmbientLight";
        }
      }
      class bb extends mn {
        constructor(t = []) {
          super(), this.isArrayCamera = true, this.isMultiViewCamera = false, this.cameras = t;
        }
      }
      class Rd {
        constructor(t = 1, e = 0, i = 0) {
          this.radius = t, this.phi = e, this.theta = i;
        }
        set(t, e, i) {
          return this.radius = t, this.phi = e, this.theta = i, this;
        }
        copy(t) {
          return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
        }
        makeSafe() {
          return this.phi = $t(this.phi, 1e-6, Math.PI - 1e-6), this;
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, e, i) {
          return this.radius = Math.sqrt(t * t + e * e + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos($t(e / this.radius, -1, 1))), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class yb extends Ua {
        constructor(t = 10, e = 10, i = 4473924, s = 8947848) {
          i = new qt(i), s = new qt(s);
          const r = e / 2, o = t / e, a = t / 2, l = [], c = [];
          for (let d = 0, f = 0, g = -a; d <= e; d++, g += o) {
            l.push(-a, 0, g, a, 0, g), l.push(g, 0, -a, g, 0, a);
            const _ = d === r ? i : s;
            _.toArray(c, f), f += 3, _.toArray(c, f), f += 3, _.toArray(c, f), f += 3, _.toArray(c, f), f += 3;
          }
          const h = new xn();
          h.setAttribute("position", new en(l, 3)), h.setAttribute("color", new en(c, 3));
          const u = new Jr({
            vertexColors: true,
            toneMapped: false
          });
          super(h, u), this.type = "GridHelper";
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      class vb extends Ua {
        constructor(t = 1) {
          const e = [
            0,
            0,
            0,
            t,
            0,
            0,
            0,
            0,
            0,
            0,
            t,
            0,
            0,
            0,
            0,
            0,
            0,
            t
          ], i = [
            1,
            0,
            0,
            1,
            0.6,
            0,
            0,
            1,
            0,
            0.6,
            1,
            0,
            0,
            0,
            1,
            0,
            0.6,
            1
          ], s = new xn();
          s.setAttribute("position", new en(e, 3)), s.setAttribute("color", new en(i, 3));
          const r = new Jr({
            vertexColors: true,
            toneMapped: false
          });
          super(s, r), this.type = "AxesHelper";
        }
        setColors(t, e, i) {
          const s = new qt(), r = this.geometry.attributes.color.array;
          return s.set(t), s.toArray(r, 0), s.toArray(r, 3), s.set(e), s.toArray(r, 6), s.toArray(r, 9), s.set(i), s.toArray(r, 12), s.toArray(r, 15), this.geometry.attributes.color.needsUpdate = true, this;
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      class Mb extends fs {
        constructor(t, e = null) {
          super(), this.object = t, this.domElement = e, this.enabled = true, this.state = -1, this.keys = {}, this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
          }, this.touches = {
            ONE: null,
            TWO: null
          };
        }
        connect(t) {
          if (t === void 0) {
            console.warn("THREE.Controls: connect() now requires an element.");
            return;
          }
          this.domElement !== null && this.disconnect(), this.domElement = t;
        }
        disconnect() {
        }
        dispose() {
        }
        update() {
        }
      }
      function Pd(n, t, e, i) {
        const s = Sb(i);
        switch (e) {
          case wm:
            return n * t;
          case Tm:
            return n * t / s.components * s.byteLength;
          case Wh:
            return n * t / s.components * s.byteLength;
          case Am:
            return n * t * 2 / s.components * s.byteLength;
          case Gh:
            return n * t * 2 / s.components * s.byteLength;
          case Em:
            return n * t * 3 / s.components * s.byteLength;
          case Pn:
            return n * t * 4 / s.components * s.byteLength;
          case Xh:
            return n * t * 4 / s.components * s.byteLength;
          case ba:
          case ya:
            return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case va:
          case Ma:
            return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Nc:
          case Bc:
            return Math.max(n, 16) * Math.max(t, 8) / 4;
          case Fc:
          case Uc:
            return Math.max(n, 8) * Math.max(t, 8) / 2;
          case zc:
          case Hc:
            return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case Vc:
            return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Wc:
            return Math.floor((n + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Gc:
            return Math.floor((n + 4) / 5) * Math.floor((t + 3) / 4) * 16;
          case Xc:
            return Math.floor((n + 4) / 5) * Math.floor((t + 4) / 5) * 16;
          case Yc:
            return Math.floor((n + 5) / 6) * Math.floor((t + 4) / 5) * 16;
          case jc:
            return Math.floor((n + 5) / 6) * Math.floor((t + 5) / 6) * 16;
          case qc:
            return Math.floor((n + 7) / 8) * Math.floor((t + 4) / 5) * 16;
          case $c:
            return Math.floor((n + 7) / 8) * Math.floor((t + 5) / 6) * 16;
          case Kc:
            return Math.floor((n + 7) / 8) * Math.floor((t + 7) / 8) * 16;
          case Zc:
            return Math.floor((n + 9) / 10) * Math.floor((t + 4) / 5) * 16;
          case Qc:
            return Math.floor((n + 9) / 10) * Math.floor((t + 5) / 6) * 16;
          case Jc:
            return Math.floor((n + 9) / 10) * Math.floor((t + 7) / 8) * 16;
          case th:
            return Math.floor((n + 9) / 10) * Math.floor((t + 9) / 10) * 16;
          case eh:
            return Math.floor((n + 11) / 12) * Math.floor((t + 9) / 10) * 16;
          case nh:
            return Math.floor((n + 11) / 12) * Math.floor((t + 11) / 12) * 16;
          case Sa:
          case ih:
          case sh:
            return Math.ceil(n / 4) * Math.ceil(t / 4) * 16;
          case Cm:
          case rh:
            return Math.ceil(n / 4) * Math.ceil(t / 4) * 8;
          case oh:
          case ah:
            return Math.ceil(n / 4) * Math.ceil(t / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${e} format.`);
      }
      function Sb(n) {
        switch (n) {
          case Vn:
          case vm:
            return {
              byteLength: 1,
              components: 1
            };
          case $r:
          case Mm:
          case oo:
            return {
              byteLength: 2,
              components: 1
            };
          case Hh:
          case Vh:
            return {
              byteLength: 2,
              components: 4
            };
          case os:
          case zh:
          case si:
            return {
              byteLength: 4,
              components: 1
            };
          case Sm:
            return {
              byteLength: 4,
              components: 3
            };
        }
        throw new Error(`Unknown texture type ${n}.`);
      }
      typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: Uh
        }
      }));
      typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Uh);
      function Wm() {
        let n = null, t = false, e = null, i = null;
        function s(r, o) {
          e(r, o), i = n.requestAnimationFrame(s);
        }
        return {
          start: function() {
            t !== true && e !== null && (i = n.requestAnimationFrame(s), t = true);
          },
          stop: function() {
            n.cancelAnimationFrame(i), t = false;
          },
          setAnimationLoop: function(r) {
            e = r;
          },
          setContext: function(r) {
            n = r;
          }
        };
      }
      function wb(n) {
        const t = /* @__PURE__ */ new WeakMap();
        function e(a, l) {
          const c = a.array, h = a.usage, u = c.byteLength, d = n.createBuffer();
          n.bindBuffer(l, d), n.bufferData(l, c, h), a.onUploadCallback();
          let f;
          if (c instanceof Float32Array) f = n.FLOAT;
          else if (c instanceof Uint16Array) a.isFloat16BufferAttribute ? f = n.HALF_FLOAT : f = n.UNSIGNED_SHORT;
          else if (c instanceof Int16Array) f = n.SHORT;
          else if (c instanceof Uint32Array) f = n.UNSIGNED_INT;
          else if (c instanceof Int32Array) f = n.INT;
          else if (c instanceof Int8Array) f = n.BYTE;
          else if (c instanceof Uint8Array) f = n.UNSIGNED_BYTE;
          else if (c instanceof Uint8ClampedArray) f = n.UNSIGNED_BYTE;
          else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
          return {
            buffer: d,
            type: f,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: u
          };
        }
        function i(a, l, c) {
          const h = l.array, u = l.updateRanges;
          if (n.bindBuffer(c, a), u.length === 0) n.bufferSubData(c, 0, h);
          else {
            u.sort((f, g) => f.start - g.start);
            let d = 0;
            for (let f = 1; f < u.length; f++) {
              const g = u[d], _ = u[f];
              _.start <= g.start + g.count + 1 ? g.count = Math.max(g.count, _.start + _.count - g.start) : (++d, u[d] = _);
            }
            u.length = d + 1;
            for (let f = 0, g = u.length; f < g; f++) {
              const _ = u[f];
              n.bufferSubData(c, _.start * h.BYTES_PER_ELEMENT, h, _.start, _.count);
            }
            l.clearUpdateRanges();
          }
          l.onUploadCallback();
        }
        function s(a) {
          return a.isInterleavedBufferAttribute && (a = a.data), t.get(a);
        }
        function r(a) {
          a.isInterleavedBufferAttribute && (a = a.data);
          const l = t.get(a);
          l && (n.deleteBuffer(l.buffer), t.delete(a));
        }
        function o(a, l) {
          if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
            const h = t.get(a);
            (!h || h.version < a.version) && t.set(a, {
              buffer: a.buffer,
              type: a.type,
              bytesPerElement: a.elementSize,
              version: a.version
            });
            return;
          }
          const c = t.get(a);
          if (c === void 0) t.set(a, e(a, l));
          else if (c.version < a.version) {
            if (c.size !== a.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(c.buffer, a, l), c.version = a.version;
          }
        }
        return {
          get: s,
          remove: r,
          update: o
        };
      }
      var Eb = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Tb = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Ab = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Cb = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Rb = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, Pb = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Db = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Lb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Ib = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, Ob = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, kb = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Fb = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Nb = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Ub = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Bb = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, zb = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Hb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Vb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Wb = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Gb = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Xb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Yb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, jb = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, qb = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, $b = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Kb = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Zb = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Qb = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Jb = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, ty = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, ey = "gl_FragColor = linearToOutputTexel( gl_FragColor );", ny = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, iy = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, sy = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, ry = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, oy = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, ay = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, ly = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, cy = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, hy = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, uy = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, dy = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, fy = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, py = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, my = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, gy = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, _y = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, xy = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, by = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, yy = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, vy = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, My = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Sy = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, wy = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Ey = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Ty = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Ay = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Cy = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Ry = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Py = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Dy = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Ly = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Iy = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Oy = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, ky = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Fy = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Ny = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, Uy = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, By = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, zy = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Hy = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Vy = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Wy = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Gy = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Xy = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Yy = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, jy = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, qy = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, $y = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Ky = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Zy = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Qy = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Jy = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, tv = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, ev = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, nv = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, iv = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, sv = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, rv = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, ov = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, av = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, lv = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, cv = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, hv = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, uv = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, dv = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, fv = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, pv = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, mv = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, gv = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, _v = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, xv = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, bv = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, yv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, vv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Mv = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Sv = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const wv = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Ev = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Tv = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Av = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Cv = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Rv = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Pv = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Dv = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Lv = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Iv = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Ov = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, kv = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Fv = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Nv = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Uv = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Bv = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, zv = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Hv = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Vv = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Wv = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Gv = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Xv = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Yv = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, jv = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qv = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, $v = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Kv = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Zv = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Qv = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Jv = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, tM = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, eM = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, nM = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, iM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, jt = {
        alphahash_fragment: Eb,
        alphahash_pars_fragment: Tb,
        alphamap_fragment: Ab,
        alphamap_pars_fragment: Cb,
        alphatest_fragment: Rb,
        alphatest_pars_fragment: Pb,
        aomap_fragment: Db,
        aomap_pars_fragment: Lb,
        batching_pars_vertex: Ib,
        batching_vertex: Ob,
        begin_vertex: kb,
        beginnormal_vertex: Fb,
        bsdfs: Nb,
        iridescence_fragment: Ub,
        bumpmap_pars_fragment: Bb,
        clipping_planes_fragment: zb,
        clipping_planes_pars_fragment: Hb,
        clipping_planes_pars_vertex: Vb,
        clipping_planes_vertex: Wb,
        color_fragment: Gb,
        color_pars_fragment: Xb,
        color_pars_vertex: Yb,
        color_vertex: jb,
        common: qb,
        cube_uv_reflection_fragment: $b,
        defaultnormal_vertex: Kb,
        displacementmap_pars_vertex: Zb,
        displacementmap_vertex: Qb,
        emissivemap_fragment: Jb,
        emissivemap_pars_fragment: ty,
        colorspace_fragment: ey,
        colorspace_pars_fragment: ny,
        envmap_fragment: iy,
        envmap_common_pars_fragment: sy,
        envmap_pars_fragment: ry,
        envmap_pars_vertex: oy,
        envmap_physical_pars_fragment: _y,
        envmap_vertex: ay,
        fog_vertex: ly,
        fog_pars_vertex: cy,
        fog_fragment: hy,
        fog_pars_fragment: uy,
        gradientmap_pars_fragment: dy,
        lightmap_pars_fragment: fy,
        lights_lambert_fragment: py,
        lights_lambert_pars_fragment: my,
        lights_pars_begin: gy,
        lights_toon_fragment: xy,
        lights_toon_pars_fragment: by,
        lights_phong_fragment: yy,
        lights_phong_pars_fragment: vy,
        lights_physical_fragment: My,
        lights_physical_pars_fragment: Sy,
        lights_fragment_begin: wy,
        lights_fragment_maps: Ey,
        lights_fragment_end: Ty,
        logdepthbuf_fragment: Ay,
        logdepthbuf_pars_fragment: Cy,
        logdepthbuf_pars_vertex: Ry,
        logdepthbuf_vertex: Py,
        map_fragment: Dy,
        map_pars_fragment: Ly,
        map_particle_fragment: Iy,
        map_particle_pars_fragment: Oy,
        metalnessmap_fragment: ky,
        metalnessmap_pars_fragment: Fy,
        morphinstance_vertex: Ny,
        morphcolor_vertex: Uy,
        morphnormal_vertex: By,
        morphtarget_pars_vertex: zy,
        morphtarget_vertex: Hy,
        normal_fragment_begin: Vy,
        normal_fragment_maps: Wy,
        normal_pars_fragment: Gy,
        normal_pars_vertex: Xy,
        normal_vertex: Yy,
        normalmap_pars_fragment: jy,
        clearcoat_normal_fragment_begin: qy,
        clearcoat_normal_fragment_maps: $y,
        clearcoat_pars_fragment: Ky,
        iridescence_pars_fragment: Zy,
        opaque_fragment: Qy,
        packing: Jy,
        premultiplied_alpha_fragment: tv,
        project_vertex: ev,
        dithering_fragment: nv,
        dithering_pars_fragment: iv,
        roughnessmap_fragment: sv,
        roughnessmap_pars_fragment: rv,
        shadowmap_pars_fragment: ov,
        shadowmap_pars_vertex: av,
        shadowmap_vertex: lv,
        shadowmask_pars_fragment: cv,
        skinbase_vertex: hv,
        skinning_pars_vertex: uv,
        skinning_vertex: dv,
        skinnormal_vertex: fv,
        specularmap_fragment: pv,
        specularmap_pars_fragment: mv,
        tonemapping_fragment: gv,
        tonemapping_pars_fragment: _v,
        transmission_fragment: xv,
        transmission_pars_fragment: bv,
        uv_pars_fragment: yv,
        uv_pars_vertex: vv,
        uv_vertex: Mv,
        worldpos_vertex: Sv,
        background_vert: wv,
        background_frag: Ev,
        backgroundCube_vert: Tv,
        backgroundCube_frag: Av,
        cube_vert: Cv,
        cube_frag: Rv,
        depth_vert: Pv,
        depth_frag: Dv,
        distanceRGBA_vert: Lv,
        distanceRGBA_frag: Iv,
        equirect_vert: Ov,
        equirect_frag: kv,
        linedashed_vert: Fv,
        linedashed_frag: Nv,
        meshbasic_vert: Uv,
        meshbasic_frag: Bv,
        meshlambert_vert: zv,
        meshlambert_frag: Hv,
        meshmatcap_vert: Vv,
        meshmatcap_frag: Wv,
        meshnormal_vert: Gv,
        meshnormal_frag: Xv,
        meshphong_vert: Yv,
        meshphong_frag: jv,
        meshphysical_vert: qv,
        meshphysical_frag: $v,
        meshtoon_vert: Kv,
        meshtoon_frag: Zv,
        points_vert: Qv,
        points_frag: Jv,
        shadow_vert: tM,
        shadow_frag: eM,
        sprite_vert: nM,
        sprite_frag: iM
      }, mt = {
        common: {
          diffuse: {
            value: new qt(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Xt()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Xt()
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          },
          specularMapTransform: {
            value: new Xt()
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          envMapRotation: {
            value: new Xt()
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          },
          aoMapTransform: {
            value: new Xt()
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          },
          lightMapTransform: {
            value: new Xt()
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpMapTransform: {
            value: new Xt()
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalMapTransform: {
            value: new Xt()
          },
          normalScale: {
            value: new Ft(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementMapTransform: {
            value: new Xt()
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          },
          emissiveMapTransform: {
            value: new Xt()
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          },
          metalnessMapTransform: {
            value: new Xt()
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          },
          roughnessMapTransform: {
            value: new Xt()
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new qt(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotLightMap: {
            value: []
          },
          spotShadowMap: {
            value: []
          },
          spotLightMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new qt(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Xt()
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Xt()
          }
        },
        sprite: {
          diffuse: {
            value: new qt(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new Ft(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Xt()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Xt()
          },
          alphaTest: {
            value: 0
          }
        }
      }, Fn = {
        basic: {
          uniforms: Je([
            mt.common,
            mt.specularmap,
            mt.envmap,
            mt.aomap,
            mt.lightmap,
            mt.fog
          ]),
          vertexShader: jt.meshbasic_vert,
          fragmentShader: jt.meshbasic_frag
        },
        lambert: {
          uniforms: Je([
            mt.common,
            mt.specularmap,
            mt.envmap,
            mt.aomap,
            mt.lightmap,
            mt.emissivemap,
            mt.bumpmap,
            mt.normalmap,
            mt.displacementmap,
            mt.fog,
            mt.lights,
            {
              emissive: {
                value: new qt(0)
              }
            }
          ]),
          vertexShader: jt.meshlambert_vert,
          fragmentShader: jt.meshlambert_frag
        },
        phong: {
          uniforms: Je([
            mt.common,
            mt.specularmap,
            mt.envmap,
            mt.aomap,
            mt.lightmap,
            mt.emissivemap,
            mt.bumpmap,
            mt.normalmap,
            mt.displacementmap,
            mt.fog,
            mt.lights,
            {
              emissive: {
                value: new qt(0)
              },
              specular: {
                value: new qt(1118481)
              },
              shininess: {
                value: 30
              }
            }
          ]),
          vertexShader: jt.meshphong_vert,
          fragmentShader: jt.meshphong_frag
        },
        standard: {
          uniforms: Je([
            mt.common,
            mt.envmap,
            mt.aomap,
            mt.lightmap,
            mt.emissivemap,
            mt.bumpmap,
            mt.normalmap,
            mt.displacementmap,
            mt.roughnessmap,
            mt.metalnessmap,
            mt.fog,
            mt.lights,
            {
              emissive: {
                value: new qt(0)
              },
              roughness: {
                value: 1
              },
              metalness: {
                value: 0
              },
              envMapIntensity: {
                value: 1
              }
            }
          ]),
          vertexShader: jt.meshphysical_vert,
          fragmentShader: jt.meshphysical_frag
        },
        toon: {
          uniforms: Je([
            mt.common,
            mt.aomap,
            mt.lightmap,
            mt.emissivemap,
            mt.bumpmap,
            mt.normalmap,
            mt.displacementmap,
            mt.gradientmap,
            mt.fog,
            mt.lights,
            {
              emissive: {
                value: new qt(0)
              }
            }
          ]),
          vertexShader: jt.meshtoon_vert,
          fragmentShader: jt.meshtoon_frag
        },
        matcap: {
          uniforms: Je([
            mt.common,
            mt.bumpmap,
            mt.normalmap,
            mt.displacementmap,
            mt.fog,
            {
              matcap: {
                value: null
              }
            }
          ]),
          vertexShader: jt.meshmatcap_vert,
          fragmentShader: jt.meshmatcap_frag
        },
        points: {
          uniforms: Je([
            mt.points,
            mt.fog
          ]),
          vertexShader: jt.points_vert,
          fragmentShader: jt.points_frag
        },
        dashed: {
          uniforms: Je([
            mt.common,
            mt.fog,
            {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }
          ]),
          vertexShader: jt.linedashed_vert,
          fragmentShader: jt.linedashed_frag
        },
        depth: {
          uniforms: Je([
            mt.common,
            mt.displacementmap
          ]),
          vertexShader: jt.depth_vert,
          fragmentShader: jt.depth_frag
        },
        normal: {
          uniforms: Je([
            mt.common,
            mt.bumpmap,
            mt.normalmap,
            mt.displacementmap,
            {
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: jt.meshnormal_vert,
          fragmentShader: jt.meshnormal_frag
        },
        sprite: {
          uniforms: Je([
            mt.sprite,
            mt.fog
          ]),
          vertexShader: jt.sprite_vert,
          fragmentShader: jt.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Xt()
            },
            t2D: {
              value: null
            },
            backgroundIntensity: {
              value: 1
            }
          },
          vertexShader: jt.background_vert,
          fragmentShader: jt.background_frag
        },
        backgroundCube: {
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            },
            backgroundBlurriness: {
              value: 0
            },
            backgroundIntensity: {
              value: 1
            },
            backgroundRotation: {
              value: new Xt()
            }
          },
          vertexShader: jt.backgroundCube_vert,
          fragmentShader: jt.backgroundCube_frag
        },
        cube: {
          uniforms: {
            tCube: {
              value: null
            },
            tFlip: {
              value: -1
            },
            opacity: {
              value: 1
            }
          },
          vertexShader: jt.cube_vert,
          fragmentShader: jt.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: jt.equirect_vert,
          fragmentShader: jt.equirect_frag
        },
        distanceRGBA: {
          uniforms: Je([
            mt.common,
            mt.displacementmap,
            {
              referencePosition: {
                value: new O()
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1e3
              }
            }
          ]),
          vertexShader: jt.distanceRGBA_vert,
          fragmentShader: jt.distanceRGBA_frag
        },
        shadow: {
          uniforms: Je([
            mt.lights,
            mt.fog,
            {
              color: {
                value: new qt(0)
              },
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: jt.shadow_vert,
          fragmentShader: jt.shadow_frag
        }
      };
      Fn.physical = {
        uniforms: Je([
          Fn.standard.uniforms,
          {
            clearcoat: {
              value: 0
            },
            clearcoatMap: {
              value: null
            },
            clearcoatMapTransform: {
              value: new Xt()
            },
            clearcoatNormalMap: {
              value: null
            },
            clearcoatNormalMapTransform: {
              value: new Xt()
            },
            clearcoatNormalScale: {
              value: new Ft(1, 1)
            },
            clearcoatRoughness: {
              value: 0
            },
            clearcoatRoughnessMap: {
              value: null
            },
            clearcoatRoughnessMapTransform: {
              value: new Xt()
            },
            dispersion: {
              value: 0
            },
            iridescence: {
              value: 0
            },
            iridescenceMap: {
              value: null
            },
            iridescenceMapTransform: {
              value: new Xt()
            },
            iridescenceIOR: {
              value: 1.3
            },
            iridescenceThicknessMinimum: {
              value: 100
            },
            iridescenceThicknessMaximum: {
              value: 400
            },
            iridescenceThicknessMap: {
              value: null
            },
            iridescenceThicknessMapTransform: {
              value: new Xt()
            },
            sheen: {
              value: 0
            },
            sheenColor: {
              value: new qt(0)
            },
            sheenColorMap: {
              value: null
            },
            sheenColorMapTransform: {
              value: new Xt()
            },
            sheenRoughness: {
              value: 1
            },
            sheenRoughnessMap: {
              value: null
            },
            sheenRoughnessMapTransform: {
              value: new Xt()
            },
            transmission: {
              value: 0
            },
            transmissionMap: {
              value: null
            },
            transmissionMapTransform: {
              value: new Xt()
            },
            transmissionSamplerSize: {
              value: new Ft()
            },
            transmissionSamplerMap: {
              value: null
            },
            thickness: {
              value: 0
            },
            thicknessMap: {
              value: null
            },
            thicknessMapTransform: {
              value: new Xt()
            },
            attenuationDistance: {
              value: 0
            },
            attenuationColor: {
              value: new qt(0)
            },
            specularColor: {
              value: new qt(1, 1, 1)
            },
            specularColorMap: {
              value: null
            },
            specularColorMapTransform: {
              value: new Xt()
            },
            specularIntensity: {
              value: 1
            },
            specularIntensityMap: {
              value: null
            },
            specularIntensityMapTransform: {
              value: new Xt()
            },
            anisotropyVector: {
              value: new Ft()
            },
            anisotropyMap: {
              value: null
            },
            anisotropyMapTransform: {
              value: new Xt()
            }
          }
        ]),
        vertexShader: jt.meshphysical_vert,
        fragmentShader: jt.meshphysical_frag
      };
      const Ko = {
        r: 0,
        b: 0,
        g: 0
      }, Gi = new Wn(), sM = new ye();
      function rM(n, t, e, i, s, r, o) {
        const a = new qt(0);
        let l = r === true ? 0 : 1, c, h, u = null, d = 0, f = null;
        function g(w) {
          let M = w.isScene === true ? w.background : null;
          return M && M.isTexture && (M = (w.backgroundBlurriness > 0 ? e : t).get(M)), M;
        }
        function _(w) {
          let M = false;
          const C = g(w);
          C === null ? p(a, l) : C && C.isColor && (p(C, 1), M = true);
          const R = n.xr.getEnvironmentBlendMode();
          R === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : R === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (n.autoClear || M) && (i.buffers.depth.setTest(true), i.buffers.depth.setMask(true), i.buffers.color.setMask(true), n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
        }
        function m(w, M) {
          const C = g(M);
          C && (C.isCubeTexture || C.mapping === tl) ? (h === void 0 && (h = new Dn(new cs(1, 1, 1), new Li({
            name: "BackgroundCubeMaterial",
            uniforms: nr(Fn.backgroundCube.uniforms),
            vertexShader: Fn.backgroundCube.vertexShader,
            fragmentShader: Fn.backgroundCube.fragmentShader,
            side: an,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(R, T, v) {
            this.matrixWorld.copyPosition(v.matrixWorld);
          }, Object.defineProperty(h.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          }), s.update(h)), Gi.copy(M.backgroundRotation), Gi.x *= -1, Gi.y *= -1, Gi.z *= -1, C.isCubeTexture && C.isRenderTargetTexture === false && (Gi.y *= -1, Gi.z *= -1), h.material.uniforms.envMap.value = C, h.material.uniforms.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = M.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(sM.makeRotationFromEuler(Gi)), h.material.toneMapped = ee.getTransfer(C.colorSpace) !== ue, (u !== C || d !== C.version || f !== n.toneMapping) && (h.material.needsUpdate = true, u = C, d = C.version, f = n.toneMapping), h.layers.enableAll(), w.unshift(h, h.geometry, h.material, 0, 0, null)) : C && C.isTexture && (c === void 0 && (c = new Dn(new lo(2, 2), new Li({
            name: "BackgroundMaterial",
            uniforms: nr(Fn.background.uniforms),
            vertexShader: Fn.background.vertexShader,
            fragmentShader: Fn.background.fragmentShader,
            side: Di,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          }), s.update(c)), c.material.uniforms.t2D.value = C, c.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, c.material.toneMapped = ee.getTransfer(C.colorSpace) !== ue, C.matrixAutoUpdate === true && C.updateMatrix(), c.material.uniforms.uvTransform.value.copy(C.matrix), (u !== C || d !== C.version || f !== n.toneMapping) && (c.material.needsUpdate = true, u = C, d = C.version, f = n.toneMapping), c.layers.enableAll(), w.unshift(c, c.geometry, c.material, 0, 0, null));
        }
        function p(w, M) {
          w.getRGB(Ko, Nm(n)), i.buffers.color.setClear(Ko.r, Ko.g, Ko.b, M, o);
        }
        function y() {
          h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
        }
        return {
          getClearColor: function() {
            return a;
          },
          setClearColor: function(w, M = 1) {
            a.set(w), l = M, p(a, l);
          },
          getClearAlpha: function() {
            return l;
          },
          setClearAlpha: function(w) {
            l = w, p(a, l);
          },
          render: _,
          addToRenderList: m,
          dispose: y
        };
      }
      function oM(n, t) {
        const e = n.getParameter(n.MAX_VERTEX_ATTRIBS), i = {}, s = d(null);
        let r = s, o = false;
        function a(b, A, L, I, H) {
          let j = false;
          const z = u(I, L, A);
          r !== z && (r = z, c(r.object)), j = f(b, I, L, H), j && g(b, I, L, H), H !== null && t.update(H, n.ELEMENT_ARRAY_BUFFER), (j || o) && (o = false, M(b, A, L, I), H !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(H).buffer));
        }
        function l() {
          return n.createVertexArray();
        }
        function c(b) {
          return n.bindVertexArray(b);
        }
        function h(b) {
          return n.deleteVertexArray(b);
        }
        function u(b, A, L) {
          const I = L.wireframe === true;
          let H = i[b.id];
          H === void 0 && (H = {}, i[b.id] = H);
          let j = H[A.id];
          j === void 0 && (j = {}, H[A.id] = j);
          let z = j[I];
          return z === void 0 && (z = d(l()), j[I] = z), z;
        }
        function d(b) {
          const A = [], L = [], I = [];
          for (let H = 0; H < e; H++) A[H] = 0, L[H] = 0, I[H] = 0;
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: A,
            enabledAttributes: L,
            attributeDivisors: I,
            object: b,
            attributes: {},
            index: null
          };
        }
        function f(b, A, L, I) {
          const H = r.attributes, j = A.attributes;
          let z = 0;
          const V = L.getAttributes();
          for (const U in V) if (V[U].location >= 0) {
            const rt = H[U];
            let et = j[U];
            if (et === void 0 && (U === "instanceMatrix" && b.instanceMatrix && (et = b.instanceMatrix), U === "instanceColor" && b.instanceColor && (et = b.instanceColor)), rt === void 0 || rt.attribute !== et || et && rt.data !== et.data) return true;
            z++;
          }
          return r.attributesNum !== z || r.index !== I;
        }
        function g(b, A, L, I) {
          const H = {}, j = A.attributes;
          let z = 0;
          const V = L.getAttributes();
          for (const U in V) if (V[U].location >= 0) {
            let rt = j[U];
            rt === void 0 && (U === "instanceMatrix" && b.instanceMatrix && (rt = b.instanceMatrix), U === "instanceColor" && b.instanceColor && (rt = b.instanceColor));
            const et = {};
            et.attribute = rt, rt && rt.data && (et.data = rt.data), H[U] = et, z++;
          }
          r.attributes = H, r.attributesNum = z, r.index = I;
        }
        function _() {
          const b = r.newAttributes;
          for (let A = 0, L = b.length; A < L; A++) b[A] = 0;
        }
        function m(b) {
          p(b, 0);
        }
        function p(b, A) {
          const L = r.newAttributes, I = r.enabledAttributes, H = r.attributeDivisors;
          L[b] = 1, I[b] === 0 && (n.enableVertexAttribArray(b), I[b] = 1), H[b] !== A && (n.vertexAttribDivisor(b, A), H[b] = A);
        }
        function y() {
          const b = r.newAttributes, A = r.enabledAttributes;
          for (let L = 0, I = A.length; L < I; L++) A[L] !== b[L] && (n.disableVertexAttribArray(L), A[L] = 0);
        }
        function w(b, A, L, I, H, j, z) {
          z === true ? n.vertexAttribIPointer(b, A, L, H, j) : n.vertexAttribPointer(b, A, L, I, H, j);
        }
        function M(b, A, L, I) {
          _();
          const H = I.attributes, j = L.getAttributes(), z = A.defaultAttributeValues;
          for (const V in j) {
            const U = j[V];
            if (U.location >= 0) {
              let q = H[V];
              if (q === void 0 && (V === "instanceMatrix" && b.instanceMatrix && (q = b.instanceMatrix), V === "instanceColor" && b.instanceColor && (q = b.instanceColor)), q !== void 0) {
                const rt = q.normalized, et = q.itemSize, ut = t.get(q);
                if (ut === void 0) continue;
                const ot = ut.buffer, W = ut.type, J = ut.bytesPerElement, ct = W === n.INT || W === n.UNSIGNED_INT || q.gpuType === zh;
                if (q.isInterleavedBufferAttribute) {
                  const ht = q.data, it = ht.stride, St = q.offset;
                  if (ht.isInstancedInterleavedBuffer) {
                    for (let lt = 0; lt < U.locationSize; lt++) p(U.location + lt, ht.meshPerAttribute);
                    b.isInstancedMesh !== true && I._maxInstanceCount === void 0 && (I._maxInstanceCount = ht.meshPerAttribute * ht.count);
                  } else for (let lt = 0; lt < U.locationSize; lt++) m(U.location + lt);
                  n.bindBuffer(n.ARRAY_BUFFER, ot);
                  for (let lt = 0; lt < U.locationSize; lt++) w(U.location + lt, et / U.locationSize, W, rt, it * J, (St + et / U.locationSize * lt) * J, ct);
                } else {
                  if (q.isInstancedBufferAttribute) {
                    for (let ht = 0; ht < U.locationSize; ht++) p(U.location + ht, q.meshPerAttribute);
                    b.isInstancedMesh !== true && I._maxInstanceCount === void 0 && (I._maxInstanceCount = q.meshPerAttribute * q.count);
                  } else for (let ht = 0; ht < U.locationSize; ht++) m(U.location + ht);
                  n.bindBuffer(n.ARRAY_BUFFER, ot);
                  for (let ht = 0; ht < U.locationSize; ht++) w(U.location + ht, et / U.locationSize, W, rt, et * J, et / U.locationSize * ht * J, ct);
                }
              } else if (z !== void 0) {
                const rt = z[V];
                if (rt !== void 0) switch (rt.length) {
                  case 2:
                    n.vertexAttrib2fv(U.location, rt);
                    break;
                  case 3:
                    n.vertexAttrib3fv(U.location, rt);
                    break;
                  case 4:
                    n.vertexAttrib4fv(U.location, rt);
                    break;
                  default:
                    n.vertexAttrib1fv(U.location, rt);
                }
              }
            }
          }
          y();
        }
        function C() {
          v();
          for (const b in i) {
            const A = i[b];
            for (const L in A) {
              const I = A[L];
              for (const H in I) h(I[H].object), delete I[H];
              delete A[L];
            }
            delete i[b];
          }
        }
        function R(b) {
          if (i[b.id] === void 0) return;
          const A = i[b.id];
          for (const L in A) {
            const I = A[L];
            for (const H in I) h(I[H].object), delete I[H];
            delete A[L];
          }
          delete i[b.id];
        }
        function T(b) {
          for (const A in i) {
            const L = i[A];
            if (L[b.id] === void 0) continue;
            const I = L[b.id];
            for (const H in I) h(I[H].object), delete I[H];
            delete L[b.id];
          }
        }
        function v() {
          x(), o = true, r !== s && (r = s, c(r.object));
        }
        function x() {
          s.geometry = null, s.program = null, s.wireframe = false;
        }
        return {
          setup: a,
          reset: v,
          resetDefaultState: x,
          dispose: C,
          releaseStatesOfGeometry: R,
          releaseStatesOfProgram: T,
          initAttributes: _,
          enableAttribute: m,
          disableUnusedAttributes: y
        };
      }
      function aM(n, t, e) {
        let i;
        function s(c) {
          i = c;
        }
        function r(c, h) {
          n.drawArrays(i, c, h), e.update(h, i, 1);
        }
        function o(c, h, u) {
          u !== 0 && (n.drawArraysInstanced(i, c, h, u), e.update(h, i, u));
        }
        function a(c, h, u) {
          if (u === 0) return;
          t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, h, 0, u);
          let f = 0;
          for (let g = 0; g < u; g++) f += h[g];
          e.update(f, i, 1);
        }
        function l(c, h, u, d) {
          if (u === 0) return;
          const f = t.get("WEBGL_multi_draw");
          if (f === null) for (let g = 0; g < c.length; g++) o(c[g], h[g], d[g]);
          else {
            f.multiDrawArraysInstancedWEBGL(i, c, 0, h, 0, d, 0, u);
            let g = 0;
            for (let _ = 0; _ < u; _++) g += h[_] * d[_];
            e.update(g, i, 1);
          }
        }
        this.setMode = s, this.render = r, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = l;
      }
      function lM(n, t, e, i) {
        let s;
        function r() {
          if (s !== void 0) return s;
          if (t.has("EXT_texture_filter_anisotropic") === true) {
            const T = t.get("EXT_texture_filter_anisotropic");
            s = n.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else s = 0;
          return s;
        }
        function o(T) {
          return !(T !== Pn && i.convert(T) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function a(T) {
          const v = T === oo && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
          return !(T !== Vn && i.convert(T) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && T !== si && !v);
        }
        function l(T) {
          if (T === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp";
            T = "mediump";
          }
          return T === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let c = e.precision !== void 0 ? e.precision : "highp";
        const h = l(c);
        h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
        const u = e.logarithmicDepthBuffer === true, d = e.reverseDepthBuffer === true && t.has("EXT_clip_control"), f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), g = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = n.getParameter(n.MAX_TEXTURE_SIZE), m = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), p = n.getParameter(n.MAX_VERTEX_ATTRIBS), y = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), w = n.getParameter(n.MAX_VARYING_VECTORS), M = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), C = g > 0, R = n.getParameter(n.MAX_SAMPLES);
        return {
          isWebGL2: true,
          getMaxAnisotropy: r,
          getMaxPrecision: l,
          textureFormatReadable: o,
          textureTypeReadable: a,
          precision: c,
          logarithmicDepthBuffer: u,
          reverseDepthBuffer: d,
          maxTextures: f,
          maxVertexTextures: g,
          maxTextureSize: _,
          maxCubemapSize: m,
          maxAttributes: p,
          maxVertexUniforms: y,
          maxVaryings: w,
          maxFragmentUniforms: M,
          vertexTextures: C,
          maxSamples: R
        };
      }
      function cM(n) {
        const t = this;
        let e = null, i = 0, s = false, r = false;
        const o = new bi(), a = new Xt(), l = {
          value: null,
          needsUpdate: false
        };
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, d) {
          const f = u.length !== 0 || d || i !== 0 || s;
          return s = d, i = u.length, f;
        }, this.beginShadows = function() {
          r = true, h(null);
        }, this.endShadows = function() {
          r = false;
        }, this.setGlobalState = function(u, d) {
          e = h(u, d, 0);
        }, this.setState = function(u, d, f) {
          const g = u.clippingPlanes, _ = u.clipIntersection, m = u.clipShadows, p = n.get(u);
          if (!s || g === null || g.length === 0 || r && !m) r ? h(null) : c();
          else {
            const y = r ? 0 : i, w = y * 4;
            let M = p.clippingState || null;
            l.value = M, M = h(g, d, w, f);
            for (let C = 0; C !== w; ++C) M[C] = e[C];
            p.clippingState = M, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += y;
          }
        };
        function c() {
          l.value !== e && (l.value = e, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0;
        }
        function h(u, d, f, g) {
          const _ = u !== null ? u.length : 0;
          let m = null;
          if (_ !== 0) {
            if (m = l.value, g !== true || m === null) {
              const p = f + _ * 4, y = d.matrixWorldInverse;
              a.getNormalMatrix(y), (m === null || m.length < p) && (m = new Float32Array(p));
              for (let w = 0, M = f; w !== _; ++w, M += 4) o.copy(u[w]).applyMatrix4(y, a), o.normal.toArray(m, M), m[M + 3] = o.constant;
            }
            l.value = m, l.needsUpdate = true;
          }
          return t.numPlanes = _, t.numIntersection = 0, m;
        }
      }
      function hM(n) {
        let t = /* @__PURE__ */ new WeakMap();
        function e(o, a) {
          return a === Lc ? o.mapping = Js : a === Ic && (o.mapping = tr), o;
        }
        function i(o) {
          if (o && o.isTexture) {
            const a = o.mapping;
            if (a === Lc || a === Ic) if (t.has(o)) {
              const l = t.get(o).texture;
              return e(l, o.mapping);
            } else {
              const l = o.image;
              if (l && l.height > 0) {
                const c = new nb(l.height);
                return c.fromEquirectangularTexture(n, o), t.set(o, c), o.addEventListener("dispose", s), e(c.texture, o.mapping);
              } else return null;
            }
          }
          return o;
        }
        function s(o) {
          const a = o.target;
          a.removeEventListener("dispose", s);
          const l = t.get(a);
          l !== void 0 && (t.delete(a), l.dispose());
        }
        function r() {
          t = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: i,
          dispose: r
        };
      }
      const Gs = 4, Dd = [
        0.125,
        0.215,
        0.35,
        0.446,
        0.526,
        0.582
      ], es = 20, Kl = new _b(), Ld = new qt();
      let Zl = null, Ql = 0, Jl = 0, tc = false;
      const $i = (1 + Math.sqrt(5)) / 2, Us = 1 / $i, Id = [
        new O(-$i, Us, 0),
        new O($i, Us, 0),
        new O(-Us, 0, $i),
        new O(Us, 0, $i),
        new O(0, $i, -Us),
        new O(0, $i, Us),
        new O(-1, 1, -1),
        new O(1, 1, -1),
        new O(-1, 1, 1),
        new O(1, 1, 1)
      ], uM = new O();
      class Od {
        constructor(t) {
          this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, i = 0.1, s = 100, r = {}) {
          const { size: o = 256, position: a = uM } = r;
          Zl = this._renderer.getRenderTarget(), Ql = this._renderer.getActiveCubeFace(), Jl = this._renderer.getActiveMipmapLevel(), tc = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(o);
          const l = this._allocateTargets();
          return l.depthBuffer = true, this._sceneToCubeUV(t, i, s, l, a), e > 0 && this._blur(l, 0, 0, e), this._applyPMREM(l), this._cleanup(l), l;
        }
        fromEquirectangular(t, e = null) {
          return this._fromTexture(t, e);
        }
        fromCubemap(t, e = null) {
          return this._fromTexture(t, e);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null && (this._cubemapMaterial = Nd(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null && (this._equirectMaterial = Fd(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(t) {
          this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
          for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
        }
        _cleanup(t) {
          this._renderer.setRenderTarget(Zl, Ql, Jl), this._renderer.xr.enabled = tc, t.scissorTest = false, Zo(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, e) {
          t.mapping === Js || t.mapping === tr ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), Zl = this._renderer.getRenderTarget(), Ql = this._renderer.getActiveCubeFace(), Jl = this._renderer.getActiveMipmapLevel(), tc = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
          const i = e || this._allocateTargets();
          return this._textureToCubeUV(t, i), this._applyPMREM(i), this._cleanup(i), i;
        }
        _allocateTargets() {
          const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, i = {
            magFilter: _n,
            minFilter: _n,
            generateMipmaps: false,
            type: oo,
            format: Pn,
            colorSpace: er,
            depthBuffer: false
          }, s = kd(t, e, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = kd(t, e, i);
            const { _lodMax: r } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = dM(r)), this._blurMaterial = fM(r, t, e);
          }
          return s;
        }
        _compileMaterial(t) {
          const e = new Dn(this._lodPlanes[0], t);
          this._renderer.compile(e, Kl);
        }
        _sceneToCubeUV(t, e, i, s, r) {
          const l = new mn(90, 1, e, i), c = [
            1,
            -1,
            1,
            1,
            1,
            1
          ], h = [
            1,
            1,
            1,
            -1,
            -1,
            -1
          ], u = this._renderer, d = u.autoClear, f = u.toneMapping;
          u.getClearColor(Ld), u.toneMapping = Ei, u.autoClear = false;
          const g = new qh({
            name: "PMREM.Background",
            side: an,
            depthWrite: false,
            depthTest: false
          }), _ = new Dn(new cs(), g);
          let m = false;
          const p = t.background;
          p ? p.isColor && (g.color.copy(p), t.background = null, m = true) : (g.color.copy(Ld), m = true);
          for (let y = 0; y < 6; y++) {
            const w = y % 3;
            w === 0 ? (l.up.set(0, c[y], 0), l.position.set(r.x, r.y, r.z), l.lookAt(r.x + h[y], r.y, r.z)) : w === 1 ? (l.up.set(0, 0, c[y]), l.position.set(r.x, r.y, r.z), l.lookAt(r.x, r.y + h[y], r.z)) : (l.up.set(0, c[y], 0), l.position.set(r.x, r.y, r.z), l.lookAt(r.x, r.y, r.z + h[y]));
            const M = this._cubeSize;
            Zo(s, w * M, y > 2 ? M : 0, M, M), u.setRenderTarget(s), m && u.render(_, l), u.render(t, l);
          }
          _.geometry.dispose(), _.material.dispose(), u.toneMapping = f, u.autoClear = d, t.background = p;
        }
        _textureToCubeUV(t, e) {
          const i = this._renderer, s = t.mapping === Js || t.mapping === tr;
          s ? (this._cubemapMaterial === null && (this._cubemapMaterial = Nd()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Fd());
          const r = s ? this._cubemapMaterial : this._equirectMaterial, o = new Dn(this._lodPlanes[0], r), a = r.uniforms;
          a.envMap.value = t;
          const l = this._cubeSize;
          Zo(e, 0, 0, 3 * l, 2 * l), i.setRenderTarget(e), i.render(o, Kl);
        }
        _applyPMREM(t) {
          const e = this._renderer, i = e.autoClear;
          e.autoClear = false;
          const s = this._lodPlanes.length;
          for (let r = 1; r < s; r++) {
            const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = Id[(s - r - 1) % Id.length];
            this._blur(t, r - 1, r, o, a);
          }
          e.autoClear = i;
        }
        _blur(t, e, i, s, r) {
          const o = this._pingPongRenderTarget;
          this._halfBlur(t, o, e, i, s, "latitudinal", r), this._halfBlur(o, t, i, i, s, "longitudinal", r);
        }
        _halfBlur(t, e, i, s, r, o, a) {
          const l = this._renderer, c = this._blurMaterial;
          o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
          const h = 3, u = new Dn(this._lodPlanes[s], c), d = c.uniforms, f = this._sizeLods[i] - 1, g = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * es - 1), _ = r / g, m = isFinite(r) ? 1 + Math.floor(h * _) : es;
          m > es && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${es}`);
          const p = [];
          let y = 0;
          for (let T = 0; T < es; ++T) {
            const v = T / _, x = Math.exp(-v * v / 2);
            p.push(x), T === 0 ? y += x : T < m && (y += 2 * x);
          }
          for (let T = 0; T < p.length; T++) p[T] = p[T] / y;
          d.envMap.value = t.texture, d.samples.value = m, d.weights.value = p, d.latitudinal.value = o === "latitudinal", a && (d.poleAxis.value = a);
          const { _lodMax: w } = this;
          d.dTheta.value = g, d.mipInt.value = w - i;
          const M = this._sizeLods[s], C = 3 * M * (s > w - Gs ? s - w + Gs : 0), R = 4 * (this._cubeSize - M);
          Zo(e, C, R, 3 * M, 2 * M), l.setRenderTarget(e), l.render(u, Kl);
        }
      }
      function dM(n) {
        const t = [], e = [], i = [];
        let s = n;
        const r = n - Gs + 1 + Dd.length;
        for (let o = 0; o < r; o++) {
          const a = Math.pow(2, s);
          e.push(a);
          let l = 1 / a;
          o > n - Gs ? l = Dd[o - n + Gs - 1] : o === 0 && (l = 0), i.push(l);
          const c = 1 / (a - 2), h = -c, u = 1 + c, d = [
            h,
            h,
            u,
            h,
            u,
            u,
            h,
            h,
            u,
            u,
            h,
            u
          ], f = 6, g = 6, _ = 3, m = 2, p = 1, y = new Float32Array(_ * g * f), w = new Float32Array(m * g * f), M = new Float32Array(p * g * f);
          for (let R = 0; R < f; R++) {
            const T = R % 3 * 2 / 3 - 1, v = R > 2 ? 0 : -1, x = [
              T,
              v,
              0,
              T + 2 / 3,
              v,
              0,
              T + 2 / 3,
              v + 1,
              0,
              T,
              v,
              0,
              T + 2 / 3,
              v + 1,
              0,
              T,
              v + 1,
              0
            ];
            y.set(x, _ * g * R), w.set(d, m * g * R);
            const b = [
              R,
              R,
              R,
              R,
              R,
              R
            ];
            M.set(b, p * g * R);
          }
          const C = new xn();
          C.setAttribute("position", new In(y, _)), C.setAttribute("uv", new In(w, m)), C.setAttribute("faceIndex", new In(M, p)), t.push(C), s > Gs && s--;
        }
        return {
          lodPlanes: t,
          sizeLods: e,
          sigmas: i
        };
      }
      function kd(n, t, e) {
        const i = new as(n, t, e);
        return i.texture.mapping = tl, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
      }
      function Zo(n, t, e, i, s) {
        n.viewport.set(t, e, i, s), n.scissor.set(t, e, i, s);
      }
      function fM(n, t, e) {
        const i = new Float32Array(es), s = new O(0, 1, 0);
        return new Li({
          name: "SphericalGaussianBlur",
          defines: {
            n: es,
            CUBEUV_TEXEL_WIDTH: 1 / t,
            CUBEUV_TEXEL_HEIGHT: 1 / e,
            CUBEUV_MAX_MIP: `${n}.0`
          },
          uniforms: {
            envMap: {
              value: null
            },
            samples: {
              value: 1
            },
            weights: {
              value: i
            },
            latitudinal: {
              value: false
            },
            dTheta: {
              value: 0
            },
            mipInt: {
              value: 0
            },
            poleAxis: {
              value: s
            }
          },
          vertexShader: Kh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: wi,
          depthTest: false,
          depthWrite: false
        });
      }
      function Fd() {
        return new Li({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null
            }
          },
          vertexShader: Kh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: wi,
          depthTest: false,
          depthWrite: false
        });
      }
      function Nd() {
        return new Li({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            }
          },
          vertexShader: Kh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: wi,
          depthTest: false,
          depthWrite: false
        });
      }
      function Kh() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function pM(n) {
        let t = /* @__PURE__ */ new WeakMap(), e = null;
        function i(a) {
          if (a && a.isTexture) {
            const l = a.mapping, c = l === Lc || l === Ic, h = l === Js || l === tr;
            if (c || h) {
              let u = t.get(a);
              const d = u !== void 0 ? u.texture.pmremVersion : 0;
              if (a.isRenderTargetTexture && a.pmremVersion !== d) return e === null && (e = new Od(n)), u = c ? e.fromEquirectangular(a, u) : e.fromCubemap(a, u), u.texture.pmremVersion = a.pmremVersion, t.set(a, u), u.texture;
              if (u !== void 0) return u.texture;
              {
                const f = a.image;
                return c && f && f.height > 0 || h && f && s(f) ? (e === null && (e = new Od(n)), u = c ? e.fromEquirectangular(a) : e.fromCubemap(a), u.texture.pmremVersion = a.pmremVersion, t.set(a, u), a.addEventListener("dispose", r), u.texture) : null;
              }
            }
          }
          return a;
        }
        function s(a) {
          let l = 0;
          const c = 6;
          for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
          return l === c;
        }
        function r(a) {
          const l = a.target;
          l.removeEventListener("dispose", r);
          const c = t.get(l);
          c !== void 0 && (t.delete(l), c.dispose());
        }
        function o() {
          t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
        }
        return {
          get: i,
          dispose: o
        };
      }
      function mM(n) {
        const t = {};
        function e(i) {
          if (t[i] !== void 0) return t[i];
          let s;
          switch (i) {
            case "WEBGL_depth_texture":
              s = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              s = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              s = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              s = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              s = n.getExtension(i);
          }
          return t[i] = s, s;
        }
        return {
          has: function(i) {
            return e(i) !== null;
          },
          init: function() {
            e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
          },
          get: function(i) {
            const s = e(i);
            return s === null && wa("THREE.WebGLRenderer: " + i + " extension not supported."), s;
          }
        };
      }
      function gM(n, t, e, i) {
        const s = {}, r = /* @__PURE__ */ new WeakMap();
        function o(u) {
          const d = u.target;
          d.index !== null && t.remove(d.index);
          for (const g in d.attributes) t.remove(d.attributes[g]);
          d.removeEventListener("dispose", o), delete s[d.id];
          const f = r.get(d);
          f && (t.remove(f), r.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === true && delete d._maxInstanceCount, e.memory.geometries--;
        }
        function a(u, d) {
          return s[d.id] === true || (d.addEventListener("dispose", o), s[d.id] = true, e.memory.geometries++), d;
        }
        function l(u) {
          const d = u.attributes;
          for (const f in d) t.update(d[f], n.ARRAY_BUFFER);
        }
        function c(u) {
          const d = [], f = u.index, g = u.attributes.position;
          let _ = 0;
          if (f !== null) {
            const y = f.array;
            _ = f.version;
            for (let w = 0, M = y.length; w < M; w += 3) {
              const C = y[w + 0], R = y[w + 1], T = y[w + 2];
              d.push(C, R, R, T, T, C);
            }
          } else if (g !== void 0) {
            const y = g.array;
            _ = g.version;
            for (let w = 0, M = y.length / 3 - 1; w < M; w += 3) {
              const C = w + 0, R = w + 1, T = w + 2;
              d.push(C, R, R, T, T, C);
            }
          } else return;
          const m = new (Dm(d) ? Fm : km)(d, 1);
          m.version = _;
          const p = r.get(u);
          p && t.remove(p), r.set(u, m);
        }
        function h(u) {
          const d = r.get(u);
          if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u);
          } else c(u);
          return r.get(u);
        }
        return {
          get: a,
          update: l,
          getWireframeAttribute: h
        };
      }
      function _M(n, t, e) {
        let i;
        function s(d) {
          i = d;
        }
        let r, o;
        function a(d) {
          r = d.type, o = d.bytesPerElement;
        }
        function l(d, f) {
          n.drawElements(i, f, r, d * o), e.update(f, i, 1);
        }
        function c(d, f, g) {
          g !== 0 && (n.drawElementsInstanced(i, f, r, d * o, g), e.update(f, i, g));
        }
        function h(d, f, g) {
          if (g === 0) return;
          t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, r, d, 0, g);
          let m = 0;
          for (let p = 0; p < g; p++) m += f[p];
          e.update(m, i, 1);
        }
        function u(d, f, g, _) {
          if (g === 0) return;
          const m = t.get("WEBGL_multi_draw");
          if (m === null) for (let p = 0; p < d.length; p++) c(d[p] / o, f[p], _[p]);
          else {
            m.multiDrawElementsInstancedWEBGL(i, f, 0, r, d, 0, _, 0, g);
            let p = 0;
            for (let y = 0; y < g; y++) p += f[y] * _[y];
            e.update(p, i, 1);
          }
        }
        this.setMode = s, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = u;
      }
      function xM(n) {
        const t = {
          geometries: 0,
          textures: 0
        }, e = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function i(r, o, a) {
          switch (e.calls++, o) {
            case n.TRIANGLES:
              e.triangles += a * (r / 3);
              break;
            case n.LINES:
              e.lines += a * (r / 2);
              break;
            case n.LINE_STRIP:
              e.lines += a * (r - 1);
              break;
            case n.LINE_LOOP:
              e.lines += a * r;
              break;
            case n.POINTS:
              e.points += a * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", o);
              break;
          }
        }
        function s() {
          e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
        }
        return {
          memory: t,
          render: e,
          programs: null,
          autoReset: true,
          reset: s,
          update: i
        };
      }
      function bM(n, t, e) {
        const i = /* @__PURE__ */ new WeakMap(), s = new pe();
        function r(o, a, l) {
          const c = o.morphTargetInfluences, h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, u = h !== void 0 ? h.length : 0;
          let d = i.get(a);
          if (d === void 0 || d.count !== u) {
            let x = function() {
              T.dispose(), i.delete(a), a.removeEventListener("dispose", x);
            };
            d !== void 0 && d.texture.dispose();
            const f = a.morphAttributes.position !== void 0, g = a.morphAttributes.normal !== void 0, _ = a.morphAttributes.color !== void 0, m = a.morphAttributes.position || [], p = a.morphAttributes.normal || [], y = a.morphAttributes.color || [];
            let w = 0;
            f === true && (w = 1), g === true && (w = 2), _ === true && (w = 3);
            let M = a.attributes.position.count * w, C = 1;
            M > t.maxTextureSize && (C = Math.ceil(M / t.maxTextureSize), M = t.maxTextureSize);
            const R = new Float32Array(M * C * 4 * u), T = new Lm(R, M, C, u);
            T.type = si, T.needsUpdate = true;
            const v = w * 4;
            for (let b = 0; b < u; b++) {
              const A = m[b], L = p[b], I = y[b], H = M * C * 4 * b;
              for (let j = 0; j < A.count; j++) {
                const z = j * v;
                f === true && (s.fromBufferAttribute(A, j), R[H + z + 0] = s.x, R[H + z + 1] = s.y, R[H + z + 2] = s.z, R[H + z + 3] = 0), g === true && (s.fromBufferAttribute(L, j), R[H + z + 4] = s.x, R[H + z + 5] = s.y, R[H + z + 6] = s.z, R[H + z + 7] = 0), _ === true && (s.fromBufferAttribute(I, j), R[H + z + 8] = s.x, R[H + z + 9] = s.y, R[H + z + 10] = s.z, R[H + z + 11] = I.itemSize === 4 ? s.w : 1);
              }
            }
            d = {
              count: u,
              texture: T,
              size: new Ft(M, C)
            }, i.set(a, d), a.addEventListener("dispose", x);
          }
          if (o.isInstancedMesh === true && o.morphTexture !== null) l.getUniforms().setValue(n, "morphTexture", o.morphTexture, e);
          else {
            let f = 0;
            for (let _ = 0; _ < c.length; _++) f += c[_];
            const g = a.morphTargetsRelative ? 1 : 1 - f;
            l.getUniforms().setValue(n, "morphTargetBaseInfluence", g), l.getUniforms().setValue(n, "morphTargetInfluences", c);
          }
          l.getUniforms().setValue(n, "morphTargetsTexture", d.texture, e), l.getUniforms().setValue(n, "morphTargetsTextureSize", d.size);
        }
        return {
          update: r
        };
      }
      function yM(n, t, e, i) {
        let s = /* @__PURE__ */ new WeakMap();
        function r(l) {
          const c = i.render.frame, h = l.geometry, u = t.get(l, h);
          if (s.get(u) !== c && (t.update(u), s.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === false && l.addEventListener("dispose", a), s.get(l) !== c && (e.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && e.update(l.instanceColor, n.ARRAY_BUFFER), s.set(l, c))), l.isSkinnedMesh) {
            const d = l.skeleton;
            s.get(d) !== c && (d.update(), s.set(d, c));
          }
          return u;
        }
        function o() {
          s = /* @__PURE__ */ new WeakMap();
        }
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a), e.remove(c.instanceMatrix), c.instanceColor !== null && e.remove(c.instanceColor);
        }
        return {
          update: r,
          dispose: o
        };
      }
      const Gm = new tn(), Ud = new Hm(1, 1), Xm = new Lm(), Ym = new Bx(), jm = new Bm(), Bd = [], zd = [], Hd = new Float32Array(16), Vd = new Float32Array(9), Wd = new Float32Array(4);
      function cr(n, t, e) {
        const i = n[0];
        if (i <= 0 || i > 0) return n;
        const s = t * e;
        let r = Bd[s];
        if (r === void 0 && (r = new Float32Array(s), Bd[s] = r), t !== 0) {
          i.toArray(r, 0);
          for (let o = 1, a = 0; o !== t; ++o) a += e, n[o].toArray(r, a);
        }
        return r;
      }
      function Ue(n, t) {
        if (n.length !== t.length) return false;
        for (let e = 0, i = n.length; e < i; e++) if (n[e] !== t[e]) return false;
        return true;
      }
      function Be(n, t) {
        for (let e = 0, i = t.length; e < i; e++) n[e] = t[e];
      }
      function nl(n, t) {
        let e = zd[t];
        e === void 0 && (e = new Int32Array(t), zd[t] = e);
        for (let i = 0; i !== t; ++i) e[i] = n.allocateTextureUnit();
        return e;
      }
      function vM(n, t) {
        const e = this.cache;
        e[0] !== t && (n.uniform1f(this.addr, t), e[0] = t);
      }
      function MM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (n.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
          if (Ue(e, t)) return;
          n.uniform2fv(this.addr, t), Be(e, t);
        }
      }
      function SM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (n.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
        else {
          if (Ue(e, t)) return;
          n.uniform3fv(this.addr, t), Be(e, t);
        }
      }
      function wM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
          if (Ue(e, t)) return;
          n.uniform4fv(this.addr, t), Be(e, t);
        }
      }
      function EM(n, t) {
        const e = this.cache, i = t.elements;
        if (i === void 0) {
          if (Ue(e, t)) return;
          n.uniformMatrix2fv(this.addr, false, t), Be(e, t);
        } else {
          if (Ue(e, i)) return;
          Wd.set(i), n.uniformMatrix2fv(this.addr, false, Wd), Be(e, i);
        }
      }
      function TM(n, t) {
        const e = this.cache, i = t.elements;
        if (i === void 0) {
          if (Ue(e, t)) return;
          n.uniformMatrix3fv(this.addr, false, t), Be(e, t);
        } else {
          if (Ue(e, i)) return;
          Vd.set(i), n.uniformMatrix3fv(this.addr, false, Vd), Be(e, i);
        }
      }
      function AM(n, t) {
        const e = this.cache, i = t.elements;
        if (i === void 0) {
          if (Ue(e, t)) return;
          n.uniformMatrix4fv(this.addr, false, t), Be(e, t);
        } else {
          if (Ue(e, i)) return;
          Hd.set(i), n.uniformMatrix4fv(this.addr, false, Hd), Be(e, i);
        }
      }
      function CM(n, t) {
        const e = this.cache;
        e[0] !== t && (n.uniform1i(this.addr, t), e[0] = t);
      }
      function RM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (n.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
          if (Ue(e, t)) return;
          n.uniform2iv(this.addr, t), Be(e, t);
        }
      }
      function PM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else {
          if (Ue(e, t)) return;
          n.uniform3iv(this.addr, t), Be(e, t);
        }
      }
      function DM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
          if (Ue(e, t)) return;
          n.uniform4iv(this.addr, t), Be(e, t);
        }
      }
      function LM(n, t) {
        const e = this.cache;
        e[0] !== t && (n.uniform1ui(this.addr, t), e[0] = t);
      }
      function IM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (n.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
        else {
          if (Ue(e, t)) return;
          n.uniform2uiv(this.addr, t), Be(e, t);
        }
      }
      function OM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
        else {
          if (Ue(e, t)) return;
          n.uniform3uiv(this.addr, t), Be(e, t);
        }
      }
      function kM(n, t) {
        const e = this.cache;
        if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
        else {
          if (Ue(e, t)) return;
          n.uniform4uiv(this.addr, t), Be(e, t);
        }
      }
      function FM(n, t, e) {
        const i = this.cache, s = e.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s);
        let r;
        this.type === n.SAMPLER_2D_SHADOW ? (Ud.compareFunction = Pm, r = Ud) : r = Gm, e.setTexture2D(t || r, s);
      }
      function NM(n, t, e) {
        const i = this.cache, s = e.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), e.setTexture3D(t || Ym, s);
      }
      function UM(n, t, e) {
        const i = this.cache, s = e.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), e.setTextureCube(t || jm, s);
      }
      function BM(n, t, e) {
        const i = this.cache, s = e.allocateTextureUnit();
        i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), e.setTexture2DArray(t || Xm, s);
      }
      function zM(n) {
        switch (n) {
          case 5126:
            return vM;
          case 35664:
            return MM;
          case 35665:
            return SM;
          case 35666:
            return wM;
          case 35674:
            return EM;
          case 35675:
            return TM;
          case 35676:
            return AM;
          case 5124:
          case 35670:
            return CM;
          case 35667:
          case 35671:
            return RM;
          case 35668:
          case 35672:
            return PM;
          case 35669:
          case 35673:
            return DM;
          case 5125:
            return LM;
          case 36294:
            return IM;
          case 36295:
            return OM;
          case 36296:
            return kM;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return FM;
          case 35679:
          case 36299:
          case 36307:
            return NM;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return UM;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return BM;
        }
      }
      function HM(n, t) {
        n.uniform1fv(this.addr, t);
      }
      function VM(n, t) {
        const e = cr(t, this.size, 2);
        n.uniform2fv(this.addr, e);
      }
      function WM(n, t) {
        const e = cr(t, this.size, 3);
        n.uniform3fv(this.addr, e);
      }
      function GM(n, t) {
        const e = cr(t, this.size, 4);
        n.uniform4fv(this.addr, e);
      }
      function XM(n, t) {
        const e = cr(t, this.size, 4);
        n.uniformMatrix2fv(this.addr, false, e);
      }
      function YM(n, t) {
        const e = cr(t, this.size, 9);
        n.uniformMatrix3fv(this.addr, false, e);
      }
      function jM(n, t) {
        const e = cr(t, this.size, 16);
        n.uniformMatrix4fv(this.addr, false, e);
      }
      function qM(n, t) {
        n.uniform1iv(this.addr, t);
      }
      function $M(n, t) {
        n.uniform2iv(this.addr, t);
      }
      function KM(n, t) {
        n.uniform3iv(this.addr, t);
      }
      function ZM(n, t) {
        n.uniform4iv(this.addr, t);
      }
      function QM(n, t) {
        n.uniform1uiv(this.addr, t);
      }
      function JM(n, t) {
        n.uniform2uiv(this.addr, t);
      }
      function tS(n, t) {
        n.uniform3uiv(this.addr, t);
      }
      function eS(n, t) {
        n.uniform4uiv(this.addr, t);
      }
      function nS(n, t, e) {
        const i = this.cache, s = t.length, r = nl(e, s);
        Ue(i, r) || (n.uniform1iv(this.addr, r), Be(i, r));
        for (let o = 0; o !== s; ++o) e.setTexture2D(t[o] || Gm, r[o]);
      }
      function iS(n, t, e) {
        const i = this.cache, s = t.length, r = nl(e, s);
        Ue(i, r) || (n.uniform1iv(this.addr, r), Be(i, r));
        for (let o = 0; o !== s; ++o) e.setTexture3D(t[o] || Ym, r[o]);
      }
      function sS(n, t, e) {
        const i = this.cache, s = t.length, r = nl(e, s);
        Ue(i, r) || (n.uniform1iv(this.addr, r), Be(i, r));
        for (let o = 0; o !== s; ++o) e.setTextureCube(t[o] || jm, r[o]);
      }
      function rS(n, t, e) {
        const i = this.cache, s = t.length, r = nl(e, s);
        Ue(i, r) || (n.uniform1iv(this.addr, r), Be(i, r));
        for (let o = 0; o !== s; ++o) e.setTexture2DArray(t[o] || Xm, r[o]);
      }
      function oS(n) {
        switch (n) {
          case 5126:
            return HM;
          case 35664:
            return VM;
          case 35665:
            return WM;
          case 35666:
            return GM;
          case 35674:
            return XM;
          case 35675:
            return YM;
          case 35676:
            return jM;
          case 5124:
          case 35670:
            return qM;
          case 35667:
          case 35671:
            return $M;
          case 35668:
          case 35672:
            return KM;
          case 35669:
          case 35673:
            return ZM;
          case 5125:
            return QM;
          case 36294:
            return JM;
          case 36295:
            return tS;
          case 36296:
            return eS;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return nS;
          case 35679:
          case 36299:
          case 36307:
            return iS;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return sS;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return rS;
        }
      }
      class aS {
        constructor(t, e, i) {
          this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.setValue = zM(e.type);
        }
      }
      class lS {
        constructor(t, e, i) {
          this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = oS(e.type);
        }
      }
      class cS {
        constructor(t) {
          this.id = t, this.seq = [], this.map = {};
        }
        setValue(t, e, i) {
          const s = this.seq;
          for (let r = 0, o = s.length; r !== o; ++r) {
            const a = s[r];
            a.setValue(t, e[a.id], i);
          }
        }
      }
      const ec = /(\w+)(\])?(\[|\.)?/g;
      function Gd(n, t) {
        n.seq.push(t), n.map[t.id] = t;
      }
      function hS(n, t, e) {
        const i = n.name, s = i.length;
        for (ec.lastIndex = 0; ; ) {
          const r = ec.exec(i), o = ec.lastIndex;
          let a = r[1];
          const l = r[2] === "]", c = r[3];
          if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === s) {
            Gd(e, c === void 0 ? new aS(a, n, t) : new lS(a, n, t));
            break;
          } else {
            let u = e.map[a];
            u === void 0 && (u = new cS(a), Gd(e, u)), e = u;
          }
        }
      }
      class Ea {
        constructor(t, e) {
          this.seq = [], this.map = {};
          const i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
          for (let s = 0; s < i; ++s) {
            const r = t.getActiveUniform(e, s), o = t.getUniformLocation(e, r.name);
            hS(r, o, this);
          }
        }
        setValue(t, e, i, s) {
          const r = this.map[e];
          r !== void 0 && r.setValue(t, i, s);
        }
        setOptional(t, e, i) {
          const s = e[i];
          s !== void 0 && this.setValue(t, i, s);
        }
        static upload(t, e, i, s) {
          for (let r = 0, o = e.length; r !== o; ++r) {
            const a = e[r], l = i[a.id];
            l.needsUpdate !== false && a.setValue(t, l.value, s);
          }
        }
        static seqWithValue(t, e) {
          const i = [];
          for (let s = 0, r = t.length; s !== r; ++s) {
            const o = t[s];
            o.id in e && i.push(o);
          }
          return i;
        }
      }
      function Xd(n, t, e) {
        const i = n.createShader(t);
        return n.shaderSource(i, e), n.compileShader(i), i;
      }
      const uS = 37297;
      let dS = 0;
      function fS(n, t) {
        const e = n.split(`
`), i = [], s = Math.max(t - 6, 0), r = Math.min(t + 6, e.length);
        for (let o = s; o < r; o++) {
          const a = o + 1;
          i.push(`${a === t ? ">" : " "} ${a}: ${e[o]}`);
        }
        return i.join(`
`);
      }
      const Yd = new Xt();
      function pS(n) {
        ee._getMatrix(Yd, ee.workingColorSpace, n);
        const t = `mat3( ${Yd.elements.map((e) => e.toFixed(4))} )`;
        switch (ee.getTransfer(n)) {
          case La:
            return [
              t,
              "LinearTransferOETF"
            ];
          case ue:
            return [
              t,
              "sRGBTransferOETF"
            ];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", n), [
              t,
              "LinearTransferOETF"
            ];
        }
      }
      function jd(n, t, e) {
        const i = n.getShaderParameter(t, n.COMPILE_STATUS), s = n.getShaderInfoLog(t).trim();
        if (i && s === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(s);
        if (r) {
          const o = parseInt(r[1]);
          return e.toUpperCase() + `

` + s + `

` + fS(n.getShaderSource(t), o);
        } else return s;
      }
      function mS(n, t) {
        const e = pS(t);
        return [
          `vec4 ${n}( vec4 value ) {`,
          `	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,
          "}"
        ].join(`
`);
      }
      function gS(n, t) {
        let e;
        switch (t) {
          case hx:
            e = "Linear";
            break;
          case ux:
            e = "Reinhard";
            break;
          case dx:
            e = "Cineon";
            break;
          case fx:
            e = "ACESFilmic";
            break;
          case mx:
            e = "AgX";
            break;
          case gx:
            e = "Neutral";
            break;
          case px:
            e = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
        }
        return "vec3 " + n + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
      }
      const Qo = new O();
      function _S() {
        ee.getLuminanceCoefficients(Qo);
        const n = Qo.x.toFixed(4), t = Qo.y.toFixed(4), e = Qo.z.toFixed(4);
        return [
          "float luminance( const in vec3 rgb ) {",
          `	const vec3 weights = vec3( ${n}, ${t}, ${e} );`,
          "	return dot( weights, rgb );",
          "}"
        ].join(`
`);
      }
      function xS(n) {
        return [
          n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
          n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(kr).join(`
`);
      }
      function bS(n) {
        const t = [];
        for (const e in n) {
          const i = n[e];
          i !== false && t.push("#define " + e + " " + i);
        }
        return t.join(`
`);
      }
      function yS(n, t) {
        const e = {}, i = n.getProgramParameter(t, n.ACTIVE_ATTRIBUTES);
        for (let s = 0; s < i; s++) {
          const r = n.getActiveAttrib(t, s), o = r.name;
          let a = 1;
          r.type === n.FLOAT_MAT2 && (a = 2), r.type === n.FLOAT_MAT3 && (a = 3), r.type === n.FLOAT_MAT4 && (a = 4), e[o] = {
            type: r.type,
            location: n.getAttribLocation(t, o),
            locationSize: a
          };
        }
        return e;
      }
      function kr(n) {
        return n !== "";
      }
      function qd(n, t) {
        const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
        return n.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function $d(n, t) {
        return n.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
      }
      const vS = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function uh(n) {
        return n.replace(vS, SS);
      }
      const MS = /* @__PURE__ */ new Map();
      function SS(n, t) {
        let e = jt[t];
        if (e === void 0) {
          const i = MS.get(t);
          if (i !== void 0) e = jt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, i);
          else throw new Error("Can not resolve #include <" + t + ">");
        }
        return uh(e);
      }
      const wS = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Kd(n) {
        return n.replace(wS, ES);
      }
      function ES(n, t, e, i) {
        let s = "";
        for (let r = parseInt(t); r < parseInt(e); r++) s += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
        return s;
      }
      function Zd(n) {
        let t = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
        return n.precision === "highp" ? t += `
#define HIGH_PRECISION` : n.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
      }
      function TS(n) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return n.shadowMapType === bm ? t = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === W0 ? t = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Jn && (t = "SHADOWMAP_TYPE_VSM"), t;
      }
      function AS(n) {
        let t = "ENVMAP_TYPE_CUBE";
        if (n.envMap) switch (n.envMapMode) {
          case Js:
          case tr:
            t = "ENVMAP_TYPE_CUBE";
            break;
          case tl:
            t = "ENVMAP_TYPE_CUBE_UV";
            break;
        }
        return t;
      }
      function CS(n) {
        let t = "ENVMAP_MODE_REFLECTION";
        if (n.envMap) switch (n.envMapMode) {
          case tr:
            t = "ENVMAP_MODE_REFRACTION";
            break;
        }
        return t;
      }
      function RS(n) {
        let t = "ENVMAP_BLENDING_NONE";
        if (n.envMap) switch (n.combine) {
          case Bh:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case lx:
            t = "ENVMAP_BLENDING_MIX";
            break;
          case cx:
            t = "ENVMAP_BLENDING_ADD";
            break;
        }
        return t;
      }
      function PS(n) {
        const t = n.envMapCubeUVHeight;
        if (t === null) return null;
        const e = Math.log2(t) - 2, i = 1 / t;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
          texelHeight: i,
          maxMip: e
        };
      }
      function DS(n, t, e, i) {
        const s = n.getContext(), r = e.defines;
        let o = e.vertexShader, a = e.fragmentShader;
        const l = TS(e), c = AS(e), h = CS(e), u = RS(e), d = PS(e), f = xS(e), g = bS(r), _ = s.createProgram();
        let m, p, y = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
        e.isRawShaderMaterial ? (m = [
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          g
        ].filter(kr).join(`
`), m.length > 0 && (m += `
`), p = [
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          g
        ].filter(kr).join(`
`), p.length > 0 && (p += `
`)) : (m = [
          Zd(e),
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          g,
          e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          e.batching ? "#define USE_BATCHING" : "",
          e.batchingColor ? "#define USE_BATCHING_COLOR" : "",
          e.instancing ? "#define USE_INSTANCING" : "",
          e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
          e.useFog && e.fog ? "#define USE_FOG" : "",
          e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
          e.map ? "#define USE_MAP" : "",
          e.envMap ? "#define USE_ENVMAP" : "",
          e.envMap ? "#define " + h : "",
          e.lightMap ? "#define USE_LIGHTMAP" : "",
          e.aoMap ? "#define USE_AOMAP" : "",
          e.bumpMap ? "#define USE_BUMPMAP" : "",
          e.normalMap ? "#define USE_NORMALMAP" : "",
          e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          e.anisotropy ? "#define USE_ANISOTROPY" : "",
          e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          e.specularMap ? "#define USE_SPECULARMAP" : "",
          e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          e.metalnessMap ? "#define USE_METALNESSMAP" : "",
          e.alphaMap ? "#define USE_ALPHAMAP" : "",
          e.alphaHash ? "#define USE_ALPHAHASH" : "",
          e.transmission ? "#define USE_TRANSMISSION" : "",
          e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          e.mapUv ? "#define MAP_UV " + e.mapUv : "",
          e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
          e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
          e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
          e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
          e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
          e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
          e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
          e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
          e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
          e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
          e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
          e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
          e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
          e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
          e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
          e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
          e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
          e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
          e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
          e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
          e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
          e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
          e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "",
          e.vertexColors ? "#define USE_COLOR" : "",
          e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          e.vertexUv1s ? "#define USE_UV1" : "",
          e.vertexUv2s ? "#define USE_UV2" : "",
          e.vertexUv3s ? "#define USE_UV3" : "",
          e.pointsUvs ? "#define USE_POINTS_UV" : "",
          e.flatShading ? "#define FLAT_SHADED" : "",
          e.skinning ? "#define USE_SKINNING" : "",
          e.morphTargets ? "#define USE_MORPHTARGETS" : "",
          e.morphNormals && e.flatShading === false ? "#define USE_MORPHNORMALS" : "",
          e.morphColors ? "#define USE_MORPHCOLORS" : "",
          e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
          e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
          e.doubleSided ? "#define DOUBLE_SIDED" : "",
          e.flipSided ? "#define FLIP_SIDED" : "",
          e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          e.shadowMapEnabled ? "#define " + l : "",
          e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "	attribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "	attribute vec3 instanceColor;",
          "#endif",
          "#ifdef USE_INSTANCING_MORPH",
          "	uniform sampler2D morphTexture;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "	attribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "	attribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "	attribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "	attribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "	attribute vec3 color;",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          `
`
        ].filter(kr).join(`
`), p = [
          Zd(e),
          "#define SHADER_TYPE " + e.shaderType,
          "#define SHADER_NAME " + e.shaderName,
          g,
          e.useFog && e.fog ? "#define USE_FOG" : "",
          e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
          e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
          e.map ? "#define USE_MAP" : "",
          e.matcap ? "#define USE_MATCAP" : "",
          e.envMap ? "#define USE_ENVMAP" : "",
          e.envMap ? "#define " + c : "",
          e.envMap ? "#define " + h : "",
          e.envMap ? "#define " + u : "",
          d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
          d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
          d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
          e.lightMap ? "#define USE_LIGHTMAP" : "",
          e.aoMap ? "#define USE_AOMAP" : "",
          e.bumpMap ? "#define USE_BUMPMAP" : "",
          e.normalMap ? "#define USE_NORMALMAP" : "",
          e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          e.anisotropy ? "#define USE_ANISOTROPY" : "",
          e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          e.clearcoat ? "#define USE_CLEARCOAT" : "",
          e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          e.dispersion ? "#define USE_DISPERSION" : "",
          e.iridescence ? "#define USE_IRIDESCENCE" : "",
          e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          e.specularMap ? "#define USE_SPECULARMAP" : "",
          e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          e.metalnessMap ? "#define USE_METALNESSMAP" : "",
          e.alphaMap ? "#define USE_ALPHAMAP" : "",
          e.alphaTest ? "#define USE_ALPHATEST" : "",
          e.alphaHash ? "#define USE_ALPHAHASH" : "",
          e.sheen ? "#define USE_SHEEN" : "",
          e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          e.transmission ? "#define USE_TRANSMISSION" : "",
          e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "",
          e.vertexColors || e.instancingColor || e.batchingColor ? "#define USE_COLOR" : "",
          e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          e.vertexUv1s ? "#define USE_UV1" : "",
          e.vertexUv2s ? "#define USE_UV2" : "",
          e.vertexUv3s ? "#define USE_UV3" : "",
          e.pointsUvs ? "#define USE_POINTS_UV" : "",
          e.gradientMap ? "#define USE_GRADIENTMAP" : "",
          e.flatShading ? "#define FLAT_SHADED" : "",
          e.doubleSided ? "#define DOUBLE_SIDED" : "",
          e.flipSided ? "#define FLIP_SIDED" : "",
          e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          e.shadowMapEnabled ? "#define " + l : "",
          e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          e.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
          e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          e.toneMapping !== Ei ? "#define TONE_MAPPING" : "",
          e.toneMapping !== Ei ? jt.tonemapping_pars_fragment : "",
          e.toneMapping !== Ei ? gS("toneMapping", e.toneMapping) : "",
          e.dithering ? "#define DITHERING" : "",
          e.opaque ? "#define OPAQUE" : "",
          jt.colorspace_pars_fragment,
          mS("linearToOutputTexel", e.outputColorSpace),
          _S(),
          e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
          `
`
        ].filter(kr).join(`
`)), o = uh(o), o = qd(o, e), o = $d(o, e), a = uh(a), a = qd(a, e), a = $d(a, e), o = Kd(o), a = Kd(a), e.isRawShaderMaterial !== true && (y = `#version 300 es
`, m = [
          f,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join(`
`) + `
` + m, p = [
          "#define varying in",
          e.glslVersion === td ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
          e.glslVersion === td ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + p);
        const w = y + m + o, M = y + p + a, C = Xd(s, s.VERTEX_SHADER, w), R = Xd(s, s.FRAGMENT_SHADER, M);
        s.attachShader(_, C), s.attachShader(_, R), e.index0AttributeName !== void 0 ? s.bindAttribLocation(_, 0, e.index0AttributeName) : e.morphTargets === true && s.bindAttribLocation(_, 0, "position"), s.linkProgram(_);
        function T(A) {
          if (n.debug.checkShaderErrors) {
            const L = s.getProgramInfoLog(_).trim(), I = s.getShaderInfoLog(C).trim(), H = s.getShaderInfoLog(R).trim();
            let j = true, z = true;
            if (s.getProgramParameter(_, s.LINK_STATUS) === false) if (j = false, typeof n.debug.onShaderError == "function") n.debug.onShaderError(s, _, C, R);
            else {
              const V = jd(s, C, "vertex"), U = jd(s, R, "fragment");
              console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(_, s.VALIDATE_STATUS) + `

Material Name: ` + A.name + `
Material Type: ` + A.type + `

Program Info Log: ` + L + `
` + V + `
` + U);
            }
            else L !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", L) : (I === "" || H === "") && (z = false);
            z && (A.diagnostics = {
              runnable: j,
              programLog: L,
              vertexShader: {
                log: I,
                prefix: m
              },
              fragmentShader: {
                log: H,
                prefix: p
              }
            });
          }
          s.deleteShader(C), s.deleteShader(R), v = new Ea(s, _), x = yS(s, _);
        }
        let v;
        this.getUniforms = function() {
          return v === void 0 && T(this), v;
        };
        let x;
        this.getAttributes = function() {
          return x === void 0 && T(this), x;
        };
        let b = e.rendererExtensionParallelShaderCompile === false;
        return this.isReady = function() {
          return b === false && (b = s.getProgramParameter(_, uS)), b;
        }, this.destroy = function() {
          i.releaseStatesOfProgram(this), s.deleteProgram(_), this.program = void 0;
        }, this.type = e.shaderType, this.name = e.shaderName, this.id = dS++, this.cacheKey = t, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = R, this;
      }
      let LS = 0;
      class IS {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
        }
        update(t) {
          const e = t.vertexShader, i = t.fragmentShader, s = this._getShaderStage(e), r = this._getShaderStage(i), o = this._getShaderCacheForMaterial(t);
          return o.has(s) === false && (o.add(s), s.usedTimes++), o.has(r) === false && (o.add(r), r.usedTimes++), this;
        }
        remove(t) {
          const e = this.materialCache.get(t);
          for (const i of e) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
          return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
          return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
          return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
          const e = this.materialCache;
          let i = e.get(t);
          return i === void 0 && (i = /* @__PURE__ */ new Set(), e.set(t, i)), i;
        }
        _getShaderStage(t) {
          const e = this.shaderCache;
          let i = e.get(t);
          return i === void 0 && (i = new OS(t), e.set(t, i)), i;
        }
      }
      class OS {
        constructor(t) {
          this.id = LS++, this.code = t, this.usedTimes = 0;
        }
      }
      function kS(n, t, e, i, s, r, o) {
        const a = new Im(), l = new IS(), c = /* @__PURE__ */ new Set(), h = [], u = s.logarithmicDepthBuffer, d = s.vertexTextures;
        let f = s.precision;
        const g = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        function _(x) {
          return c.add(x), x === 0 ? "uv" : `uv${x}`;
        }
        function m(x, b, A, L, I) {
          const H = L.fog, j = I.geometry, z = x.isMeshStandardMaterial ? L.environment : null, V = (x.isMeshStandardMaterial ? e : t).get(x.envMap || z), U = V && V.mapping === tl ? V.image.height : null, q = g[x.type];
          x.precision !== null && (f = s.getMaxPrecision(x.precision), f !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", f, "instead."));
          const rt = j.morphAttributes.position || j.morphAttributes.normal || j.morphAttributes.color, et = rt !== void 0 ? rt.length : 0;
          let ut = 0;
          j.morphAttributes.position !== void 0 && (ut = 1), j.morphAttributes.normal !== void 0 && (ut = 2), j.morphAttributes.color !== void 0 && (ut = 3);
          let ot, W, J, ct;
          if (q) {
            const ae = Fn[q];
            ot = ae.vertexShader, W = ae.fragmentShader;
          } else ot = x.vertexShader, W = x.fragmentShader, l.update(x), J = l.getVertexShaderID(x), ct = l.getFragmentShaderID(x);
          const ht = n.getRenderTarget(), it = n.state.buffers.depth.getReversed(), St = I.isInstancedMesh === true, lt = I.isBatchedMesh === true, dt = !!x.map, wt = !!x.matcap, bt = !!V, D = !!x.aoMap, zt = !!x.lightMap, ft = !!x.bumpMap, Lt = !!x.normalMap, st = !!x.displacementMap, Rt = !!x.emissiveMap, Et = !!x.metalnessMap, P = !!x.roughnessMap, S = x.anisotropy > 0, B = x.clearcoat > 0, K = x.dispersion > 0, Q = x.iridescence > 0, X = x.sheen > 0, _t = x.transmission > 0, pt = S && !!x.anisotropyMap, Pt = B && !!x.clearcoatMap, kt = B && !!x.clearcoatNormalMap, nt = B && !!x.clearcoatRoughnessMap, gt = Q && !!x.iridescenceMap, Dt = Q && !!x.iridescenceThicknessMap, Nt = X && !!x.sheenColorMap, At = X && !!x.sheenRoughnessMap, Qt = !!x.specularMap, Yt = !!x.specularColorMap, _e = !!x.specularIntensityMap, k = _t && !!x.transmissionMap, yt = _t && !!x.thicknessMap, Z = !!x.gradientMap, tt = !!x.alphaMap, Mt = x.alphaTest > 0, vt = !!x.alphaHash, Gt = !!x.extensions;
          let we = Ei;
          x.toneMapped && (ht === null || ht.isXRRenderTarget === true) && (we = n.toneMapping);
          const Ge = {
            shaderID: q,
            shaderType: x.type,
            shaderName: x.name,
            vertexShader: ot,
            fragmentShader: W,
            defines: x.defines,
            customVertexShaderID: J,
            customFragmentShaderID: ct,
            isRawShaderMaterial: x.isRawShaderMaterial === true,
            glslVersion: x.glslVersion,
            precision: f,
            batching: lt,
            batchingColor: lt && I._colorsTexture !== null,
            instancing: St,
            instancingColor: St && I.instanceColor !== null,
            instancingMorph: St && I.morphTexture !== null,
            supportsVertexTextures: d,
            outputColorSpace: ht === null ? n.outputColorSpace : ht.isXRRenderTarget === true ? ht.texture.colorSpace : er,
            alphaToCoverage: !!x.alphaToCoverage,
            map: dt,
            matcap: wt,
            envMap: bt,
            envMapMode: bt && V.mapping,
            envMapCubeUVHeight: U,
            aoMap: D,
            lightMap: zt,
            bumpMap: ft,
            normalMap: Lt,
            displacementMap: d && st,
            emissiveMap: Rt,
            normalMapObjectSpace: Lt && x.normalMapType === yx,
            normalMapTangentSpace: Lt && x.normalMapType === Rm,
            metalnessMap: Et,
            roughnessMap: P,
            anisotropy: S,
            anisotropyMap: pt,
            clearcoat: B,
            clearcoatMap: Pt,
            clearcoatNormalMap: kt,
            clearcoatRoughnessMap: nt,
            dispersion: K,
            iridescence: Q,
            iridescenceMap: gt,
            iridescenceThicknessMap: Dt,
            sheen: X,
            sheenColorMap: Nt,
            sheenRoughnessMap: At,
            specularMap: Qt,
            specularColorMap: Yt,
            specularIntensityMap: _e,
            transmission: _t,
            transmissionMap: k,
            thicknessMap: yt,
            gradientMap: Z,
            opaque: x.transparent === false && x.blending === js && x.alphaToCoverage === false,
            alphaMap: tt,
            alphaTest: Mt,
            alphaHash: vt,
            combine: x.combine,
            mapUv: dt && _(x.map.channel),
            aoMapUv: D && _(x.aoMap.channel),
            lightMapUv: zt && _(x.lightMap.channel),
            bumpMapUv: ft && _(x.bumpMap.channel),
            normalMapUv: Lt && _(x.normalMap.channel),
            displacementMapUv: st && _(x.displacementMap.channel),
            emissiveMapUv: Rt && _(x.emissiveMap.channel),
            metalnessMapUv: Et && _(x.metalnessMap.channel),
            roughnessMapUv: P && _(x.roughnessMap.channel),
            anisotropyMapUv: pt && _(x.anisotropyMap.channel),
            clearcoatMapUv: Pt && _(x.clearcoatMap.channel),
            clearcoatNormalMapUv: kt && _(x.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: nt && _(x.clearcoatRoughnessMap.channel),
            iridescenceMapUv: gt && _(x.iridescenceMap.channel),
            iridescenceThicknessMapUv: Dt && _(x.iridescenceThicknessMap.channel),
            sheenColorMapUv: Nt && _(x.sheenColorMap.channel),
            sheenRoughnessMapUv: At && _(x.sheenRoughnessMap.channel),
            specularMapUv: Qt && _(x.specularMap.channel),
            specularColorMapUv: Yt && _(x.specularColorMap.channel),
            specularIntensityMapUv: _e && _(x.specularIntensityMap.channel),
            transmissionMapUv: k && _(x.transmissionMap.channel),
            thicknessMapUv: yt && _(x.thicknessMap.channel),
            alphaMapUv: tt && _(x.alphaMap.channel),
            vertexTangents: !!j.attributes.tangent && (Lt || S),
            vertexColors: x.vertexColors,
            vertexAlphas: x.vertexColors === true && !!j.attributes.color && j.attributes.color.itemSize === 4,
            pointsUvs: I.isPoints === true && !!j.attributes.uv && (dt || tt),
            fog: !!H,
            useFog: x.fog === true,
            fogExp2: !!H && H.isFogExp2,
            flatShading: x.flatShading === true,
            sizeAttenuation: x.sizeAttenuation === true,
            logarithmicDepthBuffer: u,
            reverseDepthBuffer: it,
            skinning: I.isSkinnedMesh === true,
            morphTargets: j.morphAttributes.position !== void 0,
            morphNormals: j.morphAttributes.normal !== void 0,
            morphColors: j.morphAttributes.color !== void 0,
            morphTargetsCount: et,
            morphTextureStride: ut,
            numDirLights: b.directional.length,
            numPointLights: b.point.length,
            numSpotLights: b.spot.length,
            numSpotLightMaps: b.spotLightMap.length,
            numRectAreaLights: b.rectArea.length,
            numHemiLights: b.hemi.length,
            numDirLightShadows: b.directionalShadowMap.length,
            numPointLightShadows: b.pointShadowMap.length,
            numSpotLightShadows: b.spotShadowMap.length,
            numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
            numLightProbes: b.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: x.dithering,
            shadowMapEnabled: n.shadowMap.enabled && A.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: we,
            decodeVideoTexture: dt && x.map.isVideoTexture === true && ee.getTransfer(x.map.colorSpace) === ue,
            decodeVideoTextureEmissive: Rt && x.emissiveMap.isVideoTexture === true && ee.getTransfer(x.emissiveMap.colorSpace) === ue,
            premultipliedAlpha: x.premultipliedAlpha,
            doubleSided: x.side === Nn,
            flipSided: x.side === an,
            useDepthPacking: x.depthPacking >= 0,
            depthPacking: x.depthPacking || 0,
            index0AttributeName: x.index0AttributeName,
            extensionClipCullDistance: Gt && x.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Gt && x.extensions.multiDraw === true || lt) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: x.customProgramCacheKey()
          };
          return Ge.vertexUv1s = c.has(1), Ge.vertexUv2s = c.has(2), Ge.vertexUv3s = c.has(3), c.clear(), Ge;
        }
        function p(x) {
          const b = [];
          if (x.shaderID ? b.push(x.shaderID) : (b.push(x.customVertexShaderID), b.push(x.customFragmentShaderID)), x.defines !== void 0) for (const A in x.defines) b.push(A), b.push(x.defines[A]);
          return x.isRawShaderMaterial === false && (y(b, x), w(b, x), b.push(n.outputColorSpace)), b.push(x.customProgramCacheKey), b.join();
        }
        function y(x, b) {
          x.push(b.precision), x.push(b.outputColorSpace), x.push(b.envMapMode), x.push(b.envMapCubeUVHeight), x.push(b.mapUv), x.push(b.alphaMapUv), x.push(b.lightMapUv), x.push(b.aoMapUv), x.push(b.bumpMapUv), x.push(b.normalMapUv), x.push(b.displacementMapUv), x.push(b.emissiveMapUv), x.push(b.metalnessMapUv), x.push(b.roughnessMapUv), x.push(b.anisotropyMapUv), x.push(b.clearcoatMapUv), x.push(b.clearcoatNormalMapUv), x.push(b.clearcoatRoughnessMapUv), x.push(b.iridescenceMapUv), x.push(b.iridescenceThicknessMapUv), x.push(b.sheenColorMapUv), x.push(b.sheenRoughnessMapUv), x.push(b.specularMapUv), x.push(b.specularColorMapUv), x.push(b.specularIntensityMapUv), x.push(b.transmissionMapUv), x.push(b.thicknessMapUv), x.push(b.combine), x.push(b.fogExp2), x.push(b.sizeAttenuation), x.push(b.morphTargetsCount), x.push(b.morphAttributeCount), x.push(b.numDirLights), x.push(b.numPointLights), x.push(b.numSpotLights), x.push(b.numSpotLightMaps), x.push(b.numHemiLights), x.push(b.numRectAreaLights), x.push(b.numDirLightShadows), x.push(b.numPointLightShadows), x.push(b.numSpotLightShadows), x.push(b.numSpotLightShadowsWithMaps), x.push(b.numLightProbes), x.push(b.shadowMapType), x.push(b.toneMapping), x.push(b.numClippingPlanes), x.push(b.numClipIntersection), x.push(b.depthPacking);
        }
        function w(x, b) {
          a.disableAll(), b.supportsVertexTextures && a.enable(0), b.instancing && a.enable(1), b.instancingColor && a.enable(2), b.instancingMorph && a.enable(3), b.matcap && a.enable(4), b.envMap && a.enable(5), b.normalMapObjectSpace && a.enable(6), b.normalMapTangentSpace && a.enable(7), b.clearcoat && a.enable(8), b.iridescence && a.enable(9), b.alphaTest && a.enable(10), b.vertexColors && a.enable(11), b.vertexAlphas && a.enable(12), b.vertexUv1s && a.enable(13), b.vertexUv2s && a.enable(14), b.vertexUv3s && a.enable(15), b.vertexTangents && a.enable(16), b.anisotropy && a.enable(17), b.alphaHash && a.enable(18), b.batching && a.enable(19), b.dispersion && a.enable(20), b.batchingColor && a.enable(21), x.push(a.mask), a.disableAll(), b.fog && a.enable(0), b.useFog && a.enable(1), b.flatShading && a.enable(2), b.logarithmicDepthBuffer && a.enable(3), b.reverseDepthBuffer && a.enable(4), b.skinning && a.enable(5), b.morphTargets && a.enable(6), b.morphNormals && a.enable(7), b.morphColors && a.enable(8), b.premultipliedAlpha && a.enable(9), b.shadowMapEnabled && a.enable(10), b.doubleSided && a.enable(11), b.flipSided && a.enable(12), b.useDepthPacking && a.enable(13), b.dithering && a.enable(14), b.transmission && a.enable(15), b.sheen && a.enable(16), b.opaque && a.enable(17), b.pointsUvs && a.enable(18), b.decodeVideoTexture && a.enable(19), b.decodeVideoTextureEmissive && a.enable(20), b.alphaToCoverage && a.enable(21), x.push(a.mask);
        }
        function M(x) {
          const b = g[x.type];
          let A;
          if (b) {
            const L = Fn[b];
            A = Qx.clone(L.uniforms);
          } else A = x.uniforms;
          return A;
        }
        function C(x, b) {
          let A;
          for (let L = 0, I = h.length; L < I; L++) {
            const H = h[L];
            if (H.cacheKey === b) {
              A = H, ++A.usedTimes;
              break;
            }
          }
          return A === void 0 && (A = new DS(n, b, x, r), h.push(A)), A;
        }
        function R(x) {
          if (--x.usedTimes === 0) {
            const b = h.indexOf(x);
            h[b] = h[h.length - 1], h.pop(), x.destroy();
          }
        }
        function T(x) {
          l.remove(x);
        }
        function v() {
          l.dispose();
        }
        return {
          getParameters: m,
          getProgramCacheKey: p,
          getUniforms: M,
          acquireProgram: C,
          releaseProgram: R,
          releaseShaderCache: T,
          programs: h,
          dispose: v
        };
      }
      function FS() {
        let n = /* @__PURE__ */ new WeakMap();
        function t(o) {
          return n.has(o);
        }
        function e(o) {
          let a = n.get(o);
          return a === void 0 && (a = {}, n.set(o, a)), a;
        }
        function i(o) {
          n.delete(o);
        }
        function s(o, a, l) {
          n.get(o)[a] = l;
        }
        function r() {
          n = /* @__PURE__ */ new WeakMap();
        }
        return {
          has: t,
          get: e,
          remove: i,
          update: s,
          dispose: r
        };
      }
      function NS(n, t) {
        return n.groupOrder !== t.groupOrder ? n.groupOrder - t.groupOrder : n.renderOrder !== t.renderOrder ? n.renderOrder - t.renderOrder : n.material.id !== t.material.id ? n.material.id - t.material.id : n.z !== t.z ? n.z - t.z : n.id - t.id;
      }
      function Qd(n, t) {
        return n.groupOrder !== t.groupOrder ? n.groupOrder - t.groupOrder : n.renderOrder !== t.renderOrder ? n.renderOrder - t.renderOrder : n.z !== t.z ? t.z - n.z : n.id - t.id;
      }
      function Jd() {
        const n = [];
        let t = 0;
        const e = [], i = [], s = [];
        function r() {
          t = 0, e.length = 0, i.length = 0, s.length = 0;
        }
        function o(u, d, f, g, _, m) {
          let p = n[t];
          return p === void 0 ? (p = {
            id: u.id,
            object: u,
            geometry: d,
            material: f,
            groupOrder: g,
            renderOrder: u.renderOrder,
            z: _,
            group: m
          }, n[t] = p) : (p.id = u.id, p.object = u, p.geometry = d, p.material = f, p.groupOrder = g, p.renderOrder = u.renderOrder, p.z = _, p.group = m), t++, p;
        }
        function a(u, d, f, g, _, m) {
          const p = o(u, d, f, g, _, m);
          f.transmission > 0 ? i.push(p) : f.transparent === true ? s.push(p) : e.push(p);
        }
        function l(u, d, f, g, _, m) {
          const p = o(u, d, f, g, _, m);
          f.transmission > 0 ? i.unshift(p) : f.transparent === true ? s.unshift(p) : e.unshift(p);
        }
        function c(u, d) {
          e.length > 1 && e.sort(u || NS), i.length > 1 && i.sort(d || Qd), s.length > 1 && s.sort(d || Qd);
        }
        function h() {
          for (let u = t, d = n.length; u < d; u++) {
            const f = n[u];
            if (f.id === null) break;
            f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
          }
        }
        return {
          opaque: e,
          transmissive: i,
          transparent: s,
          init: r,
          push: a,
          unshift: l,
          finish: h,
          sort: c
        };
      }
      function US() {
        let n = /* @__PURE__ */ new WeakMap();
        function t(i, s) {
          const r = n.get(i);
          let o;
          return r === void 0 ? (o = new Jd(), n.set(i, [
            o
          ])) : s >= r.length ? (o = new Jd(), r.push(o)) : o = r[s], o;
        }
        function e() {
          n = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: t,
          dispose: e
        };
      }
      function BS() {
        const n = {};
        return {
          get: function(t) {
            if (n[t.id] !== void 0) return n[t.id];
            let e;
            switch (t.type) {
              case "DirectionalLight":
                e = {
                  direction: new O(),
                  color: new qt()
                };
                break;
              case "SpotLight":
                e = {
                  position: new O(),
                  direction: new O(),
                  color: new qt(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                e = {
                  position: new O(),
                  color: new qt(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                e = {
                  direction: new O(),
                  skyColor: new qt(),
                  groundColor: new qt()
                };
                break;
              case "RectAreaLight":
                e = {
                  color: new qt(),
                  position: new O(),
                  halfWidth: new O(),
                  halfHeight: new O()
                };
                break;
            }
            return n[t.id] = e, e;
          }
        };
      }
      function zS() {
        const n = {};
        return {
          get: function(t) {
            if (n[t.id] !== void 0) return n[t.id];
            let e;
            switch (t.type) {
              case "DirectionalLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ft()
                };
                break;
              case "SpotLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ft()
                };
                break;
              case "PointLight":
                e = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ft(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            return n[t.id] = e, e;
          }
        };
      }
      let HS = 0;
      function VS(n, t) {
        return (t.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (n.map ? 1 : 0);
      }
      function WS(n) {
        const t = new BS(), e = zS(), i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
          },
          ambient: [
            0,
            0,
            0
          ],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0,
          numLightProbes: 0
        };
        for (let c = 0; c < 9; c++) i.probe.push(new O());
        const s = new O(), r = new ye(), o = new ye();
        function a(c) {
          let h = 0, u = 0, d = 0;
          for (let x = 0; x < 9; x++) i.probe[x].set(0, 0, 0);
          let f = 0, g = 0, _ = 0, m = 0, p = 0, y = 0, w = 0, M = 0, C = 0, R = 0, T = 0;
          c.sort(VS);
          for (let x = 0, b = c.length; x < b; x++) {
            const A = c[x], L = A.color, I = A.intensity, H = A.distance, j = A.shadow && A.shadow.map ? A.shadow.map.texture : null;
            if (A.isAmbientLight) h += L.r * I, u += L.g * I, d += L.b * I;
            else if (A.isLightProbe) {
              for (let z = 0; z < 9; z++) i.probe[z].addScaledVector(A.sh.coefficients[z], I);
              T++;
            } else if (A.isDirectionalLight) {
              const z = t.get(A);
              if (z.color.copy(A.color).multiplyScalar(A.intensity), A.castShadow) {
                const V = A.shadow, U = e.get(A);
                U.shadowIntensity = V.intensity, U.shadowBias = V.bias, U.shadowNormalBias = V.normalBias, U.shadowRadius = V.radius, U.shadowMapSize = V.mapSize, i.directionalShadow[f] = U, i.directionalShadowMap[f] = j, i.directionalShadowMatrix[f] = A.shadow.matrix, y++;
              }
              i.directional[f] = z, f++;
            } else if (A.isSpotLight) {
              const z = t.get(A);
              z.position.setFromMatrixPosition(A.matrixWorld), z.color.copy(L).multiplyScalar(I), z.distance = H, z.coneCos = Math.cos(A.angle), z.penumbraCos = Math.cos(A.angle * (1 - A.penumbra)), z.decay = A.decay, i.spot[_] = z;
              const V = A.shadow;
              if (A.map && (i.spotLightMap[C] = A.map, C++, V.updateMatrices(A), A.castShadow && R++), i.spotLightMatrix[_] = V.matrix, A.castShadow) {
                const U = e.get(A);
                U.shadowIntensity = V.intensity, U.shadowBias = V.bias, U.shadowNormalBias = V.normalBias, U.shadowRadius = V.radius, U.shadowMapSize = V.mapSize, i.spotShadow[_] = U, i.spotShadowMap[_] = j, M++;
              }
              _++;
            } else if (A.isRectAreaLight) {
              const z = t.get(A);
              z.color.copy(L).multiplyScalar(I), z.halfWidth.set(A.width * 0.5, 0, 0), z.halfHeight.set(0, A.height * 0.5, 0), i.rectArea[m] = z, m++;
            } else if (A.isPointLight) {
              const z = t.get(A);
              if (z.color.copy(A.color).multiplyScalar(A.intensity), z.distance = A.distance, z.decay = A.decay, A.castShadow) {
                const V = A.shadow, U = e.get(A);
                U.shadowIntensity = V.intensity, U.shadowBias = V.bias, U.shadowNormalBias = V.normalBias, U.shadowRadius = V.radius, U.shadowMapSize = V.mapSize, U.shadowCameraNear = V.camera.near, U.shadowCameraFar = V.camera.far, i.pointShadow[g] = U, i.pointShadowMap[g] = j, i.pointShadowMatrix[g] = A.shadow.matrix, w++;
              }
              i.point[g] = z, g++;
            } else if (A.isHemisphereLight) {
              const z = t.get(A);
              z.skyColor.copy(A.color).multiplyScalar(I), z.groundColor.copy(A.groundColor).multiplyScalar(I), i.hemi[p] = z, p++;
            }
          }
          m > 0 && (n.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = mt.LTC_FLOAT_1, i.rectAreaLTC2 = mt.LTC_FLOAT_2) : (i.rectAreaLTC1 = mt.LTC_HALF_1, i.rectAreaLTC2 = mt.LTC_HALF_2)), i.ambient[0] = h, i.ambient[1] = u, i.ambient[2] = d;
          const v = i.hash;
          (v.directionalLength !== f || v.pointLength !== g || v.spotLength !== _ || v.rectAreaLength !== m || v.hemiLength !== p || v.numDirectionalShadows !== y || v.numPointShadows !== w || v.numSpotShadows !== M || v.numSpotMaps !== C || v.numLightProbes !== T) && (i.directional.length = f, i.spot.length = _, i.rectArea.length = m, i.point.length = g, i.hemi.length = p, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = w, i.pointShadowMap.length = w, i.spotShadow.length = M, i.spotShadowMap.length = M, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = w, i.spotLightMatrix.length = M + C - R, i.spotLightMap.length = C, i.numSpotLightShadowsWithMaps = R, i.numLightProbes = T, v.directionalLength = f, v.pointLength = g, v.spotLength = _, v.rectAreaLength = m, v.hemiLength = p, v.numDirectionalShadows = y, v.numPointShadows = w, v.numSpotShadows = M, v.numSpotMaps = C, v.numLightProbes = T, i.version = HS++);
        }
        function l(c, h) {
          let u = 0, d = 0, f = 0, g = 0, _ = 0;
          const m = h.matrixWorldInverse;
          for (let p = 0, y = c.length; p < y; p++) {
            const w = c[p];
            if (w.isDirectionalLight) {
              const M = i.directional[u];
              M.direction.setFromMatrixPosition(w.matrixWorld), s.setFromMatrixPosition(w.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(m), u++;
            } else if (w.isSpotLight) {
              const M = i.spot[f];
              M.position.setFromMatrixPosition(w.matrixWorld), M.position.applyMatrix4(m), M.direction.setFromMatrixPosition(w.matrixWorld), s.setFromMatrixPosition(w.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(m), f++;
            } else if (w.isRectAreaLight) {
              const M = i.rectArea[g];
              M.position.setFromMatrixPosition(w.matrixWorld), M.position.applyMatrix4(m), o.identity(), r.copy(w.matrixWorld), r.premultiply(m), o.extractRotation(r), M.halfWidth.set(w.width * 0.5, 0, 0), M.halfHeight.set(0, w.height * 0.5, 0), M.halfWidth.applyMatrix4(o), M.halfHeight.applyMatrix4(o), g++;
            } else if (w.isPointLight) {
              const M = i.point[d];
              M.position.setFromMatrixPosition(w.matrixWorld), M.position.applyMatrix4(m), d++;
            } else if (w.isHemisphereLight) {
              const M = i.hemi[_];
              M.direction.setFromMatrixPosition(w.matrixWorld), M.direction.transformDirection(m), _++;
            }
          }
        }
        return {
          setup: a,
          setupView: l,
          state: i
        };
      }
      function tf(n) {
        const t = new WS(n), e = [], i = [];
        function s(h) {
          c.camera = h, e.length = 0, i.length = 0;
        }
        function r(h) {
          e.push(h);
        }
        function o(h) {
          i.push(h);
        }
        function a() {
          t.setup(e);
        }
        function l(h) {
          t.setupView(e, h);
        }
        const c = {
          lightsArray: e,
          shadowsArray: i,
          camera: null,
          lights: t,
          transmissionRenderTarget: {}
        };
        return {
          init: s,
          state: c,
          setupLights: a,
          setupLightsView: l,
          pushLight: r,
          pushShadow: o
        };
      }
      function GS(n) {
        let t = /* @__PURE__ */ new WeakMap();
        function e(s, r = 0) {
          const o = t.get(s);
          let a;
          return o === void 0 ? (a = new tf(n), t.set(s, [
            a
          ])) : r >= o.length ? (a = new tf(n), o.push(a)) : a = o[r], a;
        }
        function i() {
          t = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: e,
          dispose: i
        };
      }
      const XS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, YS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function jS(n, t, e) {
        let i = new $h();
        const s = new Ft(), r = new Ft(), o = new pe(), a = new db({
          depthPacking: bx
        }), l = new fb(), c = {}, h = e.maxTextureSize, u = {
          [Di]: an,
          [an]: Di,
          [Nn]: Nn
        }, d = new Li({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new Ft()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: XS,
          fragmentShader: YS
        }), f = d.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const g = new xn();
        g.setAttribute("position", new In(new Float32Array([
          -1,
          -1,
          0.5,
          3,
          -1,
          0.5,
          -1,
          3,
          0.5
        ]), 3));
        const _ = new Dn(g, d), m = this;
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = bm;
        let p = this.type;
        this.render = function(R, T, v) {
          if (m.enabled === false || m.autoUpdate === false && m.needsUpdate === false || R.length === 0) return;
          const x = n.getRenderTarget(), b = n.getActiveCubeFace(), A = n.getActiveMipmapLevel(), L = n.state;
          L.setBlending(wi), L.buffers.color.setClear(1, 1, 1, 1), L.buffers.depth.setTest(true), L.setScissorTest(false);
          const I = p !== Jn && this.type === Jn, H = p === Jn && this.type !== Jn;
          for (let j = 0, z = R.length; j < z; j++) {
            const V = R[j], U = V.shadow;
            if (U === void 0) {
              console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
              continue;
            }
            if (U.autoUpdate === false && U.needsUpdate === false) continue;
            s.copy(U.mapSize);
            const q = U.getFrameExtents();
            if (s.multiply(q), r.copy(U.mapSize), (s.x > h || s.y > h) && (s.x > h && (r.x = Math.floor(h / q.x), s.x = r.x * q.x, U.mapSize.x = r.x), s.y > h && (r.y = Math.floor(h / q.y), s.y = r.y * q.y, U.mapSize.y = r.y)), U.map === null || I === true || H === true) {
              const et = this.type !== Jn ? {
                minFilter: Ln,
                magFilter: Ln
              } : {};
              U.map !== null && U.map.dispose(), U.map = new as(s.x, s.y, et), U.map.texture.name = V.name + ".shadowMap", U.camera.updateProjectionMatrix();
            }
            n.setRenderTarget(U.map), n.clear();
            const rt = U.getViewportCount();
            for (let et = 0; et < rt; et++) {
              const ut = U.getViewport(et);
              o.set(r.x * ut.x, r.y * ut.y, r.x * ut.z, r.y * ut.w), L.viewport(o), U.updateMatrices(V, et), i = U.getFrustum(), M(T, v, U.camera, V, this.type);
            }
            U.isPointLightShadow !== true && this.type === Jn && y(U, v), U.needsUpdate = false;
          }
          p = this.type, m.needsUpdate = false, n.setRenderTarget(x, b, A);
        };
        function y(R, T) {
          const v = t.update(_);
          d.defines.VSM_SAMPLES !== R.blurSamples && (d.defines.VSM_SAMPLES = R.blurSamples, f.defines.VSM_SAMPLES = R.blurSamples, d.needsUpdate = true, f.needsUpdate = true), R.mapPass === null && (R.mapPass = new as(s.x, s.y)), d.uniforms.shadow_pass.value = R.map.texture, d.uniforms.resolution.value = R.mapSize, d.uniforms.radius.value = R.radius, n.setRenderTarget(R.mapPass), n.clear(), n.renderBufferDirect(T, null, v, d, _, null), f.uniforms.shadow_pass.value = R.mapPass.texture, f.uniforms.resolution.value = R.mapSize, f.uniforms.radius.value = R.radius, n.setRenderTarget(R.map), n.clear(), n.renderBufferDirect(T, null, v, f, _, null);
        }
        function w(R, T, v, x) {
          let b = null;
          const A = v.isPointLight === true ? R.customDistanceMaterial : R.customDepthMaterial;
          if (A !== void 0) b = A;
          else if (b = v.isPointLight === true ? l : a, n.localClippingEnabled && T.clipShadows === true && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0 || T.alphaToCoverage === true) {
            const L = b.uuid, I = T.uuid;
            let H = c[L];
            H === void 0 && (H = {}, c[L] = H);
            let j = H[I];
            j === void 0 && (j = b.clone(), H[I] = j, T.addEventListener("dispose", C)), b = j;
          }
          if (b.visible = T.visible, b.wireframe = T.wireframe, x === Jn ? b.side = T.shadowSide !== null ? T.shadowSide : T.side : b.side = T.shadowSide !== null ? T.shadowSide : u[T.side], b.alphaMap = T.alphaMap, b.alphaTest = T.alphaToCoverage === true ? 0.5 : T.alphaTest, b.map = T.map, b.clipShadows = T.clipShadows, b.clippingPlanes = T.clippingPlanes, b.clipIntersection = T.clipIntersection, b.displacementMap = T.displacementMap, b.displacementScale = T.displacementScale, b.displacementBias = T.displacementBias, b.wireframeLinewidth = T.wireframeLinewidth, b.linewidth = T.linewidth, v.isPointLight === true && b.isMeshDistanceMaterial === true) {
            const L = n.properties.get(b);
            L.light = v;
          }
          return b;
        }
        function M(R, T, v, x, b) {
          if (R.visible === false) return;
          if (R.layers.test(T.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && b === Jn) && (!R.frustumCulled || i.intersectsObject(R))) {
            R.modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, R.matrixWorld);
            const I = t.update(R), H = R.material;
            if (Array.isArray(H)) {
              const j = I.groups;
              for (let z = 0, V = j.length; z < V; z++) {
                const U = j[z], q = H[U.materialIndex];
                if (q && q.visible) {
                  const rt = w(R, q, x, b);
                  R.onBeforeShadow(n, R, T, v, I, rt, U), n.renderBufferDirect(v, null, I, rt, R, U), R.onAfterShadow(n, R, T, v, I, rt, U);
                }
              }
            } else if (H.visible) {
              const j = w(R, H, x, b);
              R.onBeforeShadow(n, R, T, v, I, j, null), n.renderBufferDirect(v, null, I, j, R, null), R.onAfterShadow(n, R, T, v, I, j, null);
            }
          }
          const L = R.children;
          for (let I = 0, H = L.length; I < H; I++) M(L[I], T, v, x, b);
        }
        function C(R) {
          R.target.removeEventListener("dispose", C);
          for (const v in c) {
            const x = c[v], b = R.target.uuid;
            b in x && (x[b].dispose(), delete x[b]);
          }
        }
      }
      const qS = {
        [Ec]: Tc,
        [Ac]: Pc,
        [Cc]: Dc,
        [Qs]: Rc,
        [Tc]: Ec,
        [Pc]: Ac,
        [Dc]: Cc,
        [Rc]: Qs
      };
      function $S(n, t) {
        function e() {
          let k = false;
          const yt = new pe();
          let Z = null;
          const tt = new pe(0, 0, 0, 0);
          return {
            setMask: function(Mt) {
              Z !== Mt && !k && (n.colorMask(Mt, Mt, Mt, Mt), Z = Mt);
            },
            setLocked: function(Mt) {
              k = Mt;
            },
            setClear: function(Mt, vt, Gt, we, Ge) {
              Ge === true && (Mt *= we, vt *= we, Gt *= we), yt.set(Mt, vt, Gt, we), tt.equals(yt) === false && (n.clearColor(Mt, vt, Gt, we), tt.copy(yt));
            },
            reset: function() {
              k = false, Z = null, tt.set(-1, 0, 0, 0);
            }
          };
        }
        function i() {
          let k = false, yt = false, Z = null, tt = null, Mt = null;
          return {
            setReversed: function(vt) {
              if (yt !== vt) {
                const Gt = t.get("EXT_clip_control");
                vt ? Gt.clipControlEXT(Gt.LOWER_LEFT_EXT, Gt.ZERO_TO_ONE_EXT) : Gt.clipControlEXT(Gt.LOWER_LEFT_EXT, Gt.NEGATIVE_ONE_TO_ONE_EXT), yt = vt;
                const we = Mt;
                Mt = null, this.setClear(we);
              }
            },
            getReversed: function() {
              return yt;
            },
            setTest: function(vt) {
              vt ? ht(n.DEPTH_TEST) : it(n.DEPTH_TEST);
            },
            setMask: function(vt) {
              Z !== vt && !k && (n.depthMask(vt), Z = vt);
            },
            setFunc: function(vt) {
              if (yt && (vt = qS[vt]), tt !== vt) {
                switch (vt) {
                  case Ec:
                    n.depthFunc(n.NEVER);
                    break;
                  case Tc:
                    n.depthFunc(n.ALWAYS);
                    break;
                  case Ac:
                    n.depthFunc(n.LESS);
                    break;
                  case Qs:
                    n.depthFunc(n.LEQUAL);
                    break;
                  case Cc:
                    n.depthFunc(n.EQUAL);
                    break;
                  case Rc:
                    n.depthFunc(n.GEQUAL);
                    break;
                  case Pc:
                    n.depthFunc(n.GREATER);
                    break;
                  case Dc:
                    n.depthFunc(n.NOTEQUAL);
                    break;
                  default:
                    n.depthFunc(n.LEQUAL);
                }
                tt = vt;
              }
            },
            setLocked: function(vt) {
              k = vt;
            },
            setClear: function(vt) {
              Mt !== vt && (yt && (vt = 1 - vt), n.clearDepth(vt), Mt = vt);
            },
            reset: function() {
              k = false, Z = null, tt = null, Mt = null, yt = false;
            }
          };
        }
        function s() {
          let k = false, yt = null, Z = null, tt = null, Mt = null, vt = null, Gt = null, we = null, Ge = null;
          return {
            setTest: function(ae) {
              k || (ae ? ht(n.STENCIL_TEST) : it(n.STENCIL_TEST));
            },
            setMask: function(ae) {
              yt !== ae && !k && (n.stencilMask(ae), yt = ae);
            },
            setFunc: function(ae, En, Xn) {
              (Z !== ae || tt !== En || Mt !== Xn) && (n.stencilFunc(ae, En, Xn), Z = ae, tt = En, Mt = Xn);
            },
            setOp: function(ae, En, Xn) {
              (vt !== ae || Gt !== En || we !== Xn) && (n.stencilOp(ae, En, Xn), vt = ae, Gt = En, we = Xn);
            },
            setLocked: function(ae) {
              k = ae;
            },
            setClear: function(ae) {
              Ge !== ae && (n.clearStencil(ae), Ge = ae);
            },
            reset: function() {
              k = false, yt = null, Z = null, tt = null, Mt = null, vt = null, Gt = null, we = null, Ge = null;
            }
          };
        }
        const r = new e(), o = new i(), a = new s(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
        let h = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), f = [], g = null, _ = false, m = null, p = null, y = null, w = null, M = null, C = null, R = null, T = new qt(0, 0, 0), v = 0, x = false, b = null, A = null, L = null, I = null, H = null;
        const j = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let z = false, V = 0;
        const U = n.getParameter(n.VERSION);
        U.indexOf("WebGL") !== -1 ? (V = parseFloat(/^WebGL (\d)/.exec(U)[1]), z = V >= 1) : U.indexOf("OpenGL ES") !== -1 && (V = parseFloat(/^OpenGL ES (\d)/.exec(U)[1]), z = V >= 2);
        let q = null, rt = {};
        const et = n.getParameter(n.SCISSOR_BOX), ut = n.getParameter(n.VIEWPORT), ot = new pe().fromArray(et), W = new pe().fromArray(ut);
        function J(k, yt, Z, tt) {
          const Mt = new Uint8Array(4), vt = n.createTexture();
          n.bindTexture(k, vt), n.texParameteri(k, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(k, n.TEXTURE_MAG_FILTER, n.NEAREST);
          for (let Gt = 0; Gt < Z; Gt++) k === n.TEXTURE_3D || k === n.TEXTURE_2D_ARRAY ? n.texImage3D(yt, 0, n.RGBA, 1, 1, tt, 0, n.RGBA, n.UNSIGNED_BYTE, Mt) : n.texImage2D(yt + Gt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Mt);
          return vt;
        }
        const ct = {};
        ct[n.TEXTURE_2D] = J(n.TEXTURE_2D, n.TEXTURE_2D, 1), ct[n.TEXTURE_CUBE_MAP] = J(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ct[n.TEXTURE_2D_ARRAY] = J(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), ct[n.TEXTURE_3D] = J(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), ht(n.DEPTH_TEST), o.setFunc(Qs), ft(false), Lt($u), ht(n.CULL_FACE), D(wi);
        function ht(k) {
          h[k] !== true && (n.enable(k), h[k] = true);
        }
        function it(k) {
          h[k] !== false && (n.disable(k), h[k] = false);
        }
        function St(k, yt) {
          return u[k] !== yt ? (n.bindFramebuffer(k, yt), u[k] = yt, k === n.DRAW_FRAMEBUFFER && (u[n.FRAMEBUFFER] = yt), k === n.FRAMEBUFFER && (u[n.DRAW_FRAMEBUFFER] = yt), true) : false;
        }
        function lt(k, yt) {
          let Z = f, tt = false;
          if (k) {
            Z = d.get(yt), Z === void 0 && (Z = [], d.set(yt, Z));
            const Mt = k.textures;
            if (Z.length !== Mt.length || Z[0] !== n.COLOR_ATTACHMENT0) {
              for (let vt = 0, Gt = Mt.length; vt < Gt; vt++) Z[vt] = n.COLOR_ATTACHMENT0 + vt;
              Z.length = Mt.length, tt = true;
            }
          } else Z[0] !== n.BACK && (Z[0] = n.BACK, tt = true);
          tt && n.drawBuffers(Z);
        }
        function dt(k) {
          return g !== k ? (n.useProgram(k), g = k, true) : false;
        }
        const wt = {
          [ts]: n.FUNC_ADD,
          [X0]: n.FUNC_SUBTRACT,
          [Y0]: n.FUNC_REVERSE_SUBTRACT
        };
        wt[j0] = n.MIN, wt[q0] = n.MAX;
        const bt = {
          [$0]: n.ZERO,
          [K0]: n.ONE,
          [Z0]: n.SRC_COLOR,
          [Sc]: n.SRC_ALPHA,
          [ix]: n.SRC_ALPHA_SATURATE,
          [ex]: n.DST_COLOR,
          [J0]: n.DST_ALPHA,
          [Q0]: n.ONE_MINUS_SRC_COLOR,
          [wc]: n.ONE_MINUS_SRC_ALPHA,
          [nx]: n.ONE_MINUS_DST_COLOR,
          [tx]: n.ONE_MINUS_DST_ALPHA,
          [sx]: n.CONSTANT_COLOR,
          [rx]: n.ONE_MINUS_CONSTANT_COLOR,
          [ox]: n.CONSTANT_ALPHA,
          [ax]: n.ONE_MINUS_CONSTANT_ALPHA
        };
        function D(k, yt, Z, tt, Mt, vt, Gt, we, Ge, ae) {
          if (k === wi) {
            _ === true && (it(n.BLEND), _ = false);
            return;
          }
          if (_ === false && (ht(n.BLEND), _ = true), k !== G0) {
            if (k !== m || ae !== x) {
              if ((p !== ts || M !== ts) && (n.blendEquation(n.FUNC_ADD), p = ts, M = ts), ae) switch (k) {
                case js:
                  n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                  break;
                case Ku:
                  n.blendFunc(n.ONE, n.ONE);
                  break;
                case Zu:
                  n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                  break;
                case Qu:
                  n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", k);
                  break;
              }
              else switch (k) {
                case js:
                  n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                  break;
                case Ku:
                  n.blendFunc(n.SRC_ALPHA, n.ONE);
                  break;
                case Zu:
                  n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                  break;
                case Qu:
                  n.blendFunc(n.ZERO, n.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", k);
                  break;
              }
              y = null, w = null, C = null, R = null, T.set(0, 0, 0), v = 0, m = k, x = ae;
            }
            return;
          }
          Mt = Mt || yt, vt = vt || Z, Gt = Gt || tt, (yt !== p || Mt !== M) && (n.blendEquationSeparate(wt[yt], wt[Mt]), p = yt, M = Mt), (Z !== y || tt !== w || vt !== C || Gt !== R) && (n.blendFuncSeparate(bt[Z], bt[tt], bt[vt], bt[Gt]), y = Z, w = tt, C = vt, R = Gt), (we.equals(T) === false || Ge !== v) && (n.blendColor(we.r, we.g, we.b, Ge), T.copy(we), v = Ge), m = k, x = false;
        }
        function zt(k, yt) {
          k.side === Nn ? it(n.CULL_FACE) : ht(n.CULL_FACE);
          let Z = k.side === an;
          yt && (Z = !Z), ft(Z), k.blending === js && k.transparent === false ? D(wi) : D(k.blending, k.blendEquation, k.blendSrc, k.blendDst, k.blendEquationAlpha, k.blendSrcAlpha, k.blendDstAlpha, k.blendColor, k.blendAlpha, k.premultipliedAlpha), o.setFunc(k.depthFunc), o.setTest(k.depthTest), o.setMask(k.depthWrite), r.setMask(k.colorWrite);
          const tt = k.stencilWrite;
          a.setTest(tt), tt && (a.setMask(k.stencilWriteMask), a.setFunc(k.stencilFunc, k.stencilRef, k.stencilFuncMask), a.setOp(k.stencilFail, k.stencilZFail, k.stencilZPass)), Rt(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits), k.alphaToCoverage === true ? ht(n.SAMPLE_ALPHA_TO_COVERAGE) : it(n.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function ft(k) {
          b !== k && (k ? n.frontFace(n.CW) : n.frontFace(n.CCW), b = k);
        }
        function Lt(k) {
          k !== H0 ? (ht(n.CULL_FACE), k !== A && (k === $u ? n.cullFace(n.BACK) : k === V0 ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : it(n.CULL_FACE), A = k;
        }
        function st(k) {
          k !== L && (z && n.lineWidth(k), L = k);
        }
        function Rt(k, yt, Z) {
          k ? (ht(n.POLYGON_OFFSET_FILL), (I !== yt || H !== Z) && (n.polygonOffset(yt, Z), I = yt, H = Z)) : it(n.POLYGON_OFFSET_FILL);
        }
        function Et(k) {
          k ? ht(n.SCISSOR_TEST) : it(n.SCISSOR_TEST);
        }
        function P(k) {
          k === void 0 && (k = n.TEXTURE0 + j - 1), q !== k && (n.activeTexture(k), q = k);
        }
        function S(k, yt, Z) {
          Z === void 0 && (q === null ? Z = n.TEXTURE0 + j - 1 : Z = q);
          let tt = rt[Z];
          tt === void 0 && (tt = {
            type: void 0,
            texture: void 0
          }, rt[Z] = tt), (tt.type !== k || tt.texture !== yt) && (q !== Z && (n.activeTexture(Z), q = Z), n.bindTexture(k, yt || ct[k]), tt.type = k, tt.texture = yt);
        }
        function B() {
          const k = rt[q];
          k !== void 0 && k.type !== void 0 && (n.bindTexture(k.type, null), k.type = void 0, k.texture = void 0);
        }
        function K() {
          try {
            n.compressedTexImage2D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function Q() {
          try {
            n.compressedTexImage3D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function X() {
          try {
            n.texSubImage2D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function _t() {
          try {
            n.texSubImage3D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function pt() {
          try {
            n.compressedTexSubImage2D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function Pt() {
          try {
            n.compressedTexSubImage3D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function kt() {
          try {
            n.texStorage2D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function nt() {
          try {
            n.texStorage3D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function gt() {
          try {
            n.texImage2D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function Dt() {
          try {
            n.texImage3D(...arguments);
          } catch (k) {
            console.error("THREE.WebGLState:", k);
          }
        }
        function Nt(k) {
          ot.equals(k) === false && (n.scissor(k.x, k.y, k.z, k.w), ot.copy(k));
        }
        function At(k) {
          W.equals(k) === false && (n.viewport(k.x, k.y, k.z, k.w), W.copy(k));
        }
        function Qt(k, yt) {
          let Z = c.get(yt);
          Z === void 0 && (Z = /* @__PURE__ */ new WeakMap(), c.set(yt, Z));
          let tt = Z.get(k);
          tt === void 0 && (tt = n.getUniformBlockIndex(yt, k.name), Z.set(k, tt));
        }
        function Yt(k, yt) {
          const tt = c.get(yt).get(k);
          l.get(yt) !== tt && (n.uniformBlockBinding(yt, tt, k.__bindingPointIndex), l.set(yt, tt));
        }
        function _e() {
          n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(true, true, true, true), n.clearColor(0, 0, 0, 0), n.depthMask(true), n.depthFunc(n.LESS), o.setReversed(false), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), h = {}, q = null, rt = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), f = [], g = null, _ = false, m = null, p = null, y = null, w = null, M = null, C = null, R = null, T = new qt(0, 0, 0), v = 0, x = false, b = null, A = null, L = null, I = null, H = null, ot.set(0, 0, n.canvas.width, n.canvas.height), W.set(0, 0, n.canvas.width, n.canvas.height), r.reset(), o.reset(), a.reset();
        }
        return {
          buffers: {
            color: r,
            depth: o,
            stencil: a
          },
          enable: ht,
          disable: it,
          bindFramebuffer: St,
          drawBuffers: lt,
          useProgram: dt,
          setBlending: D,
          setMaterial: zt,
          setFlipSided: ft,
          setCullFace: Lt,
          setLineWidth: st,
          setPolygonOffset: Rt,
          setScissorTest: Et,
          activeTexture: P,
          bindTexture: S,
          unbindTexture: B,
          compressedTexImage2D: K,
          compressedTexImage3D: Q,
          texImage2D: gt,
          texImage3D: Dt,
          updateUBOMapping: Qt,
          uniformBlockBinding: Yt,
          texStorage2D: kt,
          texStorage3D: nt,
          texSubImage2D: X,
          texSubImage3D: _t,
          compressedTexSubImage2D: pt,
          compressedTexSubImage3D: Pt,
          scissor: Nt,
          viewport: At,
          reset: _e
        };
      }
      function KS(n, t, e, i, s, r, o) {
        const a = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new Ft(), h = /* @__PURE__ */ new WeakMap();
        let u;
        const d = /* @__PURE__ */ new WeakMap();
        let f = false;
        try {
          f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {
        }
        function g(P, S) {
          return f ? new OffscreenCanvas(P, S) : Oa("canvas");
        }
        function _(P, S, B) {
          let K = 1;
          const Q = Et(P);
          if ((Q.width > B || Q.height > B) && (K = B / Math.max(Q.width, Q.height)), K < 1) if (typeof HTMLImageElement < "u" && P instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && P instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && P instanceof ImageBitmap || typeof VideoFrame < "u" && P instanceof VideoFrame) {
            const X = Math.floor(K * Q.width), _t = Math.floor(K * Q.height);
            u === void 0 && (u = g(X, _t));
            const pt = S ? g(X, _t) : u;
            return pt.width = X, pt.height = _t, pt.getContext("2d").drawImage(P, 0, 0, X, _t), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Q.width + "x" + Q.height + ") to (" + X + "x" + _t + ")."), pt;
          } else return "data" in P && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Q.width + "x" + Q.height + ")."), P;
          return P;
        }
        function m(P) {
          return P.generateMipmaps;
        }
        function p(P) {
          n.generateMipmap(P);
        }
        function y(P) {
          return P.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : P.isWebGL3DRenderTarget ? n.TEXTURE_3D : P.isWebGLArrayRenderTarget || P.isCompressedArrayTexture ? n.TEXTURE_2D_ARRAY : n.TEXTURE_2D;
        }
        function w(P, S, B, K, Q = false) {
          if (P !== null) {
            if (n[P] !== void 0) return n[P];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + P + "'");
          }
          let X = S;
          if (S === n.RED && (B === n.FLOAT && (X = n.R32F), B === n.HALF_FLOAT && (X = n.R16F), B === n.UNSIGNED_BYTE && (X = n.R8)), S === n.RED_INTEGER && (B === n.UNSIGNED_BYTE && (X = n.R8UI), B === n.UNSIGNED_SHORT && (X = n.R16UI), B === n.UNSIGNED_INT && (X = n.R32UI), B === n.BYTE && (X = n.R8I), B === n.SHORT && (X = n.R16I), B === n.INT && (X = n.R32I)), S === n.RG && (B === n.FLOAT && (X = n.RG32F), B === n.HALF_FLOAT && (X = n.RG16F), B === n.UNSIGNED_BYTE && (X = n.RG8)), S === n.RG_INTEGER && (B === n.UNSIGNED_BYTE && (X = n.RG8UI), B === n.UNSIGNED_SHORT && (X = n.RG16UI), B === n.UNSIGNED_INT && (X = n.RG32UI), B === n.BYTE && (X = n.RG8I), B === n.SHORT && (X = n.RG16I), B === n.INT && (X = n.RG32I)), S === n.RGB_INTEGER && (B === n.UNSIGNED_BYTE && (X = n.RGB8UI), B === n.UNSIGNED_SHORT && (X = n.RGB16UI), B === n.UNSIGNED_INT && (X = n.RGB32UI), B === n.BYTE && (X = n.RGB8I), B === n.SHORT && (X = n.RGB16I), B === n.INT && (X = n.RGB32I)), S === n.RGBA_INTEGER && (B === n.UNSIGNED_BYTE && (X = n.RGBA8UI), B === n.UNSIGNED_SHORT && (X = n.RGBA16UI), B === n.UNSIGNED_INT && (X = n.RGBA32UI), B === n.BYTE && (X = n.RGBA8I), B === n.SHORT && (X = n.RGBA16I), B === n.INT && (X = n.RGBA32I)), S === n.RGB && B === n.UNSIGNED_INT_5_9_9_9_REV && (X = n.RGB9_E5), S === n.RGBA) {
            const _t = Q ? La : ee.getTransfer(K);
            B === n.FLOAT && (X = n.RGBA32F), B === n.HALF_FLOAT && (X = n.RGBA16F), B === n.UNSIGNED_BYTE && (X = _t === ue ? n.SRGB8_ALPHA8 : n.RGBA8), B === n.UNSIGNED_SHORT_4_4_4_4 && (X = n.RGBA4), B === n.UNSIGNED_SHORT_5_5_5_1 && (X = n.RGB5_A1);
          }
          return (X === n.R16F || X === n.R32F || X === n.RG16F || X === n.RG32F || X === n.RGBA16F || X === n.RGBA32F) && t.get("EXT_color_buffer_float"), X;
        }
        function M(P, S) {
          let B;
          return P ? S === null || S === os || S === Kr ? B = n.DEPTH24_STENCIL8 : S === si ? B = n.DEPTH32F_STENCIL8 : S === $r && (B = n.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : S === null || S === os || S === Kr ? B = n.DEPTH_COMPONENT24 : S === si ? B = n.DEPTH_COMPONENT32F : S === $r && (B = n.DEPTH_COMPONENT16), B;
        }
        function C(P, S) {
          return m(P) === true || P.isFramebufferTexture && P.minFilter !== Ln && P.minFilter !== _n ? Math.log2(Math.max(S.width, S.height)) + 1 : P.mipmaps !== void 0 && P.mipmaps.length > 0 ? P.mipmaps.length : P.isCompressedTexture && Array.isArray(P.image) ? S.mipmaps.length : 1;
        }
        function R(P) {
          const S = P.target;
          S.removeEventListener("dispose", R), v(S), S.isVideoTexture && h.delete(S);
        }
        function T(P) {
          const S = P.target;
          S.removeEventListener("dispose", T), b(S);
        }
        function v(P) {
          const S = i.get(P);
          if (S.__webglInit === void 0) return;
          const B = P.source, K = d.get(B);
          if (K) {
            const Q = K[S.__cacheKey];
            Q.usedTimes--, Q.usedTimes === 0 && x(P), Object.keys(K).length === 0 && d.delete(B);
          }
          i.remove(P);
        }
        function x(P) {
          const S = i.get(P);
          n.deleteTexture(S.__webglTexture);
          const B = P.source, K = d.get(B);
          delete K[S.__cacheKey], o.memory.textures--;
        }
        function b(P) {
          const S = i.get(P);
          if (P.depthTexture && (P.depthTexture.dispose(), i.remove(P.depthTexture)), P.isWebGLCubeRenderTarget) for (let K = 0; K < 6; K++) {
            if (Array.isArray(S.__webglFramebuffer[K])) for (let Q = 0; Q < S.__webglFramebuffer[K].length; Q++) n.deleteFramebuffer(S.__webglFramebuffer[K][Q]);
            else n.deleteFramebuffer(S.__webglFramebuffer[K]);
            S.__webglDepthbuffer && n.deleteRenderbuffer(S.__webglDepthbuffer[K]);
          }
          else {
            if (Array.isArray(S.__webglFramebuffer)) for (let K = 0; K < S.__webglFramebuffer.length; K++) n.deleteFramebuffer(S.__webglFramebuffer[K]);
            else n.deleteFramebuffer(S.__webglFramebuffer);
            if (S.__webglDepthbuffer && n.deleteRenderbuffer(S.__webglDepthbuffer), S.__webglMultisampledFramebuffer && n.deleteFramebuffer(S.__webglMultisampledFramebuffer), S.__webglColorRenderbuffer) for (let K = 0; K < S.__webglColorRenderbuffer.length; K++) S.__webglColorRenderbuffer[K] && n.deleteRenderbuffer(S.__webglColorRenderbuffer[K]);
            S.__webglDepthRenderbuffer && n.deleteRenderbuffer(S.__webglDepthRenderbuffer);
          }
          const B = P.textures;
          for (let K = 0, Q = B.length; K < Q; K++) {
            const X = i.get(B[K]);
            X.__webglTexture && (n.deleteTexture(X.__webglTexture), o.memory.textures--), i.remove(B[K]);
          }
          i.remove(P);
        }
        let A = 0;
        function L() {
          A = 0;
        }
        function I() {
          const P = A;
          return P >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + P + " texture units while this GPU supports only " + s.maxTextures), A += 1, P;
        }
        function H(P) {
          const S = [];
          return S.push(P.wrapS), S.push(P.wrapT), S.push(P.wrapR || 0), S.push(P.magFilter), S.push(P.minFilter), S.push(P.anisotropy), S.push(P.internalFormat), S.push(P.format), S.push(P.type), S.push(P.generateMipmaps), S.push(P.premultiplyAlpha), S.push(P.flipY), S.push(P.unpackAlignment), S.push(P.colorSpace), S.join();
        }
        function j(P, S) {
          const B = i.get(P);
          if (P.isVideoTexture && st(P), P.isRenderTargetTexture === false && P.version > 0 && B.__version !== P.version) {
            const K = P.image;
            if (K === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (K.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
              W(B, P, S);
              return;
            }
          }
          e.bindTexture(n.TEXTURE_2D, B.__webglTexture, n.TEXTURE0 + S);
        }
        function z(P, S) {
          const B = i.get(P);
          if (P.version > 0 && B.__version !== P.version) {
            W(B, P, S);
            return;
          }
          e.bindTexture(n.TEXTURE_2D_ARRAY, B.__webglTexture, n.TEXTURE0 + S);
        }
        function V(P, S) {
          const B = i.get(P);
          if (P.version > 0 && B.__version !== P.version) {
            W(B, P, S);
            return;
          }
          e.bindTexture(n.TEXTURE_3D, B.__webglTexture, n.TEXTURE0 + S);
        }
        function U(P, S) {
          const B = i.get(P);
          if (P.version > 0 && B.__version !== P.version) {
            J(B, P, S);
            return;
          }
          e.bindTexture(n.TEXTURE_CUBE_MAP, B.__webglTexture, n.TEXTURE0 + S);
        }
        const q = {
          [Oc]: n.REPEAT,
          [ns]: n.CLAMP_TO_EDGE,
          [kc]: n.MIRRORED_REPEAT
        }, rt = {
          [Ln]: n.NEAREST,
          [_x]: n.NEAREST_MIPMAP_NEAREST,
          [wo]: n.NEAREST_MIPMAP_LINEAR,
          [_n]: n.LINEAR,
          [vl]: n.LINEAR_MIPMAP_NEAREST,
          [is]: n.LINEAR_MIPMAP_LINEAR
        }, et = {
          [vx]: n.NEVER,
          [Ax]: n.ALWAYS,
          [Mx]: n.LESS,
          [Pm]: n.LEQUAL,
          [Sx]: n.EQUAL,
          [Tx]: n.GEQUAL,
          [wx]: n.GREATER,
          [Ex]: n.NOTEQUAL
        };
        function ut(P, S) {
          if (S.type === si && t.has("OES_texture_float_linear") === false && (S.magFilter === _n || S.magFilter === vl || S.magFilter === wo || S.magFilter === is || S.minFilter === _n || S.minFilter === vl || S.minFilter === wo || S.minFilter === is) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), n.texParameteri(P, n.TEXTURE_WRAP_S, q[S.wrapS]), n.texParameteri(P, n.TEXTURE_WRAP_T, q[S.wrapT]), (P === n.TEXTURE_3D || P === n.TEXTURE_2D_ARRAY) && n.texParameteri(P, n.TEXTURE_WRAP_R, q[S.wrapR]), n.texParameteri(P, n.TEXTURE_MAG_FILTER, rt[S.magFilter]), n.texParameteri(P, n.TEXTURE_MIN_FILTER, rt[S.minFilter]), S.compareFunction && (n.texParameteri(P, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(P, n.TEXTURE_COMPARE_FUNC, et[S.compareFunction])), t.has("EXT_texture_filter_anisotropic") === true) {
            if (S.magFilter === Ln || S.minFilter !== wo && S.minFilter !== is || S.type === si && t.has("OES_texture_float_linear") === false) return;
            if (S.anisotropy > 1 || i.get(S).__currentAnisotropy) {
              const B = t.get("EXT_texture_filter_anisotropic");
              n.texParameterf(P, B.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(S.anisotropy, s.getMaxAnisotropy())), i.get(S).__currentAnisotropy = S.anisotropy;
            }
          }
        }
        function ot(P, S) {
          let B = false;
          P.__webglInit === void 0 && (P.__webglInit = true, S.addEventListener("dispose", R));
          const K = S.source;
          let Q = d.get(K);
          Q === void 0 && (Q = {}, d.set(K, Q));
          const X = H(S);
          if (X !== P.__cacheKey) {
            Q[X] === void 0 && (Q[X] = {
              texture: n.createTexture(),
              usedTimes: 0
            }, o.memory.textures++, B = true), Q[X].usedTimes++;
            const _t = Q[P.__cacheKey];
            _t !== void 0 && (Q[P.__cacheKey].usedTimes--, _t.usedTimes === 0 && x(S)), P.__cacheKey = X, P.__webglTexture = Q[X].texture;
          }
          return B;
        }
        function W(P, S, B) {
          let K = n.TEXTURE_2D;
          (S.isDataArrayTexture || S.isCompressedArrayTexture) && (K = n.TEXTURE_2D_ARRAY), S.isData3DTexture && (K = n.TEXTURE_3D);
          const Q = ot(P, S), X = S.source;
          e.bindTexture(K, P.__webglTexture, n.TEXTURE0 + B);
          const _t = i.get(X);
          if (X.version !== _t.__version || Q === true) {
            e.activeTexture(n.TEXTURE0 + B);
            const pt = ee.getPrimaries(ee.workingColorSpace), Pt = S.colorSpace === yi ? null : ee.getPrimaries(S.colorSpace), kt = S.colorSpace === yi || pt === Pt ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, S.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, S.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, S.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, kt);
            let nt = _(S.image, false, s.maxTextureSize);
            nt = Rt(S, nt);
            const gt = r.convert(S.format, S.colorSpace), Dt = r.convert(S.type);
            let Nt = w(S.internalFormat, gt, Dt, S.colorSpace, S.isVideoTexture);
            ut(K, S);
            let At;
            const Qt = S.mipmaps, Yt = S.isVideoTexture !== true, _e = _t.__version === void 0 || Q === true, k = X.dataReady, yt = C(S, nt);
            if (S.isDepthTexture) Nt = M(S.format === Qr, S.type), _e && (Yt ? e.texStorage2D(n.TEXTURE_2D, 1, Nt, nt.width, nt.height) : e.texImage2D(n.TEXTURE_2D, 0, Nt, nt.width, nt.height, 0, gt, Dt, null));
            else if (S.isDataTexture) if (Qt.length > 0) {
              Yt && _e && e.texStorage2D(n.TEXTURE_2D, yt, Nt, Qt[0].width, Qt[0].height);
              for (let Z = 0, tt = Qt.length; Z < tt; Z++) At = Qt[Z], Yt ? k && e.texSubImage2D(n.TEXTURE_2D, Z, 0, 0, At.width, At.height, gt, Dt, At.data) : e.texImage2D(n.TEXTURE_2D, Z, Nt, At.width, At.height, 0, gt, Dt, At.data);
              S.generateMipmaps = false;
            } else Yt ? (_e && e.texStorage2D(n.TEXTURE_2D, yt, Nt, nt.width, nt.height), k && e.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, nt.width, nt.height, gt, Dt, nt.data)) : e.texImage2D(n.TEXTURE_2D, 0, Nt, nt.width, nt.height, 0, gt, Dt, nt.data);
            else if (S.isCompressedTexture) if (S.isCompressedArrayTexture) {
              Yt && _e && e.texStorage3D(n.TEXTURE_2D_ARRAY, yt, Nt, Qt[0].width, Qt[0].height, nt.depth);
              for (let Z = 0, tt = Qt.length; Z < tt; Z++) if (At = Qt[Z], S.format !== Pn) if (gt !== null) if (Yt) {
                if (k) if (S.layerUpdates.size > 0) {
                  const Mt = Pd(At.width, At.height, S.format, S.type);
                  for (const vt of S.layerUpdates) {
                    const Gt = At.data.subarray(vt * Mt / At.data.BYTES_PER_ELEMENT, (vt + 1) * Mt / At.data.BYTES_PER_ELEMENT);
                    e.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Z, 0, 0, vt, At.width, At.height, 1, gt, Gt);
                  }
                  S.clearLayerUpdates();
                } else e.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Z, 0, 0, 0, At.width, At.height, nt.depth, gt, At.data);
              } else e.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Z, Nt, At.width, At.height, nt.depth, 0, At.data, 0, 0);
              else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              else Yt ? k && e.texSubImage3D(n.TEXTURE_2D_ARRAY, Z, 0, 0, 0, At.width, At.height, nt.depth, gt, Dt, At.data) : e.texImage3D(n.TEXTURE_2D_ARRAY, Z, Nt, At.width, At.height, nt.depth, 0, gt, Dt, At.data);
            } else {
              Yt && _e && e.texStorage2D(n.TEXTURE_2D, yt, Nt, Qt[0].width, Qt[0].height);
              for (let Z = 0, tt = Qt.length; Z < tt; Z++) At = Qt[Z], S.format !== Pn ? gt !== null ? Yt ? k && e.compressedTexSubImage2D(n.TEXTURE_2D, Z, 0, 0, At.width, At.height, gt, At.data) : e.compressedTexImage2D(n.TEXTURE_2D, Z, Nt, At.width, At.height, 0, At.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Yt ? k && e.texSubImage2D(n.TEXTURE_2D, Z, 0, 0, At.width, At.height, gt, Dt, At.data) : e.texImage2D(n.TEXTURE_2D, Z, Nt, At.width, At.height, 0, gt, Dt, At.data);
            }
            else if (S.isDataArrayTexture) if (Yt) {
              if (_e && e.texStorage3D(n.TEXTURE_2D_ARRAY, yt, Nt, nt.width, nt.height, nt.depth), k) if (S.layerUpdates.size > 0) {
                const Z = Pd(nt.width, nt.height, S.format, S.type);
                for (const tt of S.layerUpdates) {
                  const Mt = nt.data.subarray(tt * Z / nt.data.BYTES_PER_ELEMENT, (tt + 1) * Z / nt.data.BYTES_PER_ELEMENT);
                  e.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, tt, nt.width, nt.height, 1, gt, Dt, Mt);
                }
                S.clearLayerUpdates();
              } else e.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, nt.width, nt.height, nt.depth, gt, Dt, nt.data);
            } else e.texImage3D(n.TEXTURE_2D_ARRAY, 0, Nt, nt.width, nt.height, nt.depth, 0, gt, Dt, nt.data);
            else if (S.isData3DTexture) Yt ? (_e && e.texStorage3D(n.TEXTURE_3D, yt, Nt, nt.width, nt.height, nt.depth), k && e.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, nt.width, nt.height, nt.depth, gt, Dt, nt.data)) : e.texImage3D(n.TEXTURE_3D, 0, Nt, nt.width, nt.height, nt.depth, 0, gt, Dt, nt.data);
            else if (S.isFramebufferTexture) {
              if (_e) if (Yt) e.texStorage2D(n.TEXTURE_2D, yt, Nt, nt.width, nt.height);
              else {
                let Z = nt.width, tt = nt.height;
                for (let Mt = 0; Mt < yt; Mt++) e.texImage2D(n.TEXTURE_2D, Mt, Nt, Z, tt, 0, gt, Dt, null), Z >>= 1, tt >>= 1;
              }
            } else if (Qt.length > 0) {
              if (Yt && _e) {
                const Z = Et(Qt[0]);
                e.texStorage2D(n.TEXTURE_2D, yt, Nt, Z.width, Z.height);
              }
              for (let Z = 0, tt = Qt.length; Z < tt; Z++) At = Qt[Z], Yt ? k && e.texSubImage2D(n.TEXTURE_2D, Z, 0, 0, gt, Dt, At) : e.texImage2D(n.TEXTURE_2D, Z, Nt, gt, Dt, At);
              S.generateMipmaps = false;
            } else if (Yt) {
              if (_e) {
                const Z = Et(nt);
                e.texStorage2D(n.TEXTURE_2D, yt, Nt, Z.width, Z.height);
              }
              k && e.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, gt, Dt, nt);
            } else e.texImage2D(n.TEXTURE_2D, 0, Nt, gt, Dt, nt);
            m(S) && p(K), _t.__version = X.version, S.onUpdate && S.onUpdate(S);
          }
          P.__version = S.version;
        }
        function J(P, S, B) {
          if (S.image.length !== 6) return;
          const K = ot(P, S), Q = S.source;
          e.bindTexture(n.TEXTURE_CUBE_MAP, P.__webglTexture, n.TEXTURE0 + B);
          const X = i.get(Q);
          if (Q.version !== X.__version || K === true) {
            e.activeTexture(n.TEXTURE0 + B);
            const _t = ee.getPrimaries(ee.workingColorSpace), pt = S.colorSpace === yi ? null : ee.getPrimaries(S.colorSpace), Pt = S.colorSpace === yi || _t === pt ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, S.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, S.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, S.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Pt);
            const kt = S.isCompressedTexture || S.image[0].isCompressedTexture, nt = S.image[0] && S.image[0].isDataTexture, gt = [];
            for (let tt = 0; tt < 6; tt++) !kt && !nt ? gt[tt] = _(S.image[tt], true, s.maxCubemapSize) : gt[tt] = nt ? S.image[tt].image : S.image[tt], gt[tt] = Rt(S, gt[tt]);
            const Dt = gt[0], Nt = r.convert(S.format, S.colorSpace), At = r.convert(S.type), Qt = w(S.internalFormat, Nt, At, S.colorSpace), Yt = S.isVideoTexture !== true, _e = X.__version === void 0 || K === true, k = Q.dataReady;
            let yt = C(S, Dt);
            ut(n.TEXTURE_CUBE_MAP, S);
            let Z;
            if (kt) {
              Yt && _e && e.texStorage2D(n.TEXTURE_CUBE_MAP, yt, Qt, Dt.width, Dt.height);
              for (let tt = 0; tt < 6; tt++) {
                Z = gt[tt].mipmaps;
                for (let Mt = 0; Mt < Z.length; Mt++) {
                  const vt = Z[Mt];
                  S.format !== Pn ? Nt !== null ? Yt ? k && e.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt, 0, 0, vt.width, vt.height, Nt, vt.data) : e.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt, Qt, vt.width, vt.height, 0, vt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Yt ? k && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt, 0, 0, vt.width, vt.height, Nt, At, vt.data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt, Qt, vt.width, vt.height, 0, Nt, At, vt.data);
                }
              }
            } else {
              if (Z = S.mipmaps, Yt && _e) {
                Z.length > 0 && yt++;
                const tt = Et(gt[0]);
                e.texStorage2D(n.TEXTURE_CUBE_MAP, yt, Qt, tt.width, tt.height);
              }
              for (let tt = 0; tt < 6; tt++) if (nt) {
                Yt ? k && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, 0, 0, gt[tt].width, gt[tt].height, Nt, At, gt[tt].data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, Qt, gt[tt].width, gt[tt].height, 0, Nt, At, gt[tt].data);
                for (let Mt = 0; Mt < Z.length; Mt++) {
                  const Gt = Z[Mt].image[tt].image;
                  Yt ? k && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt + 1, 0, 0, Gt.width, Gt.height, Nt, At, Gt.data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt + 1, Qt, Gt.width, Gt.height, 0, Nt, At, Gt.data);
                }
              } else {
                Yt ? k && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, 0, 0, Nt, At, gt[tt]) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, 0, Qt, Nt, At, gt[tt]);
                for (let Mt = 0; Mt < Z.length; Mt++) {
                  const vt = Z[Mt];
                  Yt ? k && e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt + 1, 0, 0, Nt, At, vt.image[tt]) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + tt, Mt + 1, Qt, Nt, At, vt.image[tt]);
                }
              }
            }
            m(S) && p(n.TEXTURE_CUBE_MAP), X.__version = Q.version, S.onUpdate && S.onUpdate(S);
          }
          P.__version = S.version;
        }
        function ct(P, S, B, K, Q, X) {
          const _t = r.convert(B.format, B.colorSpace), pt = r.convert(B.type), Pt = w(B.internalFormat, _t, pt, B.colorSpace), kt = i.get(S), nt = i.get(B);
          if (nt.__renderTarget = S, !kt.__hasExternalTextures) {
            const gt = Math.max(1, S.width >> X), Dt = Math.max(1, S.height >> X);
            Q === n.TEXTURE_3D || Q === n.TEXTURE_2D_ARRAY ? e.texImage3D(Q, X, Pt, gt, Dt, S.depth, 0, _t, pt, null) : e.texImage2D(Q, X, Pt, gt, Dt, 0, _t, pt, null);
          }
          e.bindFramebuffer(n.FRAMEBUFFER, P), Lt(S) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, K, Q, nt.__webglTexture, 0, ft(S)) : (Q === n.TEXTURE_2D || Q >= n.TEXTURE_CUBE_MAP_POSITIVE_X && Q <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, K, Q, nt.__webglTexture, X), e.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function ht(P, S, B) {
          if (n.bindRenderbuffer(n.RENDERBUFFER, P), S.depthBuffer) {
            const K = S.depthTexture, Q = K && K.isDepthTexture ? K.type : null, X = M(S.stencilBuffer, Q), _t = S.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, pt = ft(S);
            Lt(S) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, pt, X, S.width, S.height) : B ? n.renderbufferStorageMultisample(n.RENDERBUFFER, pt, X, S.width, S.height) : n.renderbufferStorage(n.RENDERBUFFER, X, S.width, S.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, _t, n.RENDERBUFFER, P);
          } else {
            const K = S.textures;
            for (let Q = 0; Q < K.length; Q++) {
              const X = K[Q], _t = r.convert(X.format, X.colorSpace), pt = r.convert(X.type), Pt = w(X.internalFormat, _t, pt, X.colorSpace), kt = ft(S);
              B && Lt(S) === false ? n.renderbufferStorageMultisample(n.RENDERBUFFER, kt, Pt, S.width, S.height) : Lt(S) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, kt, Pt, S.width, S.height) : n.renderbufferStorage(n.RENDERBUFFER, Pt, S.width, S.height);
            }
          }
          n.bindRenderbuffer(n.RENDERBUFFER, null);
        }
        function it(P, S) {
          if (S && S.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if (e.bindFramebuffer(n.FRAMEBUFFER, P), !(S.depthTexture && S.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          const K = i.get(S.depthTexture);
          K.__renderTarget = S, (!K.__webglTexture || S.depthTexture.image.width !== S.width || S.depthTexture.image.height !== S.height) && (S.depthTexture.image.width = S.width, S.depthTexture.image.height = S.height, S.depthTexture.needsUpdate = true), j(S.depthTexture, 0);
          const Q = K.__webglTexture, X = ft(S);
          if (S.depthTexture.format === Zr) Lt(S) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Q, 0, X) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Q, 0);
          else if (S.depthTexture.format === Qr) Lt(S) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Q, 0, X) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Q, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function St(P) {
          const S = i.get(P), B = P.isWebGLCubeRenderTarget === true;
          if (S.__boundDepthTexture !== P.depthTexture) {
            const K = P.depthTexture;
            if (S.__depthDisposeCallback && S.__depthDisposeCallback(), K) {
              const Q = () => {
                delete S.__boundDepthTexture, delete S.__depthDisposeCallback, K.removeEventListener("dispose", Q);
              };
              K.addEventListener("dispose", Q), S.__depthDisposeCallback = Q;
            }
            S.__boundDepthTexture = K;
          }
          if (P.depthTexture && !S.__autoAllocateDepthBuffer) {
            if (B) throw new Error("target.depthTexture not supported in Cube render targets");
            const K = P.texture.mipmaps;
            K && K.length > 0 ? it(S.__webglFramebuffer[0], P) : it(S.__webglFramebuffer, P);
          } else if (B) {
            S.__webglDepthbuffer = [];
            for (let K = 0; K < 6; K++) if (e.bindFramebuffer(n.FRAMEBUFFER, S.__webglFramebuffer[K]), S.__webglDepthbuffer[K] === void 0) S.__webglDepthbuffer[K] = n.createRenderbuffer(), ht(S.__webglDepthbuffer[K], P, false);
            else {
              const Q = P.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, X = S.__webglDepthbuffer[K];
              n.bindRenderbuffer(n.RENDERBUFFER, X), n.framebufferRenderbuffer(n.FRAMEBUFFER, Q, n.RENDERBUFFER, X);
            }
          } else {
            const K = P.texture.mipmaps;
            if (K && K.length > 0 ? e.bindFramebuffer(n.FRAMEBUFFER, S.__webglFramebuffer[0]) : e.bindFramebuffer(n.FRAMEBUFFER, S.__webglFramebuffer), S.__webglDepthbuffer === void 0) S.__webglDepthbuffer = n.createRenderbuffer(), ht(S.__webglDepthbuffer, P, false);
            else {
              const Q = P.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, X = S.__webglDepthbuffer;
              n.bindRenderbuffer(n.RENDERBUFFER, X), n.framebufferRenderbuffer(n.FRAMEBUFFER, Q, n.RENDERBUFFER, X);
            }
          }
          e.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function lt(P, S, B) {
          const K = i.get(P);
          S !== void 0 && ct(K.__webglFramebuffer, P, P.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), B !== void 0 && St(P);
        }
        function dt(P) {
          const S = P.texture, B = i.get(P), K = i.get(S);
          P.addEventListener("dispose", T);
          const Q = P.textures, X = P.isWebGLCubeRenderTarget === true, _t = Q.length > 1;
          if (_t || (K.__webglTexture === void 0 && (K.__webglTexture = n.createTexture()), K.__version = S.version, o.memory.textures++), X) {
            B.__webglFramebuffer = [];
            for (let pt = 0; pt < 6; pt++) if (S.mipmaps && S.mipmaps.length > 0) {
              B.__webglFramebuffer[pt] = [];
              for (let Pt = 0; Pt < S.mipmaps.length; Pt++) B.__webglFramebuffer[pt][Pt] = n.createFramebuffer();
            } else B.__webglFramebuffer[pt] = n.createFramebuffer();
          } else {
            if (S.mipmaps && S.mipmaps.length > 0) {
              B.__webglFramebuffer = [];
              for (let pt = 0; pt < S.mipmaps.length; pt++) B.__webglFramebuffer[pt] = n.createFramebuffer();
            } else B.__webglFramebuffer = n.createFramebuffer();
            if (_t) for (let pt = 0, Pt = Q.length; pt < Pt; pt++) {
              const kt = i.get(Q[pt]);
              kt.__webglTexture === void 0 && (kt.__webglTexture = n.createTexture(), o.memory.textures++);
            }
            if (P.samples > 0 && Lt(P) === false) {
              B.__webglMultisampledFramebuffer = n.createFramebuffer(), B.__webglColorRenderbuffer = [], e.bindFramebuffer(n.FRAMEBUFFER, B.__webglMultisampledFramebuffer);
              for (let pt = 0; pt < Q.length; pt++) {
                const Pt = Q[pt];
                B.__webglColorRenderbuffer[pt] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, B.__webglColorRenderbuffer[pt]);
                const kt = r.convert(Pt.format, Pt.colorSpace), nt = r.convert(Pt.type), gt = w(Pt.internalFormat, kt, nt, Pt.colorSpace, P.isXRRenderTarget === true), Dt = ft(P);
                n.renderbufferStorageMultisample(n.RENDERBUFFER, Dt, gt, P.width, P.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + pt, n.RENDERBUFFER, B.__webglColorRenderbuffer[pt]);
              }
              n.bindRenderbuffer(n.RENDERBUFFER, null), P.depthBuffer && (B.__webglDepthRenderbuffer = n.createRenderbuffer(), ht(B.__webglDepthRenderbuffer, P, true)), e.bindFramebuffer(n.FRAMEBUFFER, null);
            }
          }
          if (X) {
            e.bindTexture(n.TEXTURE_CUBE_MAP, K.__webglTexture), ut(n.TEXTURE_CUBE_MAP, S);
            for (let pt = 0; pt < 6; pt++) if (S.mipmaps && S.mipmaps.length > 0) for (let Pt = 0; Pt < S.mipmaps.length; Pt++) ct(B.__webglFramebuffer[pt][Pt], P, S, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + pt, Pt);
            else ct(B.__webglFramebuffer[pt], P, S, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + pt, 0);
            m(S) && p(n.TEXTURE_CUBE_MAP), e.unbindTexture();
          } else if (_t) {
            for (let pt = 0, Pt = Q.length; pt < Pt; pt++) {
              const kt = Q[pt], nt = i.get(kt);
              e.bindTexture(n.TEXTURE_2D, nt.__webglTexture), ut(n.TEXTURE_2D, kt), ct(B.__webglFramebuffer, P, kt, n.COLOR_ATTACHMENT0 + pt, n.TEXTURE_2D, 0), m(kt) && p(n.TEXTURE_2D);
            }
            e.unbindTexture();
          } else {
            let pt = n.TEXTURE_2D;
            if ((P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) && (pt = P.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), e.bindTexture(pt, K.__webglTexture), ut(pt, S), S.mipmaps && S.mipmaps.length > 0) for (let Pt = 0; Pt < S.mipmaps.length; Pt++) ct(B.__webglFramebuffer[Pt], P, S, n.COLOR_ATTACHMENT0, pt, Pt);
            else ct(B.__webglFramebuffer, P, S, n.COLOR_ATTACHMENT0, pt, 0);
            m(S) && p(pt), e.unbindTexture();
          }
          P.depthBuffer && St(P);
        }
        function wt(P) {
          const S = P.textures;
          for (let B = 0, K = S.length; B < K; B++) {
            const Q = S[B];
            if (m(Q)) {
              const X = y(P), _t = i.get(Q).__webglTexture;
              e.bindTexture(X, _t), p(X), e.unbindTexture();
            }
          }
        }
        const bt = [], D = [];
        function zt(P) {
          if (P.samples > 0) {
            if (Lt(P) === false) {
              const S = P.textures, B = P.width, K = P.height;
              let Q = n.COLOR_BUFFER_BIT;
              const X = P.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, _t = i.get(P), pt = S.length > 1;
              if (pt) for (let kt = 0; kt < S.length; kt++) e.bindFramebuffer(n.FRAMEBUFFER, _t.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + kt, n.RENDERBUFFER, null), e.bindFramebuffer(n.FRAMEBUFFER, _t.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + kt, n.TEXTURE_2D, null, 0);
              e.bindFramebuffer(n.READ_FRAMEBUFFER, _t.__webglMultisampledFramebuffer);
              const Pt = P.texture.mipmaps;
              Pt && Pt.length > 0 ? e.bindFramebuffer(n.DRAW_FRAMEBUFFER, _t.__webglFramebuffer[0]) : e.bindFramebuffer(n.DRAW_FRAMEBUFFER, _t.__webglFramebuffer);
              for (let kt = 0; kt < S.length; kt++) {
                if (P.resolveDepthBuffer && (P.depthBuffer && (Q |= n.DEPTH_BUFFER_BIT), P.stencilBuffer && P.resolveStencilBuffer && (Q |= n.STENCIL_BUFFER_BIT)), pt) {
                  n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, _t.__webglColorRenderbuffer[kt]);
                  const nt = i.get(S[kt]).__webglTexture;
                  n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, nt, 0);
                }
                n.blitFramebuffer(0, 0, B, K, 0, 0, B, K, Q, n.NEAREST), l === true && (bt.length = 0, D.length = 0, bt.push(n.COLOR_ATTACHMENT0 + kt), P.depthBuffer && P.resolveDepthBuffer === false && (bt.push(X), D.push(X), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, D)), n.invalidateFramebuffer(n.READ_FRAMEBUFFER, bt));
              }
              if (e.bindFramebuffer(n.READ_FRAMEBUFFER, null), e.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), pt) for (let kt = 0; kt < S.length; kt++) {
                e.bindFramebuffer(n.FRAMEBUFFER, _t.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + kt, n.RENDERBUFFER, _t.__webglColorRenderbuffer[kt]);
                const nt = i.get(S[kt]).__webglTexture;
                e.bindFramebuffer(n.FRAMEBUFFER, _t.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + kt, n.TEXTURE_2D, nt, 0);
              }
              e.bindFramebuffer(n.DRAW_FRAMEBUFFER, _t.__webglMultisampledFramebuffer);
            } else if (P.depthBuffer && P.resolveDepthBuffer === false && l) {
              const S = P.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
              n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [
                S
              ]);
            }
          }
        }
        function ft(P) {
          return Math.min(s.maxSamples, P.samples);
        }
        function Lt(P) {
          const S = i.get(P);
          return P.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === true && S.__useRenderToTexture !== false;
        }
        function st(P) {
          const S = o.render.frame;
          h.get(P) !== S && (h.set(P, S), P.update());
        }
        function Rt(P, S) {
          const B = P.colorSpace, K = P.format, Q = P.type;
          return P.isCompressedTexture === true || P.isVideoTexture === true || B !== er && B !== yi && (ee.getTransfer(B) === ue ? (K !== Pn || Q !== Vn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", B)), S;
        }
        function Et(P) {
          return typeof HTMLImageElement < "u" && P instanceof HTMLImageElement ? (c.width = P.naturalWidth || P.width, c.height = P.naturalHeight || P.height) : typeof VideoFrame < "u" && P instanceof VideoFrame ? (c.width = P.displayWidth, c.height = P.displayHeight) : (c.width = P.width, c.height = P.height), c;
        }
        this.allocateTextureUnit = I, this.resetTextureUnits = L, this.setTexture2D = j, this.setTexture2DArray = z, this.setTexture3D = V, this.setTextureCube = U, this.rebindTextures = lt, this.setupRenderTarget = dt, this.updateRenderTargetMipmap = wt, this.updateMultisampleRenderTarget = zt, this.setupDepthRenderbuffer = St, this.setupFrameBufferTexture = ct, this.useMultisampledRTT = Lt;
      }
      function ZS(n, t) {
        function e(i, s = yi) {
          let r;
          const o = ee.getTransfer(s);
          if (i === Vn) return n.UNSIGNED_BYTE;
          if (i === Hh) return n.UNSIGNED_SHORT_4_4_4_4;
          if (i === Vh) return n.UNSIGNED_SHORT_5_5_5_1;
          if (i === Sm) return n.UNSIGNED_INT_5_9_9_9_REV;
          if (i === vm) return n.BYTE;
          if (i === Mm) return n.SHORT;
          if (i === $r) return n.UNSIGNED_SHORT;
          if (i === zh) return n.INT;
          if (i === os) return n.UNSIGNED_INT;
          if (i === si) return n.FLOAT;
          if (i === oo) return n.HALF_FLOAT;
          if (i === wm) return n.ALPHA;
          if (i === Em) return n.RGB;
          if (i === Pn) return n.RGBA;
          if (i === Zr) return n.DEPTH_COMPONENT;
          if (i === Qr) return n.DEPTH_STENCIL;
          if (i === Tm) return n.RED;
          if (i === Wh) return n.RED_INTEGER;
          if (i === Am) return n.RG;
          if (i === Gh) return n.RG_INTEGER;
          if (i === Xh) return n.RGBA_INTEGER;
          if (i === ba || i === ya || i === va || i === Ma) if (o === ue) if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
            if (i === ba) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (i === ya) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (i === va) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (i === Ma) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else return null;
          else if (r = t.get("WEBGL_compressed_texture_s3tc"), r !== null) {
            if (i === ba) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === ya) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === va) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === Ma) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else return null;
          if (i === Fc || i === Nc || i === Uc || i === Bc) if (r = t.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
            if (i === Fc) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (i === Nc) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === Uc) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === Bc) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else return null;
          if (i === zc || i === Hc || i === Vc) if (r = t.get("WEBGL_compressed_texture_etc"), r !== null) {
            if (i === zc || i === Hc) return o === ue ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
            if (i === Vc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
          } else return null;
          if (i === Wc || i === Gc || i === Xc || i === Yc || i === jc || i === qc || i === $c || i === Kc || i === Zc || i === Qc || i === Jc || i === th || i === eh || i === nh) if (r = t.get("WEBGL_compressed_texture_astc"), r !== null) {
            if (i === Wc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (i === Gc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (i === Xc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (i === Yc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (i === jc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (i === qc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (i === $c) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (i === Kc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (i === Zc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (i === Qc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (i === Jc) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (i === th) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (i === eh) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (i === nh) return o === ue ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
          } else return null;
          if (i === Sa || i === ih || i === sh) if (r = t.get("EXT_texture_compression_bptc"), r !== null) {
            if (i === Sa) return o === ue ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            if (i === ih) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
            if (i === sh) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
          } else return null;
          if (i === Cm || i === rh || i === oh || i === ah) if (r = t.get("EXT_texture_compression_rgtc"), r !== null) {
            if (i === Sa) return r.COMPRESSED_RED_RGTC1_EXT;
            if (i === rh) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (i === oh) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (i === ah) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else return null;
          return i === Kr ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null;
        }
        return {
          convert: e
        };
      }
      const QS = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, JS = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
      class tw {
        constructor() {
          this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(t, e, i) {
          if (this.texture === null) {
            const s = new tn(), r = t.properties.get(s);
            r.__webglTexture = e.texture, (e.depthNear !== i.depthNear || e.depthFar !== i.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = s;
          }
        }
        getMesh(t) {
          if (this.texture !== null && this.mesh === null) {
            const e = t.cameras[0].viewport, i = new Li({
              vertexShader: QS,
              fragmentShader: JS,
              uniforms: {
                depthColor: {
                  value: this.texture
                },
                depthWidth: {
                  value: e.z
                },
                depthHeight: {
                  value: e.w
                }
              }
            });
            this.mesh = new Dn(new lo(20, 20), i);
          }
          return this.mesh;
        }
        reset() {
          this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class ew extends fs {
        constructor(t, e) {
          super();
          const i = this;
          let s = null, r = 1, o = null, a = "local-floor", l = 1, c = null, h = null, u = null, d = null, f = null, g = null;
          const _ = new tw(), m = e.getContextAttributes();
          let p = null, y = null;
          const w = [], M = [], C = new Ft();
          let R = null;
          const T = new mn();
          T.viewport = new pe();
          const v = new mn();
          v.viewport = new pe();
          const x = [
            T,
            v
          ], b = new bb();
          let A = null, L = null;
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(W) {
            let J = w[W];
            return J === void 0 && (J = new Vl(), w[W] = J), J.getTargetRaySpace();
          }, this.getControllerGrip = function(W) {
            let J = w[W];
            return J === void 0 && (J = new Vl(), w[W] = J), J.getGripSpace();
          }, this.getHand = function(W) {
            let J = w[W];
            return J === void 0 && (J = new Vl(), w[W] = J), J.getHandSpace();
          };
          function I(W) {
            const J = M.indexOf(W.inputSource);
            if (J === -1) return;
            const ct = w[J];
            ct !== void 0 && (ct.update(W.inputSource, W.frame, c || o), ct.dispatchEvent({
              type: W.type,
              data: W.inputSource
            }));
          }
          function H() {
            s.removeEventListener("select", I), s.removeEventListener("selectstart", I), s.removeEventListener("selectend", I), s.removeEventListener("squeeze", I), s.removeEventListener("squeezestart", I), s.removeEventListener("squeezeend", I), s.removeEventListener("end", H), s.removeEventListener("inputsourceschange", j);
            for (let W = 0; W < w.length; W++) {
              const J = M[W];
              J !== null && (M[W] = null, w[W].disconnect(J));
            }
            A = null, L = null, _.reset(), t.setRenderTarget(p), f = null, d = null, u = null, s = null, y = null, ot.stop(), i.isPresenting = false, t.setPixelRatio(R), t.setSize(C.width, C.height, false), i.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(W) {
            r = W, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(W) {
            a = W, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return c || o;
          }, this.setReferenceSpace = function(W) {
            c = W;
          }, this.getBaseLayer = function() {
            return d !== null ? d : f;
          }, this.getBinding = function() {
            return u;
          }, this.getFrame = function() {
            return g;
          }, this.getSession = function() {
            return s;
          }, this.setSession = async function(W) {
            if (s = W, s !== null) {
              if (p = t.getRenderTarget(), s.addEventListener("select", I), s.addEventListener("selectstart", I), s.addEventListener("selectend", I), s.addEventListener("squeeze", I), s.addEventListener("squeezestart", I), s.addEventListener("squeezeend", I), s.addEventListener("end", H), s.addEventListener("inputsourceschange", j), m.xrCompatible !== true && await e.makeXRCompatible(), R = t.getPixelRatio(), t.getSize(C), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                let ct = null, ht = null, it = null;
                m.depth && (it = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, ct = m.stencil ? Qr : Zr, ht = m.stencil ? Kr : os);
                const St = {
                  colorFormat: e.RGBA8,
                  depthFormat: it,
                  scaleFactor: r
                };
                u = new XRWebGLBinding(s, e), d = u.createProjectionLayer(St), s.updateRenderState({
                  layers: [
                    d
                  ]
                }), t.setPixelRatio(1), t.setSize(d.textureWidth, d.textureHeight, false), y = new as(d.textureWidth, d.textureHeight, {
                  format: Pn,
                  type: Vn,
                  depthTexture: new Hm(d.textureWidth, d.textureHeight, ht, void 0, void 0, void 0, void 0, void 0, void 0, ct),
                  stencilBuffer: m.stencil,
                  colorSpace: t.outputColorSpace,
                  samples: m.antialias ? 4 : 0,
                  resolveDepthBuffer: d.ignoreDepthValues === false,
                  resolveStencilBuffer: d.ignoreDepthValues === false
                });
              } else {
                const ct = {
                  antialias: m.antialias,
                  alpha: true,
                  depth: m.depth,
                  stencil: m.stencil,
                  framebufferScaleFactor: r
                };
                f = new XRWebGLLayer(s, e, ct), s.updateRenderState({
                  baseLayer: f
                }), t.setPixelRatio(1), t.setSize(f.framebufferWidth, f.framebufferHeight, false), y = new as(f.framebufferWidth, f.framebufferHeight, {
                  format: Pn,
                  type: Vn,
                  colorSpace: t.outputColorSpace,
                  stencilBuffer: m.stencil,
                  resolveDepthBuffer: f.ignoreDepthValues === false,
                  resolveStencilBuffer: f.ignoreDepthValues === false
                });
              }
              y.isXRRenderTarget = true, this.setFoveation(l), c = null, o = await s.requestReferenceSpace(a), ot.setContext(s), ot.start(), i.isPresenting = true, i.dispatchEvent({
                type: "sessionstart"
              });
            }
          }, this.getEnvironmentBlendMode = function() {
            if (s !== null) return s.environmentBlendMode;
          }, this.getDepthTexture = function() {
            return _.getDepthTexture();
          };
          function j(W) {
            for (let J = 0; J < W.removed.length; J++) {
              const ct = W.removed[J], ht = M.indexOf(ct);
              ht >= 0 && (M[ht] = null, w[ht].disconnect(ct));
            }
            for (let J = 0; J < W.added.length; J++) {
              const ct = W.added[J];
              let ht = M.indexOf(ct);
              if (ht === -1) {
                for (let St = 0; St < w.length; St++) if (St >= M.length) {
                  M.push(ct), ht = St;
                  break;
                } else if (M[St] === null) {
                  M[St] = ct, ht = St;
                  break;
                }
                if (ht === -1) break;
              }
              const it = w[ht];
              it && it.connect(ct);
            }
          }
          const z = new O(), V = new O();
          function U(W, J, ct) {
            z.setFromMatrixPosition(J.matrixWorld), V.setFromMatrixPosition(ct.matrixWorld);
            const ht = z.distanceTo(V), it = J.projectionMatrix.elements, St = ct.projectionMatrix.elements, lt = it[14] / (it[10] - 1), dt = it[14] / (it[10] + 1), wt = (it[9] + 1) / it[5], bt = (it[9] - 1) / it[5], D = (it[8] - 1) / it[0], zt = (St[8] + 1) / St[0], ft = lt * D, Lt = lt * zt, st = ht / (-D + zt), Rt = st * -D;
            if (J.matrixWorld.decompose(W.position, W.quaternion, W.scale), W.translateX(Rt), W.translateZ(st), W.matrixWorld.compose(W.position, W.quaternion, W.scale), W.matrixWorldInverse.copy(W.matrixWorld).invert(), it[10] === -1) W.projectionMatrix.copy(J.projectionMatrix), W.projectionMatrixInverse.copy(J.projectionMatrixInverse);
            else {
              const Et = lt + st, P = dt + st, S = ft - Rt, B = Lt + (ht - Rt), K = wt * dt / P * Et, Q = bt * dt / P * Et;
              W.projectionMatrix.makePerspective(S, B, K, Q, Et, P), W.projectionMatrixInverse.copy(W.projectionMatrix).invert();
            }
          }
          function q(W, J) {
            J === null ? W.matrixWorld.copy(W.matrix) : W.matrixWorld.multiplyMatrices(J.matrixWorld, W.matrix), W.matrixWorldInverse.copy(W.matrixWorld).invert();
          }
          this.updateCamera = function(W) {
            if (s === null) return;
            let J = W.near, ct = W.far;
            _.texture !== null && (_.depthNear > 0 && (J = _.depthNear), _.depthFar > 0 && (ct = _.depthFar)), b.near = v.near = T.near = J, b.far = v.far = T.far = ct, (A !== b.near || L !== b.far) && (s.updateRenderState({
              depthNear: b.near,
              depthFar: b.far
            }), A = b.near, L = b.far), T.layers.mask = W.layers.mask | 2, v.layers.mask = W.layers.mask | 4, b.layers.mask = T.layers.mask | v.layers.mask;
            const ht = W.parent, it = b.cameras;
            q(b, ht);
            for (let St = 0; St < it.length; St++) q(it[St], ht);
            it.length === 2 ? U(b, T, v) : b.projectionMatrix.copy(T.projectionMatrix), rt(W, b, ht);
          };
          function rt(W, J, ct) {
            ct === null ? W.matrix.copy(J.matrixWorld) : (W.matrix.copy(ct.matrixWorld), W.matrix.invert(), W.matrix.multiply(J.matrixWorld)), W.matrix.decompose(W.position, W.quaternion, W.scale), W.updateMatrixWorld(true), W.projectionMatrix.copy(J.projectionMatrix), W.projectionMatrixInverse.copy(J.projectionMatrixInverse), W.isPerspectiveCamera && (W.fov = ch * 2 * Math.atan(1 / W.projectionMatrix.elements[5]), W.zoom = 1);
          }
          this.getCamera = function() {
            return b;
          }, this.getFoveation = function() {
            if (!(d === null && f === null)) return l;
          }, this.setFoveation = function(W) {
            l = W, d !== null && (d.fixedFoveation = W), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = W);
          }, this.hasDepthSensing = function() {
            return _.texture !== null;
          }, this.getDepthSensingMesh = function() {
            return _.getMesh(b);
          };
          let et = null;
          function ut(W, J) {
            if (h = J.getViewerPose(c || o), g = J, h !== null) {
              const ct = h.views;
              f !== null && (t.setRenderTargetFramebuffer(y, f.framebuffer), t.setRenderTarget(y));
              let ht = false;
              ct.length !== b.cameras.length && (b.cameras.length = 0, ht = true);
              for (let lt = 0; lt < ct.length; lt++) {
                const dt = ct[lt];
                let wt = null;
                if (f !== null) wt = f.getViewport(dt);
                else {
                  const D = u.getViewSubImage(d, dt);
                  wt = D.viewport, lt === 0 && (t.setRenderTargetTextures(y, D.colorTexture, D.depthStencilTexture), t.setRenderTarget(y));
                }
                let bt = x[lt];
                bt === void 0 && (bt = new mn(), bt.layers.enable(lt), bt.viewport = new pe(), x[lt] = bt), bt.matrix.fromArray(dt.transform.matrix), bt.matrix.decompose(bt.position, bt.quaternion, bt.scale), bt.projectionMatrix.fromArray(dt.projectionMatrix), bt.projectionMatrixInverse.copy(bt.projectionMatrix).invert(), bt.viewport.set(wt.x, wt.y, wt.width, wt.height), lt === 0 && (b.matrix.copy(bt.matrix), b.matrix.decompose(b.position, b.quaternion, b.scale)), ht === true && b.cameras.push(bt);
              }
              const it = s.enabledFeatures;
              if (it && it.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && u) {
                const lt = u.getDepthInformation(ct[0]);
                lt && lt.isValid && lt.texture && _.init(t, lt, s.renderState);
              }
            }
            for (let ct = 0; ct < w.length; ct++) {
              const ht = M[ct], it = w[ct];
              ht !== null && it !== void 0 && it.update(ht, J, c || o);
            }
            et && et(W, J), J.detectedPlanes && i.dispatchEvent({
              type: "planesdetected",
              data: J
            }), g = null;
          }
          const ot = new Wm();
          ot.setAnimationLoop(ut), this.setAnimationLoop = function(W) {
            et = W;
          }, this.dispose = function() {
          };
        }
      }
      const Xi = new Wn(), nw = new ye();
      function iw(n, t) {
        function e(m, p) {
          m.matrixAutoUpdate === true && m.updateMatrix(), p.value.copy(m.matrix);
        }
        function i(m, p) {
          p.color.getRGB(m.fogColor.value, Nm(n)), p.isFog ? (m.fogNear.value = p.near, m.fogFar.value = p.far) : p.isFogExp2 && (m.fogDensity.value = p.density);
        }
        function s(m, p, y, w, M) {
          p.isMeshBasicMaterial || p.isMeshLambertMaterial ? r(m, p) : p.isMeshToonMaterial ? (r(m, p), u(m, p)) : p.isMeshPhongMaterial ? (r(m, p), h(m, p)) : p.isMeshStandardMaterial ? (r(m, p), d(m, p), p.isMeshPhysicalMaterial && f(m, p, M)) : p.isMeshMatcapMaterial ? (r(m, p), g(m, p)) : p.isMeshDepthMaterial ? r(m, p) : p.isMeshDistanceMaterial ? (r(m, p), _(m, p)) : p.isMeshNormalMaterial ? r(m, p) : p.isLineBasicMaterial ? (o(m, p), p.isLineDashedMaterial && a(m, p)) : p.isPointsMaterial ? l(m, p, y, w) : p.isSpriteMaterial ? c(m, p) : p.isShadowMaterial ? (m.color.value.copy(p.color), m.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = false);
        }
        function r(m, p) {
          m.opacity.value = p.opacity, p.color && m.diffuse.value.copy(p.color), p.emissive && m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (m.map.value = p.map, e(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, e(p.alphaMap, m.alphaMapTransform)), p.bumpMap && (m.bumpMap.value = p.bumpMap, e(p.bumpMap, m.bumpMapTransform), m.bumpScale.value = p.bumpScale, p.side === an && (m.bumpScale.value *= -1)), p.normalMap && (m.normalMap.value = p.normalMap, e(p.normalMap, m.normalMapTransform), m.normalScale.value.copy(p.normalScale), p.side === an && m.normalScale.value.negate()), p.displacementMap && (m.displacementMap.value = p.displacementMap, e(p.displacementMap, m.displacementMapTransform), m.displacementScale.value = p.displacementScale, m.displacementBias.value = p.displacementBias), p.emissiveMap && (m.emissiveMap.value = p.emissiveMap, e(p.emissiveMap, m.emissiveMapTransform)), p.specularMap && (m.specularMap.value = p.specularMap, e(p.specularMap, m.specularMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
          const y = t.get(p), w = y.envMap, M = y.envMapRotation;
          w && (m.envMap.value = w, Xi.copy(M), Xi.x *= -1, Xi.y *= -1, Xi.z *= -1, w.isCubeTexture && w.isRenderTargetTexture === false && (Xi.y *= -1, Xi.z *= -1), m.envMapRotation.value.setFromMatrix4(nw.makeRotationFromEuler(Xi)), m.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === false ? -1 : 1, m.reflectivity.value = p.reflectivity, m.ior.value = p.ior, m.refractionRatio.value = p.refractionRatio), p.lightMap && (m.lightMap.value = p.lightMap, m.lightMapIntensity.value = p.lightMapIntensity, e(p.lightMap, m.lightMapTransform)), p.aoMap && (m.aoMap.value = p.aoMap, m.aoMapIntensity.value = p.aoMapIntensity, e(p.aoMap, m.aoMapTransform));
        }
        function o(m, p) {
          m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, p.map && (m.map.value = p.map, e(p.map, m.mapTransform));
        }
        function a(m, p) {
          m.dashSize.value = p.dashSize, m.totalSize.value = p.dashSize + p.gapSize, m.scale.value = p.scale;
        }
        function l(m, p, y, w) {
          m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.size.value = p.size * y, m.scale.value = w * 0.5, p.map && (m.map.value = p.map, e(p.map, m.uvTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, e(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        }
        function c(m, p) {
          m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.rotation.value = p.rotation, p.map && (m.map.value = p.map, e(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, e(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        }
        function h(m, p) {
          m.specular.value.copy(p.specular), m.shininess.value = Math.max(p.shininess, 1e-4);
        }
        function u(m, p) {
          p.gradientMap && (m.gradientMap.value = p.gradientMap);
        }
        function d(m, p) {
          m.metalness.value = p.metalness, p.metalnessMap && (m.metalnessMap.value = p.metalnessMap, e(p.metalnessMap, m.metalnessMapTransform)), m.roughness.value = p.roughness, p.roughnessMap && (m.roughnessMap.value = p.roughnessMap, e(p.roughnessMap, m.roughnessMapTransform)), p.envMap && (m.envMapIntensity.value = p.envMapIntensity);
        }
        function f(m, p, y) {
          m.ior.value = p.ior, p.sheen > 0 && (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), m.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap, e(p.sheenColorMap, m.sheenColorMapTransform)), p.sheenRoughnessMap && (m.sheenRoughnessMap.value = p.sheenRoughnessMap, e(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))), p.clearcoat > 0 && (m.clearcoat.value = p.clearcoat, m.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap, e(p.clearcoatMap, m.clearcoatMapTransform)), p.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, e(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (m.clearcoatNormalMap.value = p.clearcoatNormalMap, e(p.clearcoatNormalMap, m.clearcoatNormalMapTransform), m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === an && m.clearcoatNormalScale.value.negate())), p.dispersion > 0 && (m.dispersion.value = p.dispersion), p.iridescence > 0 && (m.iridescence.value = p.iridescence, m.iridescenceIOR.value = p.iridescenceIOR, m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (m.iridescenceMap.value = p.iridescenceMap, e(p.iridescenceMap, m.iridescenceMapTransform)), p.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = p.iridescenceThicknessMap, e(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))), p.transmission > 0 && (m.transmission.value = p.transmission, m.transmissionSamplerMap.value = y.texture, m.transmissionSamplerSize.value.set(y.width, y.height), p.transmissionMap && (m.transmissionMap.value = p.transmissionMap, e(p.transmissionMap, m.transmissionMapTransform)), m.thickness.value = p.thickness, p.thicknessMap && (m.thicknessMap.value = p.thicknessMap, e(p.thicknessMap, m.thicknessMapTransform)), m.attenuationDistance.value = p.attenuationDistance, m.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (m.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (m.anisotropyMap.value = p.anisotropyMap, e(p.anisotropyMap, m.anisotropyMapTransform))), m.specularIntensity.value = p.specularIntensity, m.specularColor.value.copy(p.specularColor), p.specularColorMap && (m.specularColorMap.value = p.specularColorMap, e(p.specularColorMap, m.specularColorMapTransform)), p.specularIntensityMap && (m.specularIntensityMap.value = p.specularIntensityMap, e(p.specularIntensityMap, m.specularIntensityMapTransform));
        }
        function g(m, p) {
          p.matcap && (m.matcap.value = p.matcap);
        }
        function _(m, p) {
          const y = t.get(p).light;
          m.referencePosition.value.setFromMatrixPosition(y.matrixWorld), m.nearDistance.value = y.shadow.camera.near, m.farDistance.value = y.shadow.camera.far;
        }
        return {
          refreshFogUniforms: i,
          refreshMaterialUniforms: s
        };
      }
      function sw(n, t, e, i) {
        let s = {}, r = {}, o = [];
        const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
        function l(y, w) {
          const M = w.program;
          i.uniformBlockBinding(y, M);
        }
        function c(y, w) {
          let M = s[y.id];
          M === void 0 && (g(y), M = h(y), s[y.id] = M, y.addEventListener("dispose", m));
          const C = w.program;
          i.updateUBOMapping(y, C);
          const R = t.render.frame;
          r[y.id] !== R && (d(y), r[y.id] = R);
        }
        function h(y) {
          const w = u();
          y.__bindingPointIndex = w;
          const M = n.createBuffer(), C = y.__size, R = y.usage;
          return n.bindBuffer(n.UNIFORM_BUFFER, M), n.bufferData(n.UNIFORM_BUFFER, C, R), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, w, M), M;
        }
        function u() {
          for (let y = 0; y < a; y++) if (o.indexOf(y) === -1) return o.push(y), y;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function d(y) {
          const w = s[y.id], M = y.uniforms, C = y.__cache;
          n.bindBuffer(n.UNIFORM_BUFFER, w);
          for (let R = 0, T = M.length; R < T; R++) {
            const v = Array.isArray(M[R]) ? M[R] : [
              M[R]
            ];
            for (let x = 0, b = v.length; x < b; x++) {
              const A = v[x];
              if (f(A, R, x, C) === true) {
                const L = A.__offset, I = Array.isArray(A.value) ? A.value : [
                  A.value
                ];
                let H = 0;
                for (let j = 0; j < I.length; j++) {
                  const z = I[j], V = _(z);
                  typeof z == "number" || typeof z == "boolean" ? (A.__data[0] = z, n.bufferSubData(n.UNIFORM_BUFFER, L + H, A.__data)) : z.isMatrix3 ? (A.__data[0] = z.elements[0], A.__data[1] = z.elements[1], A.__data[2] = z.elements[2], A.__data[3] = 0, A.__data[4] = z.elements[3], A.__data[5] = z.elements[4], A.__data[6] = z.elements[5], A.__data[7] = 0, A.__data[8] = z.elements[6], A.__data[9] = z.elements[7], A.__data[10] = z.elements[8], A.__data[11] = 0) : (z.toArray(A.__data, H), H += V.storage / Float32Array.BYTES_PER_ELEMENT);
                }
                n.bufferSubData(n.UNIFORM_BUFFER, L, A.__data);
              }
            }
          }
          n.bindBuffer(n.UNIFORM_BUFFER, null);
        }
        function f(y, w, M, C) {
          const R = y.value, T = w + "_" + M;
          if (C[T] === void 0) return typeof R == "number" || typeof R == "boolean" ? C[T] = R : C[T] = R.clone(), true;
          {
            const v = C[T];
            if (typeof R == "number" || typeof R == "boolean") {
              if (v !== R) return C[T] = R, true;
            } else if (v.equals(R) === false) return v.copy(R), true;
          }
          return false;
        }
        function g(y) {
          const w = y.uniforms;
          let M = 0;
          const C = 16;
          for (let T = 0, v = w.length; T < v; T++) {
            const x = Array.isArray(w[T]) ? w[T] : [
              w[T]
            ];
            for (let b = 0, A = x.length; b < A; b++) {
              const L = x[b], I = Array.isArray(L.value) ? L.value : [
                L.value
              ];
              for (let H = 0, j = I.length; H < j; H++) {
                const z = I[H], V = _(z), U = M % C, q = U % V.boundary, rt = U + q;
                M += q, rt !== 0 && C - rt < V.storage && (M += C - rt), L.__data = new Float32Array(V.storage / Float32Array.BYTES_PER_ELEMENT), L.__offset = M, M += V.storage;
              }
            }
          }
          const R = M % C;
          return R > 0 && (M += C - R), y.__size = M, y.__cache = {}, this;
        }
        function _(y) {
          const w = {
            boundary: 0,
            storage: 0
          };
          return typeof y == "number" || typeof y == "boolean" ? (w.boundary = 4, w.storage = 4) : y.isVector2 ? (w.boundary = 8, w.storage = 8) : y.isVector3 || y.isColor ? (w.boundary = 16, w.storage = 12) : y.isVector4 ? (w.boundary = 16, w.storage = 16) : y.isMatrix3 ? (w.boundary = 48, w.storage = 48) : y.isMatrix4 ? (w.boundary = 64, w.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), w;
        }
        function m(y) {
          const w = y.target;
          w.removeEventListener("dispose", m);
          const M = o.indexOf(w.__bindingPointIndex);
          o.splice(M, 1), n.deleteBuffer(s[w.id]), delete s[w.id], delete r[w.id];
        }
        function p() {
          for (const y in s) n.deleteBuffer(s[y]);
          o = [], s = {}, r = {};
        }
        return {
          bind: l,
          update: c,
          dispose: p
        };
      }
      class rw {
        constructor(t = {}) {
          const { canvas: e = Px(), context: i = null, depth: s = true, stencil: r = false, alpha: o = false, antialias: a = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: u = false, reverseDepthBuffer: d = false } = t;
          this.isWebGLRenderer = true;
          let f;
          if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            f = i.getContextAttributes().alpha;
          } else f = o;
          const g = new Uint32Array(4), _ = new Int32Array(4);
          let m = null, p = null;
          const y = [], w = [];
          this.domElement = e, this.debug = {
            checkShaderErrors: true,
            onShaderError: null
          }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.toneMapping = Ei, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
          const M = this;
          let C = false;
          this._outputColorSpace = Sn;
          let R = 0, T = 0, v = null, x = -1, b = null;
          const A = new pe(), L = new pe();
          let I = null;
          const H = new qt(0);
          let j = 0, z = e.width, V = e.height, U = 1, q = null, rt = null;
          const et = new pe(0, 0, z, V), ut = new pe(0, 0, z, V);
          let ot = false;
          const W = new $h();
          let J = false, ct = false;
          const ht = new ye(), it = new ye(), St = new O(), lt = new pe(), dt = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: true
          };
          let wt = false;
          function bt() {
            return v === null ? U : 1;
          }
          let D = i;
          function zt(E, F) {
            return e.getContext(E, F);
          }
          try {
            const E = {
              alpha: true,
              depth: s,
              stencil: r,
              antialias: a,
              premultipliedAlpha: l,
              preserveDrawingBuffer: c,
              powerPreference: h,
              failIfMajorPerformanceCaveat: u
            };
            if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Uh}`), e.addEventListener("webglcontextlost", tt, false), e.addEventListener("webglcontextrestored", Mt, false), e.addEventListener("webglcontextcreationerror", vt, false), D === null) {
              const F = "webgl2";
              if (D = zt(F, E), D === null) throw zt(F) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            }
          } catch (E) {
            throw console.error("THREE.WebGLRenderer: " + E.message), E;
          }
          let ft, Lt, st, Rt, Et, P, S, B, K, Q, X, _t, pt, Pt, kt, nt, gt, Dt, Nt, At, Qt, Yt, _e, k;
          function yt() {
            ft = new mM(D), ft.init(), Yt = new ZS(D, ft), Lt = new lM(D, ft, t, Yt), st = new $S(D, ft), Lt.reverseDepthBuffer && d && st.buffers.depth.setReversed(true), Rt = new xM(D), Et = new FS(), P = new KS(D, ft, st, Et, Lt, Yt, Rt), S = new hM(M), B = new pM(M), K = new wb(D), _e = new oM(D, K), Q = new gM(D, K, Rt, _e), X = new yM(D, Q, K, Rt), Nt = new bM(D, Lt, P), nt = new cM(Et), _t = new kS(M, S, B, ft, Lt, _e, nt), pt = new iw(M, Et), Pt = new US(), kt = new GS(ft), Dt = new rM(M, S, B, st, X, f, l), gt = new jS(M, X, Lt), k = new sw(D, Rt, Lt, st), At = new aM(D, ft, Rt), Qt = new _M(D, ft, Rt), Rt.programs = _t.programs, M.capabilities = Lt, M.extensions = ft, M.properties = Et, M.renderLists = Pt, M.shadowMap = gt, M.state = st, M.info = Rt;
          }
          yt();
          const Z = new ew(M, D);
          this.xr = Z, this.getContext = function() {
            return D;
          }, this.getContextAttributes = function() {
            return D.getContextAttributes();
          }, this.forceContextLoss = function() {
            const E = ft.get("WEBGL_lose_context");
            E && E.loseContext();
          }, this.forceContextRestore = function() {
            const E = ft.get("WEBGL_lose_context");
            E && E.restoreContext();
          }, this.getPixelRatio = function() {
            return U;
          }, this.setPixelRatio = function(E) {
            E !== void 0 && (U = E, this.setSize(z, V, false));
          }, this.getSize = function(E) {
            return E.set(z, V);
          }, this.setSize = function(E, F, G = true) {
            if (Z.isPresenting) {
              console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
              return;
            }
            z = E, V = F, e.width = Math.floor(E * U), e.height = Math.floor(F * U), G === true && (e.style.width = E + "px", e.style.height = F + "px"), this.setViewport(0, 0, E, F);
          }, this.getDrawingBufferSize = function(E) {
            return E.set(z * U, V * U).floor();
          }, this.setDrawingBufferSize = function(E, F, G) {
            z = E, V = F, U = G, e.width = Math.floor(E * G), e.height = Math.floor(F * G), this.setViewport(0, 0, E, F);
          }, this.getCurrentViewport = function(E) {
            return E.copy(A);
          }, this.getViewport = function(E) {
            return E.copy(et);
          }, this.setViewport = function(E, F, G, Y) {
            E.isVector4 ? et.set(E.x, E.y, E.z, E.w) : et.set(E, F, G, Y), st.viewport(A.copy(et).multiplyScalar(U).round());
          }, this.getScissor = function(E) {
            return E.copy(ut);
          }, this.setScissor = function(E, F, G, Y) {
            E.isVector4 ? ut.set(E.x, E.y, E.z, E.w) : ut.set(E, F, G, Y), st.scissor(L.copy(ut).multiplyScalar(U).round());
          }, this.getScissorTest = function() {
            return ot;
          }, this.setScissorTest = function(E) {
            st.setScissorTest(ot = E);
          }, this.setOpaqueSort = function(E) {
            q = E;
          }, this.setTransparentSort = function(E) {
            rt = E;
          }, this.getClearColor = function(E) {
            return E.copy(Dt.getClearColor());
          }, this.setClearColor = function() {
            Dt.setClearColor(...arguments);
          }, this.getClearAlpha = function() {
            return Dt.getClearAlpha();
          }, this.setClearAlpha = function() {
            Dt.setClearAlpha(...arguments);
          }, this.clear = function(E = true, F = true, G = true) {
            let Y = 0;
            if (E) {
              let N = false;
              if (v !== null) {
                const at = v.texture.format;
                N = at === Xh || at === Gh || at === Wh;
              }
              if (N) {
                const at = v.texture.type, xt = at === Vn || at === os || at === $r || at === Kr || at === Hh || at === Vh, Tt = Dt.getClearColor(), Ct = Dt.getClearAlpha(), Ht = Tt.r, Bt = Tt.g, It = Tt.b;
                xt ? (g[0] = Ht, g[1] = Bt, g[2] = It, g[3] = Ct, D.clearBufferuiv(D.COLOR, 0, g)) : (_[0] = Ht, _[1] = Bt, _[2] = It, _[3] = Ct, D.clearBufferiv(D.COLOR, 0, _));
              } else Y |= D.COLOR_BUFFER_BIT;
            }
            F && (Y |= D.DEPTH_BUFFER_BIT), G && (Y |= D.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), D.clear(Y);
          }, this.clearColor = function() {
            this.clear(true, false, false);
          }, this.clearDepth = function() {
            this.clear(false, true, false);
          }, this.clearStencil = function() {
            this.clear(false, false, true);
          }, this.dispose = function() {
            e.removeEventListener("webglcontextlost", tt, false), e.removeEventListener("webglcontextrestored", Mt, false), e.removeEventListener("webglcontextcreationerror", vt, false), Dt.dispose(), Pt.dispose(), kt.dispose(), Et.dispose(), S.dispose(), B.dispose(), X.dispose(), _e.dispose(), k.dispose(), _t.dispose(), Z.dispose(), Z.removeEventListener("sessionstart", Ru), Z.removeEventListener("sessionend", Pu), Ui.stop();
          };
          function tt(E) {
            E.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = true;
          }
          function Mt() {
            console.log("THREE.WebGLRenderer: Context Restored."), C = false;
            const E = Rt.autoReset, F = gt.enabled, G = gt.autoUpdate, Y = gt.needsUpdate, N = gt.type;
            yt(), Rt.autoReset = E, gt.enabled = F, gt.autoUpdate = G, gt.needsUpdate = Y, gt.type = N;
          }
          function vt(E) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", E.statusMessage);
          }
          function Gt(E) {
            const F = E.target;
            F.removeEventListener("dispose", Gt), we(F);
          }
          function we(E) {
            Ge(E), Et.remove(E);
          }
          function Ge(E) {
            const F = Et.get(E).programs;
            F !== void 0 && (F.forEach(function(G) {
              _t.releaseProgram(G);
            }), E.isShaderMaterial && _t.releaseShaderCache(E));
          }
          this.renderBufferDirect = function(E, F, G, Y, N, at) {
            F === null && (F = dt);
            const xt = N.isMesh && N.matrixWorld.determinant() < 0, Tt = N_(E, F, G, Y, N);
            st.setMaterial(Y, xt);
            let Ct = G.index, Ht = 1;
            if (Y.wireframe === true) {
              if (Ct = Q.getWireframeAttribute(G), Ct === void 0) return;
              Ht = 2;
            }
            const Bt = G.drawRange, It = G.attributes.position;
            let Jt = Bt.start * Ht, se = (Bt.start + Bt.count) * Ht;
            at !== null && (Jt = Math.max(Jt, at.start * Ht), se = Math.min(se, (at.start + at.count) * Ht)), Ct !== null ? (Jt = Math.max(Jt, 0), se = Math.min(se, Ct.count)) : It != null && (Jt = Math.max(Jt, 0), se = Math.min(se, It.count));
            const Le = se - Jt;
            if (Le < 0 || Le === 1 / 0) return;
            _e.setup(N, Y, Tt, G, Ct);
            let Ee, te = At;
            if (Ct !== null && (Ee = K.get(Ct), te = Qt, te.setIndex(Ee)), N.isMesh) Y.wireframe === true ? (st.setLineWidth(Y.wireframeLinewidth * bt()), te.setMode(D.LINES)) : te.setMode(D.TRIANGLES);
            else if (N.isLine) {
              let Ot = Y.linewidth;
              Ot === void 0 && (Ot = 1), st.setLineWidth(Ot * bt()), N.isLineSegments ? te.setMode(D.LINES) : N.isLineLoop ? te.setMode(D.LINE_LOOP) : te.setMode(D.LINE_STRIP);
            } else N.isPoints ? te.setMode(D.POINTS) : N.isSprite && te.setMode(D.TRIANGLES);
            if (N.isBatchedMesh) if (N._multiDrawInstances !== null) wa("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), te.renderMultiDrawInstances(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount, N._multiDrawInstances);
            else if (ft.get("WEBGL_multi_draw")) te.renderMultiDraw(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount);
            else {
              const Ot = N._multiDrawStarts, We = N._multiDrawCounts, re = N._multiDrawCount, Tn = Ct ? K.get(Ct).bytesPerElement : 1, ys = Et.get(Y).currentProgram.getUniforms();
              for (let hn = 0; hn < re; hn++) ys.setValue(D, "_gl_DrawID", hn), te.render(Ot[hn] / Tn, We[hn]);
            }
            else if (N.isInstancedMesh) te.renderInstances(Jt, Le, N.count);
            else if (G.isInstancedBufferGeometry) {
              const Ot = G._maxInstanceCount !== void 0 ? G._maxInstanceCount : 1 / 0, We = Math.min(G.instanceCount, Ot);
              te.renderInstances(Jt, Le, We);
            } else te.render(Jt, Le);
          };
          function ae(E, F, G) {
            E.transparent === true && E.side === Nn && E.forceSinglePass === false ? (E.side = an, E.needsUpdate = true, vo(E, F, G), E.side = Di, E.needsUpdate = true, vo(E, F, G), E.side = Nn) : vo(E, F, G);
          }
          this.compile = function(E, F, G = null) {
            G === null && (G = E), p = kt.get(G), p.init(F), w.push(p), G.traverseVisible(function(N) {
              N.isLight && N.layers.test(F.layers) && (p.pushLight(N), N.castShadow && p.pushShadow(N));
            }), E !== G && E.traverseVisible(function(N) {
              N.isLight && N.layers.test(F.layers) && (p.pushLight(N), N.castShadow && p.pushShadow(N));
            }), p.setupLights();
            const Y = /* @__PURE__ */ new Set();
            return E.traverse(function(N) {
              if (!(N.isMesh || N.isPoints || N.isLine || N.isSprite)) return;
              const at = N.material;
              if (at) if (Array.isArray(at)) for (let xt = 0; xt < at.length; xt++) {
                const Tt = at[xt];
                ae(Tt, G, N), Y.add(Tt);
              }
              else ae(at, G, N), Y.add(at);
            }), p = w.pop(), Y;
          }, this.compileAsync = function(E, F, G = null) {
            const Y = this.compile(E, F, G);
            return new Promise((N) => {
              function at() {
                if (Y.forEach(function(xt) {
                  Et.get(xt).currentProgram.isReady() && Y.delete(xt);
                }), Y.size === 0) {
                  N(E);
                  return;
                }
                setTimeout(at, 10);
              }
              ft.get("KHR_parallel_shader_compile") !== null ? at() : setTimeout(at, 10);
            });
          };
          let En = null;
          function Xn(E) {
            En && En(E);
          }
          function Ru() {
            Ui.stop();
          }
          function Pu() {
            Ui.start();
          }
          const Ui = new Wm();
          Ui.setAnimationLoop(Xn), typeof self < "u" && Ui.setContext(self), this.setAnimationLoop = function(E) {
            En = E, Z.setAnimationLoop(E), E === null ? Ui.stop() : Ui.start();
          }, Z.addEventListener("sessionstart", Ru), Z.addEventListener("sessionend", Pu), this.render = function(E, F) {
            if (F !== void 0 && F.isCamera !== true) {
              console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              return;
            }
            if (C === true) return;
            if (E.matrixWorldAutoUpdate === true && E.updateMatrixWorld(), F.parent === null && F.matrixWorldAutoUpdate === true && F.updateMatrixWorld(), Z.enabled === true && Z.isPresenting === true && (Z.cameraAutoUpdate === true && Z.updateCamera(F), F = Z.getCamera()), E.isScene === true && E.onBeforeRender(M, E, F, v), p = kt.get(E, w.length), p.init(F), w.push(p), it.multiplyMatrices(F.projectionMatrix, F.matrixWorldInverse), W.setFromProjectionMatrix(it), ct = this.localClippingEnabled, J = nt.init(this.clippingPlanes, ct), m = Pt.get(E, y.length), m.init(), y.push(m), Z.enabled === true && Z.isPresenting === true) {
              const at = M.xr.getDepthSensingMesh();
              at !== null && xl(at, F, -1 / 0, M.sortObjects);
            }
            xl(E, F, 0, M.sortObjects), m.finish(), M.sortObjects === true && m.sort(q, rt), wt = Z.enabled === false || Z.isPresenting === false || Z.hasDepthSensing() === false, wt && Dt.addToRenderList(m, E), this.info.render.frame++, J === true && nt.beginShadows();
            const G = p.state.shadowsArray;
            gt.render(G, E, F), J === true && nt.endShadows(), this.info.autoReset === true && this.info.reset();
            const Y = m.opaque, N = m.transmissive;
            if (p.setupLights(), F.isArrayCamera) {
              const at = F.cameras;
              if (N.length > 0) for (let xt = 0, Tt = at.length; xt < Tt; xt++) {
                const Ct = at[xt];
                Lu(Y, N, E, Ct);
              }
              wt && Dt.render(E);
              for (let xt = 0, Tt = at.length; xt < Tt; xt++) {
                const Ct = at[xt];
                Du(m, E, Ct, Ct.viewport);
              }
            } else N.length > 0 && Lu(Y, N, E, F), wt && Dt.render(E), Du(m, E, F);
            v !== null && T === 0 && (P.updateMultisampleRenderTarget(v), P.updateRenderTargetMipmap(v)), E.isScene === true && E.onAfterRender(M, E, F), _e.resetDefaultState(), x = -1, b = null, w.pop(), w.length > 0 ? (p = w[w.length - 1], J === true && nt.setGlobalState(M.clippingPlanes, p.state.camera)) : p = null, y.pop(), y.length > 0 ? m = y[y.length - 1] : m = null;
          };
          function xl(E, F, G, Y) {
            if (E.visible === false) return;
            if (E.layers.test(F.layers)) {
              if (E.isGroup) G = E.renderOrder;
              else if (E.isLOD) E.autoUpdate === true && E.update(F);
              else if (E.isLight) p.pushLight(E), E.castShadow && p.pushShadow(E);
              else if (E.isSprite) {
                if (!E.frustumCulled || W.intersectsSprite(E)) {
                  Y && lt.setFromMatrixPosition(E.matrixWorld).applyMatrix4(it);
                  const xt = X.update(E), Tt = E.material;
                  Tt.visible && m.push(E, xt, Tt, G, lt.z, null);
                }
              } else if ((E.isMesh || E.isLine || E.isPoints) && (!E.frustumCulled || W.intersectsObject(E))) {
                const xt = X.update(E), Tt = E.material;
                if (Y && (E.boundingSphere !== void 0 ? (E.boundingSphere === null && E.computeBoundingSphere(), lt.copy(E.boundingSphere.center)) : (xt.boundingSphere === null && xt.computeBoundingSphere(), lt.copy(xt.boundingSphere.center)), lt.applyMatrix4(E.matrixWorld).applyMatrix4(it)), Array.isArray(Tt)) {
                  const Ct = xt.groups;
                  for (let Ht = 0, Bt = Ct.length; Ht < Bt; Ht++) {
                    const It = Ct[Ht], Jt = Tt[It.materialIndex];
                    Jt && Jt.visible && m.push(E, xt, Jt, G, lt.z, It);
                  }
                } else Tt.visible && m.push(E, xt, Tt, G, lt.z, null);
              }
            }
            const at = E.children;
            for (let xt = 0, Tt = at.length; xt < Tt; xt++) xl(at[xt], F, G, Y);
          }
          function Du(E, F, G, Y) {
            const N = E.opaque, at = E.transmissive, xt = E.transparent;
            p.setupLightsView(G), J === true && nt.setGlobalState(M.clippingPlanes, G), Y && st.viewport(A.copy(Y)), N.length > 0 && yo(N, F, G), at.length > 0 && yo(at, F, G), xt.length > 0 && yo(xt, F, G), st.buffers.depth.setTest(true), st.buffers.depth.setMask(true), st.buffers.color.setMask(true), st.setPolygonOffset(false);
          }
          function Lu(E, F, G, Y) {
            if ((G.isScene === true ? G.overrideMaterial : null) !== null) return;
            p.state.transmissionRenderTarget[Y.id] === void 0 && (p.state.transmissionRenderTarget[Y.id] = new as(1, 1, {
              generateMipmaps: true,
              type: ft.has("EXT_color_buffer_half_float") || ft.has("EXT_color_buffer_float") ? oo : Vn,
              minFilter: is,
              samples: 4,
              stencilBuffer: r,
              resolveDepthBuffer: false,
              resolveStencilBuffer: false,
              colorSpace: ee.workingColorSpace
            }));
            const at = p.state.transmissionRenderTarget[Y.id], xt = Y.viewport || A;
            at.setSize(xt.z * M.transmissionResolutionScale, xt.w * M.transmissionResolutionScale);
            const Tt = M.getRenderTarget();
            M.setRenderTarget(at), M.getClearColor(H), j = M.getClearAlpha(), j < 1 && M.setClearColor(16777215, 0.5), M.clear(), wt && Dt.render(G);
            const Ct = M.toneMapping;
            M.toneMapping = Ei;
            const Ht = Y.viewport;
            if (Y.viewport !== void 0 && (Y.viewport = void 0), p.setupLightsView(Y), J === true && nt.setGlobalState(M.clippingPlanes, Y), yo(E, G, Y), P.updateMultisampleRenderTarget(at), P.updateRenderTargetMipmap(at), ft.has("WEBGL_multisampled_render_to_texture") === false) {
              let Bt = false;
              for (let It = 0, Jt = F.length; It < Jt; It++) {
                const se = F[It], Le = se.object, Ee = se.geometry, te = se.material, Ot = se.group;
                if (te.side === Nn && Le.layers.test(Y.layers)) {
                  const We = te.side;
                  te.side = an, te.needsUpdate = true, Iu(Le, G, Y, Ee, te, Ot), te.side = We, te.needsUpdate = true, Bt = true;
                }
              }
              Bt === true && (P.updateMultisampleRenderTarget(at), P.updateRenderTargetMipmap(at));
            }
            M.setRenderTarget(Tt), M.setClearColor(H, j), Ht !== void 0 && (Y.viewport = Ht), M.toneMapping = Ct;
          }
          function yo(E, F, G) {
            const Y = F.isScene === true ? F.overrideMaterial : null;
            for (let N = 0, at = E.length; N < at; N++) {
              const xt = E[N], Tt = xt.object, Ct = xt.geometry, Ht = xt.group;
              let Bt = xt.material;
              Bt.allowOverride === true && Y !== null && (Bt = Y), Tt.layers.test(G.layers) && Iu(Tt, F, G, Ct, Bt, Ht);
            }
          }
          function Iu(E, F, G, Y, N, at) {
            E.onBeforeRender(M, F, G, Y, N, at), E.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, E.matrixWorld), E.normalMatrix.getNormalMatrix(E.modelViewMatrix), N.onBeforeRender(M, F, G, Y, E, at), N.transparent === true && N.side === Nn && N.forceSinglePass === false ? (N.side = an, N.needsUpdate = true, M.renderBufferDirect(G, F, Y, N, E, at), N.side = Di, N.needsUpdate = true, M.renderBufferDirect(G, F, Y, N, E, at), N.side = Nn) : M.renderBufferDirect(G, F, Y, N, E, at), E.onAfterRender(M, F, G, Y, N, at);
          }
          function vo(E, F, G) {
            F.isScene !== true && (F = dt);
            const Y = Et.get(E), N = p.state.lights, at = p.state.shadowsArray, xt = N.state.version, Tt = _t.getParameters(E, N.state, at, F, G), Ct = _t.getProgramCacheKey(Tt);
            let Ht = Y.programs;
            Y.environment = E.isMeshStandardMaterial ? F.environment : null, Y.fog = F.fog, Y.envMap = (E.isMeshStandardMaterial ? B : S).get(E.envMap || Y.environment), Y.envMapRotation = Y.environment !== null && E.envMap === null ? F.environmentRotation : E.envMapRotation, Ht === void 0 && (E.addEventListener("dispose", Gt), Ht = /* @__PURE__ */ new Map(), Y.programs = Ht);
            let Bt = Ht.get(Ct);
            if (Bt !== void 0) {
              if (Y.currentProgram === Bt && Y.lightsStateVersion === xt) return ku(E, Tt), Bt;
            } else Tt.uniforms = _t.getUniforms(E), E.onBeforeCompile(Tt, M), Bt = _t.acquireProgram(Tt, Ct), Ht.set(Ct, Bt), Y.uniforms = Tt.uniforms;
            const It = Y.uniforms;
            return (!E.isShaderMaterial && !E.isRawShaderMaterial || E.clipping === true) && (It.clippingPlanes = nt.uniform), ku(E, Tt), Y.needsLights = B_(E), Y.lightsStateVersion = xt, Y.needsLights && (It.ambientLightColor.value = N.state.ambient, It.lightProbe.value = N.state.probe, It.directionalLights.value = N.state.directional, It.directionalLightShadows.value = N.state.directionalShadow, It.spotLights.value = N.state.spot, It.spotLightShadows.value = N.state.spotShadow, It.rectAreaLights.value = N.state.rectArea, It.ltc_1.value = N.state.rectAreaLTC1, It.ltc_2.value = N.state.rectAreaLTC2, It.pointLights.value = N.state.point, It.pointLightShadows.value = N.state.pointShadow, It.hemisphereLights.value = N.state.hemi, It.directionalShadowMap.value = N.state.directionalShadowMap, It.directionalShadowMatrix.value = N.state.directionalShadowMatrix, It.spotShadowMap.value = N.state.spotShadowMap, It.spotLightMatrix.value = N.state.spotLightMatrix, It.spotLightMap.value = N.state.spotLightMap, It.pointShadowMap.value = N.state.pointShadowMap, It.pointShadowMatrix.value = N.state.pointShadowMatrix), Y.currentProgram = Bt, Y.uniformsList = null, Bt;
          }
          function Ou(E) {
            if (E.uniformsList === null) {
              const F = E.currentProgram.getUniforms();
              E.uniformsList = Ea.seqWithValue(F.seq, E.uniforms);
            }
            return E.uniformsList;
          }
          function ku(E, F) {
            const G = Et.get(E);
            G.outputColorSpace = F.outputColorSpace, G.batching = F.batching, G.batchingColor = F.batchingColor, G.instancing = F.instancing, G.instancingColor = F.instancingColor, G.instancingMorph = F.instancingMorph, G.skinning = F.skinning, G.morphTargets = F.morphTargets, G.morphNormals = F.morphNormals, G.morphColors = F.morphColors, G.morphTargetsCount = F.morphTargetsCount, G.numClippingPlanes = F.numClippingPlanes, G.numIntersection = F.numClipIntersection, G.vertexAlphas = F.vertexAlphas, G.vertexTangents = F.vertexTangents, G.toneMapping = F.toneMapping;
          }
          function N_(E, F, G, Y, N) {
            F.isScene !== true && (F = dt), P.resetTextureUnits();
            const at = F.fog, xt = Y.isMeshStandardMaterial ? F.environment : null, Tt = v === null ? M.outputColorSpace : v.isXRRenderTarget === true ? v.texture.colorSpace : er, Ct = (Y.isMeshStandardMaterial ? B : S).get(Y.envMap || xt), Ht = Y.vertexColors === true && !!G.attributes.color && G.attributes.color.itemSize === 4, Bt = !!G.attributes.tangent && (!!Y.normalMap || Y.anisotropy > 0), It = !!G.morphAttributes.position, Jt = !!G.morphAttributes.normal, se = !!G.morphAttributes.color;
            let Le = Ei;
            Y.toneMapped && (v === null || v.isXRRenderTarget === true) && (Le = M.toneMapping);
            const Ee = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color, te = Ee !== void 0 ? Ee.length : 0, Ot = Et.get(Y), We = p.state.lights;
            if (J === true && (ct === true || E !== b)) {
              const Ze = E === b && Y.id === x;
              nt.setState(Y, E, Ze);
            }
            let re = false;
            Y.version === Ot.__version ? (Ot.needsLights && Ot.lightsStateVersion !== We.state.version || Ot.outputColorSpace !== Tt || N.isBatchedMesh && Ot.batching === false || !N.isBatchedMesh && Ot.batching === true || N.isBatchedMesh && Ot.batchingColor === true && N.colorTexture === null || N.isBatchedMesh && Ot.batchingColor === false && N.colorTexture !== null || N.isInstancedMesh && Ot.instancing === false || !N.isInstancedMesh && Ot.instancing === true || N.isSkinnedMesh && Ot.skinning === false || !N.isSkinnedMesh && Ot.skinning === true || N.isInstancedMesh && Ot.instancingColor === true && N.instanceColor === null || N.isInstancedMesh && Ot.instancingColor === false && N.instanceColor !== null || N.isInstancedMesh && Ot.instancingMorph === true && N.morphTexture === null || N.isInstancedMesh && Ot.instancingMorph === false && N.morphTexture !== null || Ot.envMap !== Ct || Y.fog === true && Ot.fog !== at || Ot.numClippingPlanes !== void 0 && (Ot.numClippingPlanes !== nt.numPlanes || Ot.numIntersection !== nt.numIntersection) || Ot.vertexAlphas !== Ht || Ot.vertexTangents !== Bt || Ot.morphTargets !== It || Ot.morphNormals !== Jt || Ot.morphColors !== se || Ot.toneMapping !== Le || Ot.morphTargetsCount !== te) && (re = true) : (re = true, Ot.__version = Y.version);
            let Tn = Ot.currentProgram;
            re === true && (Tn = vo(Y, F, N));
            let ys = false, hn = false, fr = false;
            const ve = Tn.getUniforms(), bn = Ot.uniforms;
            if (st.useProgram(Tn.program) && (ys = true, hn = true, fr = true), Y.id !== x && (x = Y.id, hn = true), ys || b !== E) {
              st.buffers.depth.getReversed() ? (ht.copy(E.projectionMatrix), Lx(ht), Ix(ht), ve.setValue(D, "projectionMatrix", ht)) : ve.setValue(D, "projectionMatrix", E.projectionMatrix), ve.setValue(D, "viewMatrix", E.matrixWorldInverse);
              const nn = ve.map.cameraPosition;
              nn !== void 0 && nn.setValue(D, St.setFromMatrixPosition(E.matrixWorld)), Lt.logarithmicDepthBuffer && ve.setValue(D, "logDepthBufFC", 2 / (Math.log(E.far + 1) / Math.LN2)), (Y.isMeshPhongMaterial || Y.isMeshToonMaterial || Y.isMeshLambertMaterial || Y.isMeshBasicMaterial || Y.isMeshStandardMaterial || Y.isShaderMaterial) && ve.setValue(D, "isOrthographic", E.isOrthographicCamera === true), b !== E && (b = E, hn = true, fr = true);
            }
            if (N.isSkinnedMesh) {
              ve.setOptional(D, N, "bindMatrix"), ve.setOptional(D, N, "bindMatrixInverse");
              const Ze = N.skeleton;
              Ze && (Ze.boneTexture === null && Ze.computeBoneTexture(), ve.setValue(D, "boneTexture", Ze.boneTexture, P));
            }
            N.isBatchedMesh && (ve.setOptional(D, N, "batchingTexture"), ve.setValue(D, "batchingTexture", N._matricesTexture, P), ve.setOptional(D, N, "batchingIdTexture"), ve.setValue(D, "batchingIdTexture", N._indirectTexture, P), ve.setOptional(D, N, "batchingColorTexture"), N._colorsTexture !== null && ve.setValue(D, "batchingColorTexture", N._colorsTexture, P));
            const yn = G.morphAttributes;
            if ((yn.position !== void 0 || yn.normal !== void 0 || yn.color !== void 0) && Nt.update(N, G, Tn), (hn || Ot.receiveShadow !== N.receiveShadow) && (Ot.receiveShadow = N.receiveShadow, ve.setValue(D, "receiveShadow", N.receiveShadow)), Y.isMeshGouraudMaterial && Y.envMap !== null && (bn.envMap.value = Ct, bn.flipEnvMap.value = Ct.isCubeTexture && Ct.isRenderTargetTexture === false ? -1 : 1), Y.isMeshStandardMaterial && Y.envMap === null && F.environment !== null && (bn.envMapIntensity.value = F.environmentIntensity), hn && (ve.setValue(D, "toneMappingExposure", M.toneMappingExposure), Ot.needsLights && U_(bn, fr), at && Y.fog === true && pt.refreshFogUniforms(bn, at), pt.refreshMaterialUniforms(bn, Y, U, V, p.state.transmissionRenderTarget[E.id]), Ea.upload(D, Ou(Ot), bn, P)), Y.isShaderMaterial && Y.uniformsNeedUpdate === true && (Ea.upload(D, Ou(Ot), bn, P), Y.uniformsNeedUpdate = false), Y.isSpriteMaterial && ve.setValue(D, "center", N.center), ve.setValue(D, "modelViewMatrix", N.modelViewMatrix), ve.setValue(D, "normalMatrix", N.normalMatrix), ve.setValue(D, "modelMatrix", N.matrixWorld), Y.isShaderMaterial || Y.isRawShaderMaterial) {
              const Ze = Y.uniformsGroups;
              for (let nn = 0, bl = Ze.length; nn < bl; nn++) {
                const Bi = Ze[nn];
                k.update(Bi, Tn), k.bind(Bi, Tn);
              }
            }
            return Tn;
          }
          function U_(E, F) {
            E.ambientLightColor.needsUpdate = F, E.lightProbe.needsUpdate = F, E.directionalLights.needsUpdate = F, E.directionalLightShadows.needsUpdate = F, E.pointLights.needsUpdate = F, E.pointLightShadows.needsUpdate = F, E.spotLights.needsUpdate = F, E.spotLightShadows.needsUpdate = F, E.rectAreaLights.needsUpdate = F, E.hemisphereLights.needsUpdate = F;
          }
          function B_(E) {
            return E.isMeshLambertMaterial || E.isMeshToonMaterial || E.isMeshPhongMaterial || E.isMeshStandardMaterial || E.isShadowMaterial || E.isShaderMaterial && E.lights === true;
          }
          this.getActiveCubeFace = function() {
            return R;
          }, this.getActiveMipmapLevel = function() {
            return T;
          }, this.getRenderTarget = function() {
            return v;
          }, this.setRenderTargetTextures = function(E, F, G) {
            const Y = Et.get(E);
            Y.__autoAllocateDepthBuffer = E.resolveDepthBuffer === false, Y.__autoAllocateDepthBuffer === false && (Y.__useRenderToTexture = false), Et.get(E.texture).__webglTexture = F, Et.get(E.depthTexture).__webglTexture = Y.__autoAllocateDepthBuffer ? void 0 : G, Y.__hasExternalTextures = true;
          }, this.setRenderTargetFramebuffer = function(E, F) {
            const G = Et.get(E);
            G.__webglFramebuffer = F, G.__useDefaultFramebuffer = F === void 0;
          };
          const z_ = D.createFramebuffer();
          this.setRenderTarget = function(E, F = 0, G = 0) {
            v = E, R = F, T = G;
            let Y = true, N = null, at = false, xt = false;
            if (E) {
              const Ct = Et.get(E);
              if (Ct.__useDefaultFramebuffer !== void 0) st.bindFramebuffer(D.FRAMEBUFFER, null), Y = false;
              else if (Ct.__webglFramebuffer === void 0) P.setupRenderTarget(E);
              else if (Ct.__hasExternalTextures) P.rebindTextures(E, Et.get(E.texture).__webglTexture, Et.get(E.depthTexture).__webglTexture);
              else if (E.depthBuffer) {
                const It = E.depthTexture;
                if (Ct.__boundDepthTexture !== It) {
                  if (It !== null && Et.has(It) && (E.width !== It.image.width || E.height !== It.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                  P.setupDepthRenderbuffer(E);
                }
              }
              const Ht = E.texture;
              (Ht.isData3DTexture || Ht.isDataArrayTexture || Ht.isCompressedArrayTexture) && (xt = true);
              const Bt = Et.get(E).__webglFramebuffer;
              E.isWebGLCubeRenderTarget ? (Array.isArray(Bt[F]) ? N = Bt[F][G] : N = Bt[F], at = true) : E.samples > 0 && P.useMultisampledRTT(E) === false ? N = Et.get(E).__webglMultisampledFramebuffer : Array.isArray(Bt) ? N = Bt[G] : N = Bt, A.copy(E.viewport), L.copy(E.scissor), I = E.scissorTest;
            } else A.copy(et).multiplyScalar(U).floor(), L.copy(ut).multiplyScalar(U).floor(), I = ot;
            if (G !== 0 && (N = z_), st.bindFramebuffer(D.FRAMEBUFFER, N) && Y && st.drawBuffers(E, N), st.viewport(A), st.scissor(L), st.setScissorTest(I), at) {
              const Ct = Et.get(E.texture);
              D.framebufferTexture2D(D.FRAMEBUFFER, D.COLOR_ATTACHMENT0, D.TEXTURE_CUBE_MAP_POSITIVE_X + F, Ct.__webglTexture, G);
            } else if (xt) {
              const Ct = Et.get(E.texture), Ht = F;
              D.framebufferTextureLayer(D.FRAMEBUFFER, D.COLOR_ATTACHMENT0, Ct.__webglTexture, G, Ht);
            } else if (E !== null && G !== 0) {
              const Ct = Et.get(E.texture);
              D.framebufferTexture2D(D.FRAMEBUFFER, D.COLOR_ATTACHMENT0, D.TEXTURE_2D, Ct.__webglTexture, G);
            }
            x = -1;
          }, this.readRenderTargetPixels = function(E, F, G, Y, N, at, xt) {
            if (!(E && E.isWebGLRenderTarget)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              return;
            }
            let Tt = Et.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && xt !== void 0 && (Tt = Tt[xt]), Tt) {
              st.bindFramebuffer(D.FRAMEBUFFER, Tt);
              try {
                const Ct = E.texture, Ht = Ct.format, Bt = Ct.type;
                if (!Lt.textureFormatReadable(Ht)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  return;
                }
                if (!Lt.textureTypeReadable(Bt)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  return;
                }
                F >= 0 && F <= E.width - Y && G >= 0 && G <= E.height - N && D.readPixels(F, G, Y, N, Yt.convert(Ht), Yt.convert(Bt), at);
              } finally {
                const Ct = v !== null ? Et.get(v).__webglFramebuffer : null;
                st.bindFramebuffer(D.FRAMEBUFFER, Ct);
              }
            }
          }, this.readRenderTargetPixelsAsync = async function(E, F, G, Y, N, at, xt) {
            if (!(E && E.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Tt = Et.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && xt !== void 0 && (Tt = Tt[xt]), Tt) if (F >= 0 && F <= E.width - Y && G >= 0 && G <= E.height - N) {
              st.bindFramebuffer(D.FRAMEBUFFER, Tt);
              const Ct = E.texture, Ht = Ct.format, Bt = Ct.type;
              if (!Lt.textureFormatReadable(Ht)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
              if (!Lt.textureTypeReadable(Bt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
              const It = D.createBuffer();
              D.bindBuffer(D.PIXEL_PACK_BUFFER, It), D.bufferData(D.PIXEL_PACK_BUFFER, at.byteLength, D.STREAM_READ), D.readPixels(F, G, Y, N, Yt.convert(Ht), Yt.convert(Bt), 0);
              const Jt = v !== null ? Et.get(v).__webglFramebuffer : null;
              st.bindFramebuffer(D.FRAMEBUFFER, Jt);
              const se = D.fenceSync(D.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return D.flush(), await Dx(D, se, 4), D.bindBuffer(D.PIXEL_PACK_BUFFER, It), D.getBufferSubData(D.PIXEL_PACK_BUFFER, 0, at), D.deleteBuffer(It), D.deleteSync(se), at;
            } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
          }, this.copyFramebufferToTexture = function(E, F = null, G = 0) {
            const Y = Math.pow(2, -G), N = Math.floor(E.image.width * Y), at = Math.floor(E.image.height * Y), xt = F !== null ? F.x : 0, Tt = F !== null ? F.y : 0;
            P.setTexture2D(E, 0), D.copyTexSubImage2D(D.TEXTURE_2D, G, 0, 0, xt, Tt, N, at), st.unbindTexture();
          };
          const H_ = D.createFramebuffer(), V_ = D.createFramebuffer();
          this.copyTextureToTexture = function(E, F, G = null, Y = null, N = 0, at = null) {
            at === null && (N !== 0 ? (wa("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), at = N, N = 0) : at = 0);
            let xt, Tt, Ct, Ht, Bt, It, Jt, se, Le;
            const Ee = E.isCompressedTexture ? E.mipmaps[at] : E.image;
            if (G !== null) xt = G.max.x - G.min.x, Tt = G.max.y - G.min.y, Ct = G.isBox3 ? G.max.z - G.min.z : 1, Ht = G.min.x, Bt = G.min.y, It = G.isBox3 ? G.min.z : 0;
            else {
              const yn = Math.pow(2, -N);
              xt = Math.floor(Ee.width * yn), Tt = Math.floor(Ee.height * yn), E.isDataArrayTexture ? Ct = Ee.depth : E.isData3DTexture ? Ct = Math.floor(Ee.depth * yn) : Ct = 1, Ht = 0, Bt = 0, It = 0;
            }
            Y !== null ? (Jt = Y.x, se = Y.y, Le = Y.z) : (Jt = 0, se = 0, Le = 0);
            const te = Yt.convert(F.format), Ot = Yt.convert(F.type);
            let We;
            F.isData3DTexture ? (P.setTexture3D(F, 0), We = D.TEXTURE_3D) : F.isDataArrayTexture || F.isCompressedArrayTexture ? (P.setTexture2DArray(F, 0), We = D.TEXTURE_2D_ARRAY) : (P.setTexture2D(F, 0), We = D.TEXTURE_2D), D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL, F.flipY), D.pixelStorei(D.UNPACK_PREMULTIPLY_ALPHA_WEBGL, F.premultiplyAlpha), D.pixelStorei(D.UNPACK_ALIGNMENT, F.unpackAlignment);
            const re = D.getParameter(D.UNPACK_ROW_LENGTH), Tn = D.getParameter(D.UNPACK_IMAGE_HEIGHT), ys = D.getParameter(D.UNPACK_SKIP_PIXELS), hn = D.getParameter(D.UNPACK_SKIP_ROWS), fr = D.getParameter(D.UNPACK_SKIP_IMAGES);
            D.pixelStorei(D.UNPACK_ROW_LENGTH, Ee.width), D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, Ee.height), D.pixelStorei(D.UNPACK_SKIP_PIXELS, Ht), D.pixelStorei(D.UNPACK_SKIP_ROWS, Bt), D.pixelStorei(D.UNPACK_SKIP_IMAGES, It);
            const ve = E.isDataArrayTexture || E.isData3DTexture, bn = F.isDataArrayTexture || F.isData3DTexture;
            if (E.isDepthTexture) {
              const yn = Et.get(E), Ze = Et.get(F), nn = Et.get(yn.__renderTarget), bl = Et.get(Ze.__renderTarget);
              st.bindFramebuffer(D.READ_FRAMEBUFFER, nn.__webglFramebuffer), st.bindFramebuffer(D.DRAW_FRAMEBUFFER, bl.__webglFramebuffer);
              for (let Bi = 0; Bi < Ct; Bi++) ve && (D.framebufferTextureLayer(D.READ_FRAMEBUFFER, D.COLOR_ATTACHMENT0, Et.get(E).__webglTexture, N, It + Bi), D.framebufferTextureLayer(D.DRAW_FRAMEBUFFER, D.COLOR_ATTACHMENT0, Et.get(F).__webglTexture, at, Le + Bi)), D.blitFramebuffer(Ht, Bt, xt, Tt, Jt, se, xt, Tt, D.DEPTH_BUFFER_BIT, D.NEAREST);
              st.bindFramebuffer(D.READ_FRAMEBUFFER, null), st.bindFramebuffer(D.DRAW_FRAMEBUFFER, null);
            } else if (N !== 0 || E.isRenderTargetTexture || Et.has(E)) {
              const yn = Et.get(E), Ze = Et.get(F);
              st.bindFramebuffer(D.READ_FRAMEBUFFER, H_), st.bindFramebuffer(D.DRAW_FRAMEBUFFER, V_);
              for (let nn = 0; nn < Ct; nn++) ve ? D.framebufferTextureLayer(D.READ_FRAMEBUFFER, D.COLOR_ATTACHMENT0, yn.__webglTexture, N, It + nn) : D.framebufferTexture2D(D.READ_FRAMEBUFFER, D.COLOR_ATTACHMENT0, D.TEXTURE_2D, yn.__webglTexture, N), bn ? D.framebufferTextureLayer(D.DRAW_FRAMEBUFFER, D.COLOR_ATTACHMENT0, Ze.__webglTexture, at, Le + nn) : D.framebufferTexture2D(D.DRAW_FRAMEBUFFER, D.COLOR_ATTACHMENT0, D.TEXTURE_2D, Ze.__webglTexture, at), N !== 0 ? D.blitFramebuffer(Ht, Bt, xt, Tt, Jt, se, xt, Tt, D.COLOR_BUFFER_BIT, D.NEAREST) : bn ? D.copyTexSubImage3D(We, at, Jt, se, Le + nn, Ht, Bt, xt, Tt) : D.copyTexSubImage2D(We, at, Jt, se, Ht, Bt, xt, Tt);
              st.bindFramebuffer(D.READ_FRAMEBUFFER, null), st.bindFramebuffer(D.DRAW_FRAMEBUFFER, null);
            } else bn ? E.isDataTexture || E.isData3DTexture ? D.texSubImage3D(We, at, Jt, se, Le, xt, Tt, Ct, te, Ot, Ee.data) : F.isCompressedArrayTexture ? D.compressedTexSubImage3D(We, at, Jt, se, Le, xt, Tt, Ct, te, Ee.data) : D.texSubImage3D(We, at, Jt, se, Le, xt, Tt, Ct, te, Ot, Ee) : E.isDataTexture ? D.texSubImage2D(D.TEXTURE_2D, at, Jt, se, xt, Tt, te, Ot, Ee.data) : E.isCompressedTexture ? D.compressedTexSubImage2D(D.TEXTURE_2D, at, Jt, se, Ee.width, Ee.height, te, Ee.data) : D.texSubImage2D(D.TEXTURE_2D, at, Jt, se, xt, Tt, te, Ot, Ee);
            D.pixelStorei(D.UNPACK_ROW_LENGTH, re), D.pixelStorei(D.UNPACK_IMAGE_HEIGHT, Tn), D.pixelStorei(D.UNPACK_SKIP_PIXELS, ys), D.pixelStorei(D.UNPACK_SKIP_ROWS, hn), D.pixelStorei(D.UNPACK_SKIP_IMAGES, fr), at === 0 && F.generateMipmaps && D.generateMipmap(We), st.unbindTexture();
          }, this.copyTextureToTexture3D = function(E, F, G = null, Y = null, N = 0) {
            return wa('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(E, F, G, Y, N);
          }, this.initRenderTarget = function(E) {
            Et.get(E).__webglFramebuffer === void 0 && P.setupRenderTarget(E);
          }, this.initTexture = function(E) {
            E.isCubeTexture ? P.setTextureCube(E, 0) : E.isData3DTexture ? P.setTexture3D(E, 0) : E.isDataArrayTexture || E.isCompressedArrayTexture ? P.setTexture2DArray(E, 0) : P.setTexture2D(E, 0), st.unbindTexture();
          }, this.resetState = function() {
            R = 0, T = 0, v = null, st.reset(), _e.reset();
          }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        get coordinateSystem() {
          return ri;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(t) {
          this._outputColorSpace = t;
          const e = this.getContext();
          e.drawingBufferColorSpace = ee._getDrawingBufferColorSpace(t), e.unpackColorSpace = ee._getUnpackColorSpace();
        }
      }
      const ef = {
        type: "change"
      }, Zh = {
        type: "start"
      }, qm = {
        type: "end"
      }, Jo = new jh(), nf = new bi(), ow = Math.cos(70 * Rx.DEG2RAD), Ne = new O(), sn = 2 * Math.PI, fe = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      }, nc = 1e-6;
      class aw extends Mb {
        constructor(t, e = null) {
          super(t, e), this.state = fe.NONE, this.target = new O(), this.cursor = new O(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.zoomToCursor = false, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
          }, this.mouseButtons = {
            LEFT: Ys.ROTATE,
            MIDDLE: Ys.DOLLY,
            RIGHT: Ys.PAN
          }, this.touches = {
            ONE: Ws.ROTATE,
            TWO: Ws.DOLLY_PAN
          }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new O(), this._lastQuaternion = new ls(), this._lastTargetPosition = new O(), this._quat = new ls().setFromUnitVectors(t.up, new O(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new Rd(), this._sphericalDelta = new Rd(), this._scale = 1, this._panOffset = new O(), this._rotateStart = new Ft(), this._rotateEnd = new Ft(), this._rotateDelta = new Ft(), this._panStart = new Ft(), this._panEnd = new Ft(), this._panDelta = new Ft(), this._dollyStart = new Ft(), this._dollyEnd = new Ft(), this._dollyDelta = new Ft(), this._dollyDirection = new O(), this._mouse = new Ft(), this._performCursorZoom = false, this._pointers = [], this._pointerPositions = {}, this._controlActive = false, this._onPointerMove = cw.bind(this), this._onPointerDown = lw.bind(this), this._onPointerUp = hw.bind(this), this._onContextMenu = _w.bind(this), this._onMouseWheel = fw.bind(this), this._onKeyDown = pw.bind(this), this._onTouchStart = mw.bind(this), this._onTouchMove = gw.bind(this), this._onMouseDown = uw.bind(this), this._onMouseMove = dw.bind(this), this._interceptControlDown = xw.bind(this), this._interceptControlUp = bw.bind(this), this.domElement !== null && this.connect(this.domElement), this.update();
        }
        connect(t) {
          super.connect(t), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: false
          }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: true,
            capture: true
          }), this.domElement.style.touchAction = "none";
        }
        disconnect() {
          this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: true
          }), this.domElement.style.touchAction = "auto";
        }
        dispose() {
          this.disconnect();
        }
        getPolarAngle() {
          return this._spherical.phi;
        }
        getAzimuthalAngle() {
          return this._spherical.theta;
        }
        getDistance() {
          return this.object.position.distanceTo(this.target);
        }
        listenToKeyEvents(t) {
          t.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = t;
        }
        stopListenToKeyEvents() {
          this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
        }
        saveState() {
          this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
        }
        reset() {
          this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(ef), this.update(), this.state = fe.NONE;
        }
        update(t = null) {
          const e = this.object.position;
          Ne.copy(e).sub(this.target), Ne.applyQuaternion(this._quat), this._spherical.setFromVector3(Ne), this.autoRotate && this.state === fe.NONE && this._rotateLeft(this._getAutoRotationAngle(t)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
          let i = this.minAzimuthAngle, s = this.maxAzimuthAngle;
          isFinite(i) && isFinite(s) && (i < -Math.PI ? i += sn : i > Math.PI && (i -= sn), s < -Math.PI ? s += sn : s > Math.PI && (s -= sn), i <= s ? this._spherical.theta = Math.max(i, Math.min(s, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (i + s) / 2 ? Math.max(i, this._spherical.theta) : Math.min(s, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === true ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
          let r = false;
          if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical.radius = this._clampDistance(this._spherical.radius);
          else {
            const o = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), r = o != this._spherical.radius;
          }
          if (Ne.setFromSpherical(this._spherical), Ne.applyQuaternion(this._quatInverse), e.copy(this.target).add(Ne), this.object.lookAt(this.target), this.enableDamping === true ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
            let o = null;
            if (this.object.isPerspectiveCamera) {
              const a = Ne.length();
              o = this._clampDistance(a * this._scale);
              const l = a - o;
              this.object.position.addScaledVector(this._dollyDirection, l), this.object.updateMatrixWorld(), r = !!l;
            } else if (this.object.isOrthographicCamera) {
              const a = new O(this._mouse.x, this._mouse.y, 0);
              a.unproject(this.object);
              const l = this.object.zoom;
              this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), r = l !== this.object.zoom;
              const c = new O(this._mouse.x, this._mouse.y, 0);
              c.unproject(this.object), this.object.position.sub(c).add(a), this.object.updateMatrixWorld(), o = Ne.length();
            } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = false;
            o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (Jo.origin.copy(this.object.position), Jo.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(Jo.direction)) < ow ? this.object.lookAt(this.target) : (nf.setFromNormalAndCoplanarPoint(this.object.up, this.target), Jo.intersectPlane(nf, this.target))));
          } else if (this.object.isOrthographicCamera) {
            const o = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), r = true);
          }
          return this._scale = 1, this._performCursorZoom = false, r || this._lastPosition.distanceToSquared(this.object.position) > nc || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > nc || this._lastTargetPosition.distanceToSquared(this.target) > nc ? (this.dispatchEvent(ef), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), true) : false;
        }
        _getAutoRotationAngle(t) {
          return t !== null ? sn / 60 * this.autoRotateSpeed * t : sn / 60 / 60 * this.autoRotateSpeed;
        }
        _getZoomScale(t) {
          const e = Math.abs(t * 0.01);
          return Math.pow(0.95, this.zoomSpeed * e);
        }
        _rotateLeft(t) {
          this._sphericalDelta.theta -= t;
        }
        _rotateUp(t) {
          this._sphericalDelta.phi -= t;
        }
        _panLeft(t, e) {
          Ne.setFromMatrixColumn(e, 0), Ne.multiplyScalar(-t), this._panOffset.add(Ne);
        }
        _panUp(t, e) {
          this.screenSpacePanning === true ? Ne.setFromMatrixColumn(e, 1) : (Ne.setFromMatrixColumn(e, 0), Ne.crossVectors(this.object.up, Ne)), Ne.multiplyScalar(t), this._panOffset.add(Ne);
        }
        _pan(t, e) {
          const i = this.domElement;
          if (this.object.isPerspectiveCamera) {
            const s = this.object.position;
            Ne.copy(s).sub(this.target);
            let r = Ne.length();
            r *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * t * r / i.clientHeight, this.object.matrix), this._panUp(2 * e * r / i.clientHeight, this.object.matrix);
          } else this.object.isOrthographicCamera ? (this._panLeft(t * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(e * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = false);
        }
        _dollyOut(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _dollyIn(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _updateZoomParameters(t, e) {
          if (!this.zoomToCursor) return;
          this._performCursorZoom = true;
          const i = this.domElement.getBoundingClientRect(), s = t - i.left, r = e - i.top, o = i.width, a = i.height;
          this._mouse.x = s / o * 2 - 1, this._mouse.y = -(r / a) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
        }
        _clampDistance(t) {
          return Math.max(this.minDistance, Math.min(this.maxDistance, t));
        }
        _handleMouseDownRotate(t) {
          this._rotateStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownDolly(t) {
          this._updateZoomParameters(t.clientX, t.clientX), this._dollyStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownPan(t) {
          this._panStart.set(t.clientX, t.clientY);
        }
        _handleMouseMoveRotate(t) {
          this._rotateEnd.set(t.clientX, t.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const e = this.domElement;
          this._rotateLeft(sn * this._rotateDelta.x / e.clientHeight), this._rotateUp(sn * this._rotateDelta.y / e.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
        }
        _handleMouseMoveDolly(t) {
          this._dollyEnd.set(t.clientX, t.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
        }
        _handleMouseMovePan(t) {
          this._panEnd.set(t.clientX, t.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
        }
        _handleMouseWheel(t) {
          this._updateZoomParameters(t.clientX, t.clientY), t.deltaY < 0 ? this._dollyIn(this._getZoomScale(t.deltaY)) : t.deltaY > 0 && this._dollyOut(this._getZoomScale(t.deltaY)), this.update();
        }
        _handleKeyDown(t) {
          let e = false;
          switch (t.code) {
            case this.keys.UP:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateUp(sn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), e = true;
              break;
            case this.keys.BOTTOM:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateUp(-sn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), e = true;
              break;
            case this.keys.LEFT:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateLeft(sn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), e = true;
              break;
            case this.keys.RIGHT:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateLeft(-sn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), e = true;
              break;
          }
          e && (t.preventDefault(), this.update());
        }
        _handleTouchStartRotate(t) {
          if (this._pointers.length === 1) this._rotateStart.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + e.x), s = 0.5 * (t.pageY + e.y);
            this._rotateStart.set(i, s);
          }
        }
        _handleTouchStartPan(t) {
          if (this._pointers.length === 1) this._panStart.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + e.x), s = 0.5 * (t.pageY + e.y);
            this._panStart.set(i, s);
          }
        }
        _handleTouchStartDolly(t) {
          const e = this._getSecondPointerPosition(t), i = t.pageX - e.x, s = t.pageY - e.y, r = Math.sqrt(i * i + s * s);
          this._dollyStart.set(0, r);
        }
        _handleTouchStartDollyPan(t) {
          this.enableZoom && this._handleTouchStartDolly(t), this.enablePan && this._handleTouchStartPan(t);
        }
        _handleTouchStartDollyRotate(t) {
          this.enableZoom && this._handleTouchStartDolly(t), this.enableRotate && this._handleTouchStartRotate(t);
        }
        _handleTouchMoveRotate(t) {
          if (this._pointers.length == 1) this._rotateEnd.set(t.pageX, t.pageY);
          else {
            const i = this._getSecondPointerPosition(t), s = 0.5 * (t.pageX + i.x), r = 0.5 * (t.pageY + i.y);
            this._rotateEnd.set(s, r);
          }
          this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const e = this.domElement;
          this._rotateLeft(sn * this._rotateDelta.x / e.clientHeight), this._rotateUp(sn * this._rotateDelta.y / e.clientHeight), this._rotateStart.copy(this._rotateEnd);
        }
        _handleTouchMovePan(t) {
          if (this._pointers.length === 1) this._panEnd.set(t.pageX, t.pageY);
          else {
            const e = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + e.x), s = 0.5 * (t.pageY + e.y);
            this._panEnd.set(i, s);
          }
          this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
        }
        _handleTouchMoveDolly(t) {
          const e = this._getSecondPointerPosition(t), i = t.pageX - e.x, s = t.pageY - e.y, r = Math.sqrt(i * i + s * s);
          this._dollyEnd.set(0, r), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
          const o = (t.pageX + e.x) * 0.5, a = (t.pageY + e.y) * 0.5;
          this._updateZoomParameters(o, a);
        }
        _handleTouchMoveDollyPan(t) {
          this.enableZoom && this._handleTouchMoveDolly(t), this.enablePan && this._handleTouchMovePan(t);
        }
        _handleTouchMoveDollyRotate(t) {
          this.enableZoom && this._handleTouchMoveDolly(t), this.enableRotate && this._handleTouchMoveRotate(t);
        }
        _addPointer(t) {
          this._pointers.push(t.pointerId);
        }
        _removePointer(t) {
          delete this._pointerPositions[t.pointerId];
          for (let e = 0; e < this._pointers.length; e++) if (this._pointers[e] == t.pointerId) {
            this._pointers.splice(e, 1);
            return;
          }
        }
        _isTrackingPointer(t) {
          for (let e = 0; e < this._pointers.length; e++) if (this._pointers[e] == t.pointerId) return true;
          return false;
        }
        _trackPointer(t) {
          let e = this._pointerPositions[t.pointerId];
          e === void 0 && (e = new Ft(), this._pointerPositions[t.pointerId] = e), e.set(t.pageX, t.pageY);
        }
        _getSecondPointerPosition(t) {
          const e = t.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
          return this._pointerPositions[e];
        }
        _customWheelEvent(t) {
          const e = t.deltaMode, i = {
            clientX: t.clientX,
            clientY: t.clientY,
            deltaY: t.deltaY
          };
          switch (e) {
            case 1:
              i.deltaY *= 16;
              break;
            case 2:
              i.deltaY *= 100;
              break;
          }
          return t.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
        }
      }
      function lw(n) {
        this.enabled !== false && (this._pointers.length === 0 && (this.domElement.setPointerCapture(n.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(n) && (this._addPointer(n), n.pointerType === "touch" ? this._onTouchStart(n) : this._onMouseDown(n)));
      }
      function cw(n) {
        this.enabled !== false && (n.pointerType === "touch" ? this._onTouchMove(n) : this._onMouseMove(n));
      }
      function hw(n) {
        switch (this._removePointer(n), this._pointers.length) {
          case 0:
            this.domElement.releasePointerCapture(n.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(qm), this.state = fe.NONE;
            break;
          case 1:
            const t = this._pointers[0], e = this._pointerPositions[t];
            this._onTouchStart({
              pointerId: t,
              pageX: e.x,
              pageY: e.y
            });
            break;
        }
      }
      function uw(n) {
        let t;
        switch (n.button) {
          case 0:
            t = this.mouseButtons.LEFT;
            break;
          case 1:
            t = this.mouseButtons.MIDDLE;
            break;
          case 2:
            t = this.mouseButtons.RIGHT;
            break;
          default:
            t = -1;
        }
        switch (t) {
          case Ys.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseDownDolly(n), this.state = fe.DOLLY;
            break;
          case Ys.ROTATE:
            if (n.ctrlKey || n.metaKey || n.shiftKey) {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(n), this.state = fe.PAN;
            } else {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(n), this.state = fe.ROTATE;
            }
            break;
          case Ys.PAN:
            if (n.ctrlKey || n.metaKey || n.shiftKey) {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(n), this.state = fe.ROTATE;
            } else {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(n), this.state = fe.PAN;
            }
            break;
          default:
            this.state = fe.NONE;
        }
        this.state !== fe.NONE && this.dispatchEvent(Zh);
      }
      function dw(n) {
        switch (this.state) {
          case fe.ROTATE:
            if (this.enableRotate === false) return;
            this._handleMouseMoveRotate(n);
            break;
          case fe.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseMoveDolly(n);
            break;
          case fe.PAN:
            if (this.enablePan === false) return;
            this._handleMouseMovePan(n);
            break;
        }
      }
      function fw(n) {
        this.enabled === false || this.enableZoom === false || this.state !== fe.NONE || (n.preventDefault(), this.dispatchEvent(Zh), this._handleMouseWheel(this._customWheelEvent(n)), this.dispatchEvent(qm));
      }
      function pw(n) {
        this.enabled !== false && this._handleKeyDown(n);
      }
      function mw(n) {
        switch (this._trackPointer(n), this._pointers.length) {
          case 1:
            switch (this.touches.ONE) {
              case Ws.ROTATE:
                if (this.enableRotate === false) return;
                this._handleTouchStartRotate(n), this.state = fe.TOUCH_ROTATE;
                break;
              case Ws.PAN:
                if (this.enablePan === false) return;
                this._handleTouchStartPan(n), this.state = fe.TOUCH_PAN;
                break;
              default:
                this.state = fe.NONE;
            }
            break;
          case 2:
            switch (this.touches.TWO) {
              case Ws.DOLLY_PAN:
                if (this.enableZoom === false && this.enablePan === false) return;
                this._handleTouchStartDollyPan(n), this.state = fe.TOUCH_DOLLY_PAN;
                break;
              case Ws.DOLLY_ROTATE:
                if (this.enableZoom === false && this.enableRotate === false) return;
                this._handleTouchStartDollyRotate(n), this.state = fe.TOUCH_DOLLY_ROTATE;
                break;
              default:
                this.state = fe.NONE;
            }
            break;
          default:
            this.state = fe.NONE;
        }
        this.state !== fe.NONE && this.dispatchEvent(Zh);
      }
      function gw(n) {
        switch (this._trackPointer(n), this.state) {
          case fe.TOUCH_ROTATE:
            if (this.enableRotate === false) return;
            this._handleTouchMoveRotate(n), this.update();
            break;
          case fe.TOUCH_PAN:
            if (this.enablePan === false) return;
            this._handleTouchMovePan(n), this.update();
            break;
          case fe.TOUCH_DOLLY_PAN:
            if (this.enableZoom === false && this.enablePan === false) return;
            this._handleTouchMoveDollyPan(n), this.update();
            break;
          case fe.TOUCH_DOLLY_ROTATE:
            if (this.enableZoom === false && this.enableRotate === false) return;
            this._handleTouchMoveDollyRotate(n), this.update();
            break;
          default:
            this.state = fe.NONE;
        }
      }
      function _w(n) {
        this.enabled !== false && n.preventDefault();
      }
      function xw(n) {
        n.key === "Control" && (this._controlActive = true, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      function bw(n) {
        n.key === "Control" && (this._controlActive = false, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      const yw = (n, t, e) => {
        const i = (n - t) / (e - t);
        return {
          r: Math.floor(255 * (1 - i)),
          g: Math.floor(255 * i),
          b: 0
        };
      }, sf = ({ data: n, colorType: t, title: e, strikes: i, volatilities: s }) => {
        const r = Zs(null), o = Zs(null), [a, l] = Vs(false), c = () => {
          const u = r.current;
          u && (a ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen() : u.requestFullscreen ? u.requestFullscreen() : u.webkitRequestFullscreen ? u.webkitRequestFullscreen() : u.msRequestFullscreen && u.msRequestFullscreen());
        };
        Xs(() => {
          const u = () => {
            l(!!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement));
          };
          return document.addEventListener("fullscreenchange", u), document.addEventListener("webkitfullscreenchange", u), document.addEventListener("msfullscreenchange", u), () => {
            document.removeEventListener("fullscreenchange", u), document.removeEventListener("webkitfullscreenchange", u), document.removeEventListener("msfullscreenchange", u);
          };
        }, []);
        const h = (u, d) => {
          const f = parseFloat(u);
          switch (d) {
            case "prices":
              return f / 40;
            case "delta":
              return (f + 1) / 2;
            case "gamma":
              return f * 10;
            case "theta":
              return (f + 0.5) / 1;
            case "vega":
              return f * 2;
            case "rho":
              return (f + 0.5) / 1;
            default:
              return f;
          }
        };
        return Xs(() => {
          if (!r.current) return;
          const u = r.current.clientWidth, d = u * 3 / 4, f = new sb(), g = new mn(45, u / d, 0.1, 1e3), _ = new rw({
            antialias: true
          });
          _.setSize(u, d), _.setPixelRatio(window.devicePixelRatio || 1), r.current.appendChild(_.domElement);
          const m = new xb(16777215, 0.5);
          f.add(m);
          const p = new gb(16777215, 1);
          p.position.set(10, 10, 10), f.add(p);
          const y = new lo(10, 10, n[0].length - 1, n.length - 1);
          let w = 1 / 0, M = -1 / 0;
          n.forEach((lt) => {
            lt.forEach((dt) => {
              const wt = h(dt, t);
              w = Math.min(w, wt), M = Math.max(M, wt);
            });
          });
          const C = {
            min: Math.min(...i),
            max: Math.max(...i)
          }, R = {
            min: Math.min(...s),
            max: Math.max(...s)
          }, T = {
            min: w,
            max: M
          }, v = y.attributes.position.array;
          for (let lt = 0; lt < v.length; lt += 3) {
            const dt = Math.floor(lt / 3) % n[0].length, wt = Math.floor(lt / (3 * n[0].length));
            if (wt < n.length && dt < n[0].length) {
              const bt = h(n[wt][dt], t);
              v[lt + 2] = (bt - w) / (M - w);
            }
          }
          y.computeVertexNormals();
          const x = document.createElement("canvas");
          x.width = n[0].length, x.height = n.length;
          const b = x.getContext("2d");
          for (let lt = 0; lt < n.length; lt++) for (let dt = 0; dt < n[0].length; dt++) {
            const wt = h(n[lt][dt], t), bt = yw(wt, w, M);
            b.fillStyle = `rgb(${bt.r},${bt.g},${bt.b})`, b.fillRect(dt, lt, 1, 1);
          }
          const A = new Yl(x), L = new ub({
            map: A,
            side: Nn,
            shininess: 50,
            specular: new qt(3355443),
            transparent: true,
            opacity: 0.8
          }), I = new Dn(y, L), H = new Ua(new hb(y), new Jr({
            color: 0,
            linewidth: 1,
            opacity: 0.3,
            transparent: true
          }));
          I.rotation.x = -Math.PI / 2, I.position.set(0, 0.5, 0), H.rotation.x = -Math.PI / 2, H.position.set(0, 0.5, 0), f.add(I), f.add(H);
          const j = new cs(10, 1, 10), z = new cb(j), V = new Ua(z, new Jr({
            color: 8947848
          }));
          V.position.set(0, 0.5, 0), f.add(V);
          const U = new yb(10, 10);
          U.position.y = 0, f.add(U);
          const q = new vb(5);
          q.position.y = 0, f.add(q);
          const rt = (lt, dt) => {
            const wt = window.devicePixelRatio || 1, bt = document.createElement("canvas");
            bt.width = 512 * wt, bt.height = 128 * wt;
            const D = bt.getContext("2d");
            D.scale(wt, wt), D.fillStyle = "white", D.font = "48px -apple-system, Times, serif", D.textAlign = "center", D.textBaseline = "middle", D.imageSmoothingEnabled = true, D.imageSmoothingQuality = "high", D.fillText(lt, bt.width / (2 * wt), bt.height / (2 * wt));
            const zt = new Yl(bt);
            zt.minFilter = _n, zt.magFilter = _n;
            const ft = new hh({
              map: zt
            }), Lt = new yd(ft);
            return Lt.position.copy(dt), Lt.scale.set(2, 1, 1), Lt;
          }, et = rt(`Strike (${C.min.toFixed(2)}-${C.max.toFixed(2)})`, new O(5.5, 0, 0)), ut = rt(`Vol (${R.min.toFixed(2)}-${R.max.toFixed(2)})`, new O(0, 0, 5.5)), ot = rt(`Value (${T.min.toFixed(2)}-${T.max.toFixed(2)})`, new O(0, 3, 0));
          f.add(et), f.add(ut), f.add(ot);
          const W = (lt, dt, wt = 5) => {
            const bt = new Or(), D = 10 / (wt - 1), zt = (lt.max - lt.min) / (wt - 1);
            for (let ft = 0; ft < wt; ft++) {
              const Lt = new cs(0.1, 0.1, 0.1), st = new qh({
                color: 13421772
              }), Rt = new Dn(Lt, st);
              switch (dt) {
                case "x":
                  Rt.position.set(-5 + ft * D, 0, -5);
                  break;
                case "y":
                  Rt.position.set(-5, ft * 0.1, -5);
                  break;
                case "z":
                  Rt.position.set(-5, 0, -5 + ft * D);
                  break;
              }
              const Et = (lt.min + ft * zt).toFixed(2), P = window.devicePixelRatio || 1, S = document.createElement("canvas");
              S.width = 64 * P, S.height = 32 * P;
              const B = S.getContext("2d");
              B.scale(P, P), B.fillStyle = "white", B.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif', B.textAlign = "center", B.textBaseline = "middle", B.fillText(Et, S.width / (2 * P), S.height / (2 * P));
              const K = new Yl(S);
              K.minFilter = _n;
              const Q = new hh({
                map: K
              }), X = new yd(Q);
              switch (X.scale.set(0.5, 0.25, 1), dt) {
                case "x":
                  X.position.set(-5 + ft * D, -0.3, -5);
                  break;
                case "y":
                  X.position.set(-5.5, ft * 0.1, -5);
                  break;
                case "z":
                  X.position.set(-5, -0.3, -5 + ft * D);
                  break;
              }
              bt.add(Rt), bt.add(X);
            }
            return bt;
          }, J = W(C, "x"), ct = W(T, "y"), ht = W({
            min: R.min * 100,
            max: R.max * 100
          }, "z");
          f.add(J), f.add(ct), f.add(ht), g.position.set(8, 2, 8), g.lookAt(0, 0.5, 0);
          const it = new aw(g, _.domElement);
          it.enableDamping = true, it.dampingFactor = 0.05, it.target.set(0, 0.5, 0), it.minPolarAngle = 0, it.maxPolarAngle = Math.PI / 2, it.minDistance = 5, it.maxDistance = 20;
          function St() {
            requestAnimationFrame(St), it.update(), _.render(f, g);
          }
          return St(), o.current = {
            scene: f,
            camera: g,
            renderer: _,
            controls: it
          }, () => {
            it.dispose(), _.dispose(), r.current && r.current.removeChild(_.domElement);
          };
        }, [
          n,
          t
        ]), Xs(() => {
          const u = () => {
            if (!r.current || !o.current) return;
            const { camera: d, renderer: f } = o.current, g = r.current.clientWidth, _ = a ? window.innerHeight : g * 3 / 4;
            d.aspect = g / _, d.updateProjectionMatrix(), f.setSize(g, _);
          };
          return window.addEventListener("resize", u), () => window.removeEventListener("resize", u);
        }, [
          a
        ]), $("div", {
          class: `relative ${a ? "w-screen h-screen" : "w-full aspect-[4/3]"} 
        bg-gray-900 rounded-lg overflow-hidden`,
          ref: r,
          children: $("div", {
            class: "absolute top-0 left-0 right-0 z-10 flex justify-between items-center p-2 bg-gradient-to-b from-black/50 to-transparent",
            children: [
              $("div", {
                class: "text-white font-bold",
                children: e
              }),
              $("button", {
                onClick: c,
                class: "p-2 rounded-lg bg-gray-800/50 hover:bg-gray-700/50 transition-colors text-white",
                title: a ? "Exit Fullscreen" : "Enter Fullscreen",
                children: a ? $("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  class: "h-5 w-5",
                  viewBox: "0 0 20 20",
                  fill: "currentColor",
                  children: $("path", {
                    "fill-rule": "evenodd",
                    d: "M5 4a1 1 0 0 0-1 1v3a1 1 0 0 1-2 0V5a3 3 0 0 1 3-3h3a1 1 0 0 1 0 2H5zm10 0h-3a1 1 0 0 1 0-2h3a3 3 0 0 1 3 3v3a1 1 0 1 1-2 0V5a1 1 0 0 0-1-1zM5 16a1 1 0 0 0 1-1v-3a1 1 0 1 1 2 0v3a3 3 0 0 1-3 3H2a1 1 0 1 1 0-2h3zm10 0h3a1 1 0 1 1 0 2h-3a3 3 0 0 1-3-3v-3a1 1 0 1 1 2 0v3a1 1 0 0 0 1 1z"
                  })
                }) : $("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  class: "h-5 w-5",
                  viewBox: "0 0 20 20",
                  fill: "currentColor",
                  children: $("path", {
                    "fill-rule": "evenodd",
                    d: "M3 4a1 1 0 0 1 1-1h3a1 1 0 0 1 0 2H4v3a1 1 0 0 1-2 0V4zm13-1h-3a1 1 0 1 0 0 2h3v3a1 1 0 1 0 2 0V4a1 1 0 0 0-1-1zM3 16a1 1 0 0 0 1 1h3a1 1 0 1 0 0-2H4v-3a1 1 0 1 0-2 0v3a1 1 0 0 0 1 1zm13 1h3a1 1 0 1 0 0-2h-3v-3a1 1 0 1 0-2 0v3a1 1 0 0 0 1 1z"
                  })
                })
              })
            ]
          })
        });
      };
      function co(n) {
        return n + 0.5 | 0;
      }
      const vi = (n, t, e) => Math.max(Math.min(n, e), t);
      function Fr(n) {
        return vi(co(n * 2.55), 0, 255);
      }
      function Ai(n) {
        return vi(co(n * 255), 0, 255);
      }
      function ni(n) {
        return vi(co(n / 2.55) / 100, 0, 1);
      }
      function rf(n) {
        return vi(co(n * 100), 0, 100);
      }
      const Mn = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15
      }, dh = [
        ..."0123456789ABCDEF"
      ], vw = (n) => dh[n & 15], Mw = (n) => dh[(n & 240) >> 4] + dh[n & 15], ta = (n) => (n & 240) >> 4 === (n & 15), Sw = (n) => ta(n.r) && ta(n.g) && ta(n.b) && ta(n.a);
      function ww(n) {
        var t = n.length, e;
        return n[0] === "#" && (t === 4 || t === 5 ? e = {
          r: 255 & Mn[n[1]] * 17,
          g: 255 & Mn[n[2]] * 17,
          b: 255 & Mn[n[3]] * 17,
          a: t === 5 ? Mn[n[4]] * 17 : 255
        } : (t === 7 || t === 9) && (e = {
          r: Mn[n[1]] << 4 | Mn[n[2]],
          g: Mn[n[3]] << 4 | Mn[n[4]],
          b: Mn[n[5]] << 4 | Mn[n[6]],
          a: t === 9 ? Mn[n[7]] << 4 | Mn[n[8]] : 255
        })), e;
      }
      const Ew = (n, t) => n < 255 ? t(n) : "";
      function Tw(n) {
        var t = Sw(n) ? vw : Mw;
        return n ? "#" + t(n.r) + t(n.g) + t(n.b) + Ew(n.a, t) : void 0;
      }
      const Aw = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
      function $m(n, t, e) {
        const i = t * Math.min(e, 1 - e), s = (r, o = (r + n / 30) % 12) => e - i * Math.max(Math.min(o - 3, 9 - o, 1), -1);
        return [
          s(0),
          s(8),
          s(4)
        ];
      }
      function Cw(n, t, e) {
        const i = (s, r = (s + n / 60) % 6) => e - e * t * Math.max(Math.min(r, 4 - r, 1), 0);
        return [
          i(5),
          i(3),
          i(1)
        ];
      }
      function Rw(n, t, e) {
        const i = $m(n, 1, 0.5);
        let s;
        for (t + e > 1 && (s = 1 / (t + e), t *= s, e *= s), s = 0; s < 3; s++) i[s] *= 1 - t - e, i[s] += t;
        return i;
      }
      function Pw(n, t, e, i, s) {
        return n === s ? (t - e) / i + (t < e ? 6 : 0) : t === s ? (e - n) / i + 2 : (n - t) / i + 4;
      }
      function Qh(n) {
        const e = n.r / 255, i = n.g / 255, s = n.b / 255, r = Math.max(e, i, s), o = Math.min(e, i, s), a = (r + o) / 2;
        let l, c, h;
        return r !== o && (h = r - o, c = a > 0.5 ? h / (2 - r - o) : h / (r + o), l = Pw(e, i, s, h, r), l = l * 60 + 0.5), [
          l | 0,
          c || 0,
          a
        ];
      }
      function Jh(n, t, e, i) {
        return (Array.isArray(t) ? n(t[0], t[1], t[2]) : n(t, e, i)).map(Ai);
      }
      function tu(n, t, e) {
        return Jh($m, n, t, e);
      }
      function Dw(n, t, e) {
        return Jh(Rw, n, t, e);
      }
      function Lw(n, t, e) {
        return Jh(Cw, n, t, e);
      }
      function Km(n) {
        return (n % 360 + 360) % 360;
      }
      function Iw(n) {
        const t = Aw.exec(n);
        let e = 255, i;
        if (!t) return;
        t[5] !== i && (e = t[6] ? Fr(+t[5]) : Ai(+t[5]));
        const s = Km(+t[2]), r = +t[3] / 100, o = +t[4] / 100;
        return t[1] === "hwb" ? i = Dw(s, r, o) : t[1] === "hsv" ? i = Lw(s, r, o) : i = tu(s, r, o), {
          r: i[0],
          g: i[1],
          b: i[2],
          a: e
        };
      }
      function Ow(n, t) {
        var e = Qh(n);
        e[0] = Km(e[0] + t), e = tu(e), n.r = e[0], n.g = e[1], n.b = e[2];
      }
      function kw(n) {
        if (!n) return;
        const t = Qh(n), e = t[0], i = rf(t[1]), s = rf(t[2]);
        return n.a < 255 ? `hsla(${e}, ${i}%, ${s}%, ${ni(n.a)})` : `hsl(${e}, ${i}%, ${s}%)`;
      }
      const of = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
      }, af = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32"
      };
      function Fw() {
        const n = {}, t = Object.keys(af), e = Object.keys(of);
        let i, s, r, o, a;
        for (i = 0; i < t.length; i++) {
          for (o = a = t[i], s = 0; s < e.length; s++) r = e[s], a = a.replace(r, of[r]);
          r = parseInt(af[o], 16), n[a] = [
            r >> 16 & 255,
            r >> 8 & 255,
            r & 255
          ];
        }
        return n;
      }
      let ea;
      function Nw(n) {
        ea || (ea = Fw(), ea.transparent = [
          0,
          0,
          0,
          0
        ]);
        const t = ea[n.toLowerCase()];
        return t && {
          r: t[0],
          g: t[1],
          b: t[2],
          a: t.length === 4 ? t[3] : 255
        };
      }
      const Uw = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
      function Bw(n) {
        const t = Uw.exec(n);
        let e = 255, i, s, r;
        if (t) {
          if (t[7] !== i) {
            const o = +t[7];
            e = t[8] ? Fr(o) : vi(o * 255, 0, 255);
          }
          return i = +t[1], s = +t[3], r = +t[5], i = 255 & (t[2] ? Fr(i) : vi(i, 0, 255)), s = 255 & (t[4] ? Fr(s) : vi(s, 0, 255)), r = 255 & (t[6] ? Fr(r) : vi(r, 0, 255)), {
            r: i,
            g: s,
            b: r,
            a: e
          };
        }
      }
      function zw(n) {
        return n && (n.a < 255 ? `rgba(${n.r}, ${n.g}, ${n.b}, ${ni(n.a)})` : `rgb(${n.r}, ${n.g}, ${n.b})`);
      }
      const ic = (n) => n <= 31308e-7 ? n * 12.92 : Math.pow(n, 1 / 2.4) * 1.055 - 0.055, Bs = (n) => n <= 0.04045 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
      function Hw(n, t, e) {
        const i = Bs(ni(n.r)), s = Bs(ni(n.g)), r = Bs(ni(n.b));
        return {
          r: Ai(ic(i + e * (Bs(ni(t.r)) - i))),
          g: Ai(ic(s + e * (Bs(ni(t.g)) - s))),
          b: Ai(ic(r + e * (Bs(ni(t.b)) - r))),
          a: n.a + e * (t.a - n.a)
        };
      }
      function na(n, t, e) {
        if (n) {
          let i = Qh(n);
          i[t] = Math.max(0, Math.min(i[t] + i[t] * e, t === 0 ? 360 : 1)), i = tu(i), n.r = i[0], n.g = i[1], n.b = i[2];
        }
      }
      function Zm(n, t) {
        return n && Object.assign(t || {}, n);
      }
      function lf(n) {
        var t = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
        return Array.isArray(n) ? n.length >= 3 && (t = {
          r: n[0],
          g: n[1],
          b: n[2],
          a: 255
        }, n.length > 3 && (t.a = Ai(n[3]))) : (t = Zm(n, {
          r: 0,
          g: 0,
          b: 0,
          a: 1
        }), t.a = Ai(t.a)), t;
      }
      function Vw(n) {
        return n.charAt(0) === "r" ? Bw(n) : Iw(n);
      }
      class to {
        constructor(t) {
          if (t instanceof to) return t;
          const e = typeof t;
          let i;
          e === "object" ? i = lf(t) : e === "string" && (i = ww(t) || Nw(t) || Vw(t)), this._rgb = i, this._valid = !!i;
        }
        get valid() {
          return this._valid;
        }
        get rgb() {
          var t = Zm(this._rgb);
          return t && (t.a = ni(t.a)), t;
        }
        set rgb(t) {
          this._rgb = lf(t);
        }
        rgbString() {
          return this._valid ? zw(this._rgb) : void 0;
        }
        hexString() {
          return this._valid ? Tw(this._rgb) : void 0;
        }
        hslString() {
          return this._valid ? kw(this._rgb) : void 0;
        }
        mix(t, e) {
          if (t) {
            const i = this.rgb, s = t.rgb;
            let r;
            const o = e === r ? 0.5 : e, a = 2 * o - 1, l = i.a - s.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
            r = 1 - c, i.r = 255 & c * i.r + r * s.r + 0.5, i.g = 255 & c * i.g + r * s.g + 0.5, i.b = 255 & c * i.b + r * s.b + 0.5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i;
          }
          return this;
        }
        interpolate(t, e) {
          return t && (this._rgb = Hw(this._rgb, t._rgb, e)), this;
        }
        clone() {
          return new to(this.rgb);
        }
        alpha(t) {
          return this._rgb.a = Ai(t), this;
        }
        clearer(t) {
          const e = this._rgb;
          return e.a *= 1 - t, this;
        }
        greyscale() {
          const t = this._rgb, e = co(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
          return t.r = t.g = t.b = e, this;
        }
        opaquer(t) {
          const e = this._rgb;
          return e.a *= 1 + t, this;
        }
        negate() {
          const t = this._rgb;
          return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
        }
        lighten(t) {
          return na(this._rgb, 2, t), this;
        }
        darken(t) {
          return na(this._rgb, 2, -t), this;
        }
        saturate(t) {
          return na(this._rgb, 1, t), this;
        }
        desaturate(t) {
          return na(this._rgb, 1, -t), this;
        }
        rotate(t) {
          return Ow(this._rgb, t), this;
        }
      }
      function Qn() {
      }
      const Ww = /* @__PURE__ */ (() => {
        let n = 0;
        return () => n++;
      })();
      function Kt(n) {
        return n == null;
      }
      function oe(n) {
        if (Array.isArray && Array.isArray(n)) return true;
        const t = Object.prototype.toString.call(n);
        return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
      }
      function Wt(n) {
        return n !== null && Object.prototype.toString.call(n) === "[object Object]";
      }
      function Me(n) {
        return (typeof n == "number" || n instanceof Number) && isFinite(+n);
      }
      function fn(n, t) {
        return Me(n) ? n : t;
      }
      function Ut(n, t) {
        return typeof n > "u" ? t : n;
      }
      const Gw = (n, t) => typeof n == "string" && n.endsWith("%") ? parseFloat(n) / 100 : +n / t, Qm = (n, t) => typeof n == "string" && n.endsWith("%") ? parseFloat(n) / 100 * t : +n;
      function ce(n, t, e) {
        if (n && typeof n.call == "function") return n.apply(e, t);
      }
      function he(n, t, e, i) {
        let s, r, o;
        if (oe(n)) for (r = n.length, s = 0; s < r; s++) t.call(e, n[s], s);
        else if (Wt(n)) for (o = Object.keys(n), r = o.length, s = 0; s < r; s++) t.call(e, n[o[s]], o[s]);
      }
      function Ba(n, t) {
        let e, i, s, r;
        if (!n || !t || n.length !== t.length) return false;
        for (e = 0, i = n.length; e < i; ++e) if (s = n[e], r = t[e], s.datasetIndex !== r.datasetIndex || s.index !== r.index) return false;
        return true;
      }
      function za(n) {
        if (oe(n)) return n.map(za);
        if (Wt(n)) {
          const t = /* @__PURE__ */ Object.create(null), e = Object.keys(n), i = e.length;
          let s = 0;
          for (; s < i; ++s) t[e[s]] = za(n[e[s]]);
          return t;
        }
        return n;
      }
      function Jm(n) {
        return [
          "__proto__",
          "prototype",
          "constructor"
        ].indexOf(n) === -1;
      }
      function Xw(n, t, e, i) {
        if (!Jm(n)) return;
        const s = t[n], r = e[n];
        Wt(s) && Wt(r) ? eo(s, r, i) : t[n] = za(r);
      }
      function eo(n, t, e) {
        const i = oe(t) ? t : [
          t
        ], s = i.length;
        if (!Wt(n)) return n;
        e = e || {};
        const r = e.merger || Xw;
        let o;
        for (let a = 0; a < s; ++a) {
          if (o = i[a], !Wt(o)) continue;
          const l = Object.keys(o);
          for (let c = 0, h = l.length; c < h; ++c) r(l[c], n, o, e);
        }
        return n;
      }
      function Vr(n, t) {
        return eo(n, t, {
          merger: Yw
        });
      }
      function Yw(n, t, e) {
        if (!Jm(n)) return;
        const i = t[n], s = e[n];
        Wt(i) && Wt(s) ? Vr(i, s) : Object.prototype.hasOwnProperty.call(t, n) || (t[n] = za(s));
      }
      const cf = {
        "": (n) => n,
        x: (n) => n.x,
        y: (n) => n.y
      };
      function jw(n) {
        const t = n.split("."), e = [];
        let i = "";
        for (const s of t) i += s, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (e.push(i), i = "");
        return e;
      }
      function qw(n) {
        const t = jw(n);
        return (e) => {
          for (const i of t) {
            if (i === "") break;
            e = e && e[i];
          }
          return e;
        };
      }
      function Ii(n, t) {
        return (cf[t] || (cf[t] = qw(t)))(n);
      }
      function eu(n) {
        return n.charAt(0).toUpperCase() + n.slice(1);
      }
      const cn = (n) => typeof n < "u", ln = (n) => typeof n == "function", hf = (n, t) => {
        if (n.size !== t.size) return false;
        for (const e of n) if (!t.has(e)) return false;
        return true;
      };
      function $w(n) {
        return n.type === "mouseup" || n.type === "click" || n.type === "contextmenu";
      }
      const Zt = Math.PI, ge = 2 * Zt, Kw = ge + Zt, Ha = Number.POSITIVE_INFINITY, nu = Zt / 180, xe = Zt / 2, wn = Zt / 4, Va = Zt * 2 / 3, Mi = Math.log10, Hn = Math.sign;
      function Wr(n, t, e) {
        return Math.abs(n - t) < e;
      }
      function uf(n) {
        const t = Math.round(n);
        n = Wr(n, t, n / 1e3) ? t : n;
        const e = Math.pow(10, Math.floor(Mi(n))), i = n / e;
        return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * e;
      }
      function Zw(n) {
        const t = [], e = Math.sqrt(n);
        let i;
        for (i = 1; i < e; i++) n % i === 0 && (t.push(i), t.push(n / i));
        return e === (e | 0) && t.push(e), t.sort((s, r) => s - r).pop(), t;
      }
      function Qw(n) {
        return typeof n == "symbol" || typeof n == "object" && n !== null && !(Symbol.toPrimitive in n || "toString" in n || "valueOf" in n);
      }
      function Oi(n) {
        return !Qw(n) && !isNaN(parseFloat(n)) && isFinite(n);
      }
      function Jw(n, t) {
        const e = Math.round(n);
        return e - t <= n && e + t >= n;
      }
      function tg(n, t, e) {
        let i, s, r;
        for (i = 0, s = n.length; i < s; i++) r = n[i][e], isNaN(r) || (t.min = Math.min(t.min, r), t.max = Math.max(t.max, r));
      }
      function ke(n) {
        return n * (Zt / 180);
      }
      function il(n) {
        return n * (180 / Zt);
      }
      function df(n) {
        if (!Me(n)) return;
        let t = 1, e = 0;
        for (; Math.round(n * t) / t !== n; ) t *= 10, e++;
        return e;
      }
      function Wa(n, t) {
        const e = t.x - n.x, i = t.y - n.y, s = Math.sqrt(e * e + i * i);
        let r = Math.atan2(i, e);
        return r < -0.5 * Zt && (r += ge), {
          angle: r,
          distance: s
        };
      }
      function ir(n, t) {
        return Math.sqrt(Math.pow(t.x - n.x, 2) + Math.pow(t.y - n.y, 2));
      }
      function tE(n, t) {
        return (n - t + Kw) % ge - Zt;
      }
      function pn(n) {
        return (n % ge + ge) % ge;
      }
      function no(n, t, e, i) {
        const s = pn(n), r = pn(t), o = pn(e), a = pn(r - s), l = pn(o - s), c = pn(s - r), h = pn(s - o);
        return s === r || s === o || i && r === o || a > l && c < h;
      }
      function Ve(n, t, e) {
        return Math.max(t, Math.min(e, n));
      }
      function eE(n) {
        return Ve(n, -32768, 32767);
      }
      function oi(n, t, e, i = 1e-6) {
        return n >= Math.min(t, e) - i && n <= Math.max(t, e) + i;
      }
      function iu(n, t, e) {
        e = e || ((o) => n[o] < t);
        let i = n.length - 1, s = 0, r;
        for (; i - s > 1; ) r = s + i >> 1, e(r) ? s = r : i = r;
        return {
          lo: s,
          hi: i
        };
      }
      const ai = (n, t, e, i) => iu(n, e, i ? (s) => {
        const r = n[s][t];
        return r < e || r === e && n[s + 1][t] === e;
      } : (s) => n[s][t] < e), nE = (n, t, e) => iu(n, e, (i) => n[i][t] >= e);
      function iE(n, t, e) {
        let i = 0, s = n.length;
        for (; i < s && n[i] < t; ) i++;
        for (; s > i && n[s - 1] > e; ) s--;
        return i > 0 || s < n.length ? n.slice(i, s) : n;
      }
      const eg = [
        "push",
        "pop",
        "shift",
        "splice",
        "unshift"
      ];
      function sE(n, t) {
        if (n._chartjs) {
          n._chartjs.listeners.push(t);
          return;
        }
        Object.defineProperty(n, "_chartjs", {
          configurable: true,
          enumerable: false,
          value: {
            listeners: [
              t
            ]
          }
        }), eg.forEach((e) => {
          const i = "_onData" + eu(e), s = n[e];
          Object.defineProperty(n, e, {
            configurable: true,
            enumerable: false,
            value(...r) {
              const o = s.apply(this, r);
              return n._chartjs.listeners.forEach((a) => {
                typeof a[i] == "function" && a[i](...r);
              }), o;
            }
          });
        });
      }
      function ff(n, t) {
        const e = n._chartjs;
        if (!e) return;
        const i = e.listeners, s = i.indexOf(t);
        s !== -1 && i.splice(s, 1), !(i.length > 0) && (eg.forEach((r) => {
          delete n[r];
        }), delete n._chartjs);
      }
      function ng(n) {
        const t = new Set(n);
        return t.size === n.length ? n : Array.from(t);
      }
      const ig = function() {
        return typeof window > "u" ? function(n) {
          return n();
        } : window.requestAnimationFrame;
      }();
      function sg(n, t) {
        let e = [], i = false;
        return function(...s) {
          e = s, i || (i = true, ig.call(window, () => {
            i = false, n.apply(t, e);
          }));
        };
      }
      function rE(n, t) {
        let e;
        return function(...i) {
          return t ? (clearTimeout(e), e = setTimeout(n, t, i)) : n.apply(this, i), t;
        };
      }
      const su = (n) => n === "start" ? "left" : n === "end" ? "right" : "center", je = (n, t, e) => n === "start" ? t : n === "end" ? e : (t + e) / 2, oE = (n, t, e, i) => n === (i ? "left" : "right") ? e : n === "center" ? (t + e) / 2 : t;
      function rg(n, t, e) {
        const i = t.length;
        let s = 0, r = i;
        if (n._sorted) {
          const { iScale: o, vScale: a, _parsed: l } = n, c = n.dataset && n.dataset.options ? n.dataset.options.spanGaps : null, h = o.axis, { min: u, max: d, minDefined: f, maxDefined: g } = o.getUserBounds();
          if (f) {
            if (s = Math.min(ai(l, h, u).lo, e ? i : ai(t, h, o.getPixelForValue(u)).lo), c) {
              const _ = l.slice(0, s + 1).reverse().findIndex((m) => !Kt(m[a.axis]));
              s -= Math.max(0, _);
            }
            s = Ve(s, 0, i - 1);
          }
          if (g) {
            let _ = Math.max(ai(l, o.axis, d, true).hi + 1, e ? 0 : ai(t, h, o.getPixelForValue(d), true).hi + 1);
            if (c) {
              const m = l.slice(_ - 1).findIndex((p) => !Kt(p[a.axis]));
              _ += Math.max(0, m);
            }
            r = Ve(_, s, i) - s;
          } else r = i - s;
        }
        return {
          start: s,
          count: r
        };
      }
      function og(n) {
        const { xScale: t, yScale: e, _scaleRanges: i } = n, s = {
          xmin: t.min,
          xmax: t.max,
          ymin: e.min,
          ymax: e.max
        };
        if (!i) return n._scaleRanges = s, true;
        const r = i.xmin !== t.min || i.xmax !== t.max || i.ymin !== e.min || i.ymax !== e.max;
        return Object.assign(i, s), r;
      }
      const ia = (n) => n === 0 || n === 1, pf = (n, t, e) => -(Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * ge / e)), mf = (n, t, e) => Math.pow(2, -10 * n) * Math.sin((n - t) * ge / e) + 1, Gr = {
        linear: (n) => n,
        easeInQuad: (n) => n * n,
        easeOutQuad: (n) => -n * (n - 2),
        easeInOutQuad: (n) => (n /= 0.5) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1),
        easeInCubic: (n) => n * n * n,
        easeOutCubic: (n) => (n -= 1) * n * n + 1,
        easeInOutCubic: (n) => (n /= 0.5) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2),
        easeInQuart: (n) => n * n * n * n,
        easeOutQuart: (n) => -((n -= 1) * n * n * n - 1),
        easeInOutQuart: (n) => (n /= 0.5) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2),
        easeInQuint: (n) => n * n * n * n * n,
        easeOutQuint: (n) => (n -= 1) * n * n * n * n + 1,
        easeInOutQuint: (n) => (n /= 0.5) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2),
        easeInSine: (n) => -Math.cos(n * xe) + 1,
        easeOutSine: (n) => Math.sin(n * xe),
        easeInOutSine: (n) => -0.5 * (Math.cos(Zt * n) - 1),
        easeInExpo: (n) => n === 0 ? 0 : Math.pow(2, 10 * (n - 1)),
        easeOutExpo: (n) => n === 1 ? 1 : -Math.pow(2, -10 * n) + 1,
        easeInOutExpo: (n) => ia(n) ? n : n < 0.5 ? 0.5 * Math.pow(2, 10 * (n * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (n * 2 - 1)) + 2),
        easeInCirc: (n) => n >= 1 ? n : -(Math.sqrt(1 - n * n) - 1),
        easeOutCirc: (n) => Math.sqrt(1 - (n -= 1) * n),
        easeInOutCirc: (n) => (n /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1),
        easeInElastic: (n) => ia(n) ? n : pf(n, 0.075, 0.3),
        easeOutElastic: (n) => ia(n) ? n : mf(n, 0.075, 0.3),
        easeInOutElastic(n) {
          return ia(n) ? n : n < 0.5 ? 0.5 * pf(n * 2, 0.1125, 0.45) : 0.5 + 0.5 * mf(n * 2 - 1, 0.1125, 0.45);
        },
        easeInBack(n) {
          return n * n * ((1.70158 + 1) * n - 1.70158);
        },
        easeOutBack(n) {
          return (n -= 1) * n * ((1.70158 + 1) * n + 1.70158) + 1;
        },
        easeInOutBack(n) {
          let t = 1.70158;
          return (n /= 0.5) < 1 ? 0.5 * (n * n * (((t *= 1.525) + 1) * n - t)) : 0.5 * ((n -= 2) * n * (((t *= 1.525) + 1) * n + t) + 2);
        },
        easeInBounce: (n) => 1 - Gr.easeOutBounce(1 - n),
        easeOutBounce(n) {
          return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
        },
        easeInOutBounce: (n) => n < 0.5 ? Gr.easeInBounce(n * 2) * 0.5 : Gr.easeOutBounce(n * 2 - 1) * 0.5 + 0.5
      };
      function ru(n) {
        if (n && typeof n == "object") {
          const t = n.toString();
          return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
        }
        return false;
      }
      function gf(n) {
        return ru(n) ? n : new to(n);
      }
      function sc(n) {
        return ru(n) ? n : new to(n).saturate(0.5).darken(0.1).hexString();
      }
      const aE = [
        "x",
        "y",
        "borderWidth",
        "radius",
        "tension"
      ], lE = [
        "color",
        "borderColor",
        "backgroundColor"
      ];
      function cE(n) {
        n.set("animation", {
          delay: void 0,
          duration: 1e3,
          easing: "easeOutQuart",
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0
        }), n.describe("animation", {
          _fallback: false,
          _indexable: false,
          _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
        }), n.set("animations", {
          colors: {
            type: "color",
            properties: lE
          },
          numbers: {
            type: "number",
            properties: aE
          }
        }), n.describe("animations", {
          _fallback: "animation"
        }), n.set("transitions", {
          active: {
            animation: {
              duration: 400
            }
          },
          resize: {
            animation: {
              duration: 0
            }
          },
          show: {
            animations: {
              colors: {
                from: "transparent"
              },
              visible: {
                type: "boolean",
                duration: 0
              }
            }
          },
          hide: {
            animations: {
              colors: {
                to: "transparent"
              },
              visible: {
                type: "boolean",
                easing: "linear",
                fn: (t) => t | 0
              }
            }
          }
        });
      }
      function hE(n) {
        n.set("layout", {
          autoPadding: true,
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        });
      }
      const _f = /* @__PURE__ */ new Map();
      function uE(n, t) {
        t = t || {};
        const e = n + JSON.stringify(t);
        let i = _f.get(e);
        return i || (i = new Intl.NumberFormat(n, t), _f.set(e, i)), i;
      }
      function ho(n, t, e) {
        return uE(t, e).format(n);
      }
      const ag = {
        values(n) {
          return oe(n) ? n : "" + n;
        },
        numeric(n, t, e) {
          if (n === 0) return "0";
          const i = this.chart.options.locale;
          let s, r = n;
          if (e.length > 1) {
            const c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));
            (c < 1e-4 || c > 1e15) && (s = "scientific"), r = dE(n, e);
          }
          const o = Mi(Math.abs(r)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = {
            notation: s,
            minimumFractionDigits: a,
            maximumFractionDigits: a
          };
          return Object.assign(l, this.options.ticks.format), ho(n, i, l);
        },
        logarithmic(n, t, e) {
          if (n === 0) return "0";
          const i = e[t].significand || n / Math.pow(10, Math.floor(Mi(n)));
          return [
            1,
            2,
            3,
            5,
            10,
            15
          ].includes(i) || t > 0.8 * e.length ? ag.numeric.call(this, n, t, e) : "";
        }
      };
      function dE(n, t) {
        let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
        return Math.abs(e) >= 1 && n !== Math.floor(n) && (e = n - Math.floor(n)), e;
      }
      var sl = {
        formatters: ag
      };
      function fE(n) {
        n.set("scale", {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
          bounds: "ticks",
          clip: true,
          grace: 0,
          grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (t, e) => e.lineWidth,
            tickColor: (t, e) => e.color,
            offset: false
          },
          border: {
            display: true,
            dash: [],
            dashOffset: 0,
            width: 1
          },
          title: {
            display: false,
            text: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: sl.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
          }
        }), n.route("scale.ticks", "color", "", "color"), n.route("scale.grid", "color", "", "borderColor"), n.route("scale.border", "color", "", "borderColor"), n.route("scale.title", "color", "", "color"), n.describe("scale", {
          _fallback: false,
          _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
          _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
        }), n.describe("scales", {
          _fallback: "scale"
        }), n.describe("scale.ticks", {
          _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
          _indexable: (t) => t !== "backdropPadding"
        });
      }
      const hs = /* @__PURE__ */ Object.create(null), fh = /* @__PURE__ */ Object.create(null);
      function Xr(n, t) {
        if (!t) return n;
        const e = t.split(".");
        for (let i = 0, s = e.length; i < s; ++i) {
          const r = e[i];
          n = n[r] || (n[r] = /* @__PURE__ */ Object.create(null));
        }
        return n;
      }
      function rc(n, t, e) {
        return typeof t == "string" ? eo(Xr(n, t), e) : eo(Xr(n, ""), t);
      }
      class pE {
        constructor(t, e) {
          this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (i) => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ], this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
          }, this.hover = {}, this.hoverBackgroundColor = (i, s) => sc(s.backgroundColor), this.hoverBorderColor = (i, s) => sc(s.borderColor), this.hoverColor = (i, s) => sc(s.color), this.indexAxis = "x", this.interaction = {
            mode: "nearest",
            intersect: true,
            includeInvisible: false
          }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(t), this.apply(e);
        }
        set(t, e) {
          return rc(this, t, e);
        }
        get(t) {
          return Xr(this, t);
        }
        describe(t, e) {
          return rc(fh, t, e);
        }
        override(t, e) {
          return rc(hs, t, e);
        }
        route(t, e, i, s) {
          const r = Xr(this, t), o = Xr(this, i), a = "_" + e;
          Object.defineProperties(r, {
            [a]: {
              value: r[e],
              writable: true
            },
            [e]: {
              enumerable: true,
              get() {
                const l = this[a], c = o[s];
                return Wt(l) ? Object.assign({}, c, l) : Ut(l, c);
              },
              set(l) {
                this[a] = l;
              }
            }
          });
        }
        apply(t) {
          t.forEach((e) => e(this));
        }
      }
      var be = new pE({
        _scriptable: (n) => !n.startsWith("on"),
        _indexable: (n) => n !== "events",
        hover: {
          _fallback: "interaction"
        },
        interaction: {
          _scriptable: false,
          _indexable: false
        }
      }, [
        cE,
        hE,
        fE
      ]);
      function mE(n) {
        return !n || Kt(n.size) || Kt(n.family) ? null : (n.style ? n.style + " " : "") + (n.weight ? n.weight + " " : "") + n.size + "px " + n.family;
      }
      function Ga(n, t, e, i, s) {
        let r = t[s];
        return r || (r = t[s] = n.measureText(s).width, e.push(s)), r > i && (i = r), i;
      }
      function gE(n, t, e, i) {
        i = i || {};
        let s = i.data = i.data || {}, r = i.garbageCollect = i.garbageCollect || [];
        i.font !== t && (s = i.data = {}, r = i.garbageCollect = [], i.font = t), n.save(), n.font = t;
        let o = 0;
        const a = e.length;
        let l, c, h, u, d;
        for (l = 0; l < a; l++) if (u = e[l], u != null && !oe(u)) o = Ga(n, s, r, o, u);
        else if (oe(u)) for (c = 0, h = u.length; c < h; c++) d = u[c], d != null && !oe(d) && (o = Ga(n, s, r, o, d));
        n.restore();
        const f = r.length / 2;
        if (f > e.length) {
          for (l = 0; l < f; l++) delete s[r[l]];
          r.splice(0, f);
        }
        return o;
      }
      function Yi(n, t, e) {
        const i = n.currentDevicePixelRatio, s = e !== 0 ? Math.max(e / 2, 0.5) : 0;
        return Math.round((t - s) * i) / i + s;
      }
      function xf(n, t) {
        !t && !n || (t = t || n.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, n.width, n.height), t.restore());
      }
      function ph(n, t, e, i) {
        lg(n, t, e, i, null);
      }
      function lg(n, t, e, i, s) {
        let r, o, a, l, c, h, u, d;
        const f = t.pointStyle, g = t.rotation, _ = t.radius;
        let m = (g || 0) * nu;
        if (f && typeof f == "object" && (r = f.toString(), r === "[object HTMLImageElement]" || r === "[object HTMLCanvasElement]")) {
          n.save(), n.translate(e, i), n.rotate(m), n.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), n.restore();
          return;
        }
        if (!(isNaN(_) || _ <= 0)) {
          switch (n.beginPath(), f) {
            default:
              s ? n.ellipse(e, i, s / 2, _, 0, 0, ge) : n.arc(e, i, _, 0, ge), n.closePath();
              break;
            case "triangle":
              h = s ? s / 2 : _, n.moveTo(e + Math.sin(m) * h, i - Math.cos(m) * _), m += Va, n.lineTo(e + Math.sin(m) * h, i - Math.cos(m) * _), m += Va, n.lineTo(e + Math.sin(m) * h, i - Math.cos(m) * _), n.closePath();
              break;
            case "rectRounded":
              c = _ * 0.516, l = _ - c, o = Math.cos(m + wn) * l, u = Math.cos(m + wn) * (s ? s / 2 - c : l), a = Math.sin(m + wn) * l, d = Math.sin(m + wn) * (s ? s / 2 - c : l), n.arc(e - u, i - a, c, m - Zt, m - xe), n.arc(e + d, i - o, c, m - xe, m), n.arc(e + u, i + a, c, m, m + xe), n.arc(e - d, i + o, c, m + xe, m + Zt), n.closePath();
              break;
            case "rect":
              if (!g) {
                l = Math.SQRT1_2 * _, h = s ? s / 2 : l, n.rect(e - h, i - l, 2 * h, 2 * l);
                break;
              }
              m += wn;
            case "rectRot":
              u = Math.cos(m) * (s ? s / 2 : _), o = Math.cos(m) * _, a = Math.sin(m) * _, d = Math.sin(m) * (s ? s / 2 : _), n.moveTo(e - u, i - a), n.lineTo(e + d, i - o), n.lineTo(e + u, i + a), n.lineTo(e - d, i + o), n.closePath();
              break;
            case "crossRot":
              m += wn;
            case "cross":
              u = Math.cos(m) * (s ? s / 2 : _), o = Math.cos(m) * _, a = Math.sin(m) * _, d = Math.sin(m) * (s ? s / 2 : _), n.moveTo(e - u, i - a), n.lineTo(e + u, i + a), n.moveTo(e + d, i - o), n.lineTo(e - d, i + o);
              break;
            case "star":
              u = Math.cos(m) * (s ? s / 2 : _), o = Math.cos(m) * _, a = Math.sin(m) * _, d = Math.sin(m) * (s ? s / 2 : _), n.moveTo(e - u, i - a), n.lineTo(e + u, i + a), n.moveTo(e + d, i - o), n.lineTo(e - d, i + o), m += wn, u = Math.cos(m) * (s ? s / 2 : _), o = Math.cos(m) * _, a = Math.sin(m) * _, d = Math.sin(m) * (s ? s / 2 : _), n.moveTo(e - u, i - a), n.lineTo(e + u, i + a), n.moveTo(e + d, i - o), n.lineTo(e - d, i + o);
              break;
            case "line":
              o = s ? s / 2 : Math.cos(m) * _, a = Math.sin(m) * _, n.moveTo(e - o, i - a), n.lineTo(e + o, i + a);
              break;
            case "dash":
              n.moveTo(e, i), n.lineTo(e + Math.cos(m) * (s ? s / 2 : _), i + Math.sin(m) * _);
              break;
            case false:
              n.closePath();
              break;
          }
          n.fill(), t.borderWidth > 0 && n.stroke();
        }
      }
      function li(n, t, e) {
        return e = e || 0.5, !t || n && n.x > t.left - e && n.x < t.right + e && n.y > t.top - e && n.y < t.bottom + e;
      }
      function uo(n, t) {
        n.save(), n.beginPath(), n.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), n.clip();
      }
      function fo(n) {
        n.restore();
      }
      function _E(n, t, e, i, s) {
        if (!t) return n.lineTo(e.x, e.y);
        if (s === "middle") {
          const r = (t.x + e.x) / 2;
          n.lineTo(r, t.y), n.lineTo(r, e.y);
        } else s === "after" != !!i ? n.lineTo(t.x, e.y) : n.lineTo(e.x, t.y);
        n.lineTo(e.x, e.y);
      }
      function xE(n, t, e, i) {
        if (!t) return n.lineTo(e.x, e.y);
        n.bezierCurveTo(i ? t.cp1x : t.cp2x, i ? t.cp1y : t.cp2y, i ? e.cp2x : e.cp1x, i ? e.cp2y : e.cp1y, e.x, e.y);
      }
      function bE(n, t) {
        t.translation && n.translate(t.translation[0], t.translation[1]), Kt(t.rotation) || n.rotate(t.rotation), t.color && (n.fillStyle = t.color), t.textAlign && (n.textAlign = t.textAlign), t.textBaseline && (n.textBaseline = t.textBaseline);
      }
      function yE(n, t, e, i, s) {
        if (s.strikethrough || s.underline) {
          const r = n.measureText(i), o = t - r.actualBoundingBoxLeft, a = t + r.actualBoundingBoxRight, l = e - r.actualBoundingBoxAscent, c = e + r.actualBoundingBoxDescent, h = s.strikethrough ? (l + c) / 2 : c;
          n.strokeStyle = n.fillStyle, n.beginPath(), n.lineWidth = s.decorationWidth || 2, n.moveTo(o, h), n.lineTo(a, h), n.stroke();
        }
      }
      function vE(n, t) {
        const e = n.fillStyle;
        n.fillStyle = t.color, n.fillRect(t.left, t.top, t.width, t.height), n.fillStyle = e;
      }
      function us(n, t, e, i, s, r = {}) {
        const o = oe(t) ? t : [
          t
        ], a = r.strokeWidth > 0 && r.strokeColor !== "";
        let l, c;
        for (n.save(), n.font = s.string, bE(n, r), l = 0; l < o.length; ++l) c = o[l], r.backdrop && vE(n, r.backdrop), a && (r.strokeColor && (n.strokeStyle = r.strokeColor), Kt(r.strokeWidth) || (n.lineWidth = r.strokeWidth), n.strokeText(c, e, i, r.maxWidth)), n.fillText(c, e, i, r.maxWidth), yE(n, e, i, c, r), i += Number(s.lineHeight);
        n.restore();
      }
      function sr(n, t) {
        const { x: e, y: i, w: s, h: r, radius: o } = t;
        n.arc(e + o.topLeft, i + o.topLeft, o.topLeft, 1.5 * Zt, Zt, true), n.lineTo(e, i + r - o.bottomLeft), n.arc(e + o.bottomLeft, i + r - o.bottomLeft, o.bottomLeft, Zt, xe, true), n.lineTo(e + s - o.bottomRight, i + r), n.arc(e + s - o.bottomRight, i + r - o.bottomRight, o.bottomRight, xe, 0, true), n.lineTo(e + s, i + o.topRight), n.arc(e + s - o.topRight, i + o.topRight, o.topRight, 0, -xe, true), n.lineTo(e + o.topLeft, i);
      }
      const ME = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, SE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
      function wE(n, t) {
        const e = ("" + n).match(ME);
        if (!e || e[1] === "normal") return t * 1.2;
        switch (n = +e[2], e[3]) {
          case "px":
            return n;
          case "%":
            n /= 100;
            break;
        }
        return t * n;
      }
      const EE = (n) => +n || 0;
      function ou(n, t) {
        const e = {}, i = Wt(t), s = i ? Object.keys(t) : t, r = Wt(n) ? i ? (o) => Ut(n[o], n[t[o]]) : (o) => n[o] : () => n;
        for (const o of s) e[o] = EE(r(o));
        return e;
      }
      function cg(n) {
        return ou(n, {
          top: "y",
          right: "x",
          bottom: "y",
          left: "x"
        });
      }
      function Ci(n) {
        return ou(n, [
          "topLeft",
          "topRight",
          "bottomLeft",
          "bottomRight"
        ]);
      }
      function Fe(n) {
        const t = cg(n);
        return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
      }
      function Te(n, t) {
        n = n || {}, t = t || be.font;
        let e = Ut(n.size, t.size);
        typeof e == "string" && (e = parseInt(e, 10));
        let i = Ut(n.style, t.style);
        i && !("" + i).match(SE) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0);
        const s = {
          family: Ut(n.family, t.family),
          lineHeight: wE(Ut(n.lineHeight, t.lineHeight), e),
          size: e,
          style: i,
          weight: Ut(n.weight, t.weight),
          string: ""
        };
        return s.string = mE(s), s;
      }
      function Nr(n, t, e, i) {
        let s, r, o;
        for (s = 0, r = n.length; s < r; ++s) if (o = n[s], o !== void 0 && o !== void 0) return o;
      }
      function TE(n, t, e) {
        const { min: i, max: s } = n, r = Qm(t, (s - i) / 2), o = (a, l) => e && a === 0 ? 0 : a + l;
        return {
          min: o(i, -Math.abs(r)),
          max: o(s, r)
        };
      }
      function Fi(n, t) {
        return Object.assign(Object.create(n), t);
      }
      function au(n, t = [
        ""
      ], e, i, s = () => n[0]) {
        const r = e || n;
        typeof i > "u" && (i = fg("_fallback", n));
        const o = {
          [Symbol.toStringTag]: "Object",
          _cacheable: true,
          _scopes: n,
          _rootScopes: r,
          _fallback: i,
          _getTarget: s,
          override: (a) => au([
            a,
            ...n
          ], t, r, i)
        };
        return new Proxy(o, {
          deleteProperty(a, l) {
            return delete a[l], delete a._keys, delete n[0][l], true;
          },
          get(a, l) {
            return ug(a, l, () => OE(l, t, n, a));
          },
          getOwnPropertyDescriptor(a, l) {
            return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
          },
          getPrototypeOf() {
            return Reflect.getPrototypeOf(n[0]);
          },
          has(a, l) {
            return yf(a).includes(l);
          },
          ownKeys(a) {
            return yf(a);
          },
          set(a, l, c) {
            const h = a._storage || (a._storage = s());
            return a[l] = h[l] = c, delete a._keys, true;
          }
        });
      }
      function rr(n, t, e, i) {
        const s = {
          _cacheable: false,
          _proxy: n,
          _context: t,
          _subProxy: e,
          _stack: /* @__PURE__ */ new Set(),
          _descriptors: hg(n, i),
          setContext: (r) => rr(n, r, e, i),
          override: (r) => rr(n.override(r), t, e, i)
        };
        return new Proxy(s, {
          deleteProperty(r, o) {
            return delete r[o], delete n[o], true;
          },
          get(r, o, a) {
            return ug(r, o, () => CE(r, o, a));
          },
          getOwnPropertyDescriptor(r, o) {
            return r._descriptors.allKeys ? Reflect.has(n, o) ? {
              enumerable: true,
              configurable: true
            } : void 0 : Reflect.getOwnPropertyDescriptor(n, o);
          },
          getPrototypeOf() {
            return Reflect.getPrototypeOf(n);
          },
          has(r, o) {
            return Reflect.has(n, o);
          },
          ownKeys() {
            return Reflect.ownKeys(n);
          },
          set(r, o, a) {
            return n[o] = a, delete r[o], true;
          }
        });
      }
      function hg(n, t = {
        scriptable: true,
        indexable: true
      }) {
        const { _scriptable: e = t.scriptable, _indexable: i = t.indexable, _allKeys: s = t.allKeys } = n;
        return {
          allKeys: s,
          scriptable: e,
          indexable: i,
          isScriptable: ln(e) ? e : () => e,
          isIndexable: ln(i) ? i : () => i
        };
      }
      const AE = (n, t) => n ? n + eu(t) : t, lu = (n, t) => Wt(t) && n !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
      function ug(n, t, e) {
        if (Object.prototype.hasOwnProperty.call(n, t) || t === "constructor") return n[t];
        const i = e();
        return n[t] = i, i;
      }
      function CE(n, t, e) {
        const { _proxy: i, _context: s, _subProxy: r, _descriptors: o } = n;
        let a = i[t];
        return ln(a) && o.isScriptable(t) && (a = RE(t, a, n, e)), oe(a) && a.length && (a = PE(t, a, n, o.isIndexable)), lu(t, a) && (a = rr(a, s, r && r[t], o)), a;
      }
      function RE(n, t, e, i) {
        const { _proxy: s, _context: r, _subProxy: o, _stack: a } = e;
        if (a.has(n)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + n);
        a.add(n);
        let l = t(r, o || i);
        return a.delete(n), lu(n, l) && (l = cu(s._scopes, s, n, l)), l;
      }
      function PE(n, t, e, i) {
        const { _proxy: s, _context: r, _subProxy: o, _descriptors: a } = e;
        if (typeof r.index < "u" && i(n)) return t[r.index % t.length];
        if (Wt(t[0])) {
          const l = t, c = s._scopes.filter((h) => h !== l);
          t = [];
          for (const h of l) {
            const u = cu(c, s, n, h);
            t.push(rr(u, r, o && o[n], a));
          }
        }
        return t;
      }
      function dg(n, t, e) {
        return ln(n) ? n(t, e) : n;
      }
      const DE = (n, t) => n === true ? t : typeof n == "string" ? Ii(t, n) : void 0;
      function LE(n, t, e, i, s) {
        for (const r of t) {
          const o = DE(e, r);
          if (o) {
            n.add(o);
            const a = dg(o._fallback, e, s);
            if (typeof a < "u" && a !== e && a !== i) return a;
          } else if (o === false && typeof i < "u" && e !== i) return null;
        }
        return false;
      }
      function cu(n, t, e, i) {
        const s = t._rootScopes, r = dg(t._fallback, e, i), o = [
          ...n,
          ...s
        ], a = /* @__PURE__ */ new Set();
        a.add(i);
        let l = bf(a, o, e, r || e, i);
        return l === null || typeof r < "u" && r !== e && (l = bf(a, o, r, l, i), l === null) ? false : au(Array.from(a), [
          ""
        ], s, r, () => IE(t, e, i));
      }
      function bf(n, t, e, i, s) {
        for (; e; ) e = LE(n, t, e, i, s);
        return e;
      }
      function IE(n, t, e) {
        const i = n._getTarget();
        t in i || (i[t] = {});
        const s = i[t];
        return oe(s) && Wt(e) ? e : s || {};
      }
      function OE(n, t, e, i) {
        let s;
        for (const r of t) if (s = fg(AE(r, n), e), typeof s < "u") return lu(n, s) ? cu(e, i, n, s) : s;
      }
      function fg(n, t) {
        for (const e of t) {
          if (!e) continue;
          const i = e[n];
          if (typeof i < "u") return i;
        }
      }
      function yf(n) {
        let t = n._keys;
        return t || (t = n._keys = kE(n._scopes)), t;
      }
      function kE(n) {
        const t = /* @__PURE__ */ new Set();
        for (const e of n) for (const i of Object.keys(e).filter((s) => !s.startsWith("_"))) t.add(i);
        return Array.from(t);
      }
      function pg(n, t, e, i) {
        const { iScale: s } = n, { key: r = "r" } = this._parsing, o = new Array(i);
        let a, l, c, h;
        for (a = 0, l = i; a < l; ++a) c = a + e, h = t[c], o[a] = {
          r: s.parse(Ii(h, r), c)
        };
        return o;
      }
      const FE = Number.EPSILON || 1e-14, or = (n, t) => t < n.length && !n[t].skip && n[t], mg = (n) => n === "x" ? "y" : "x";
      function NE(n, t, e, i) {
        const s = n.skip ? t : n, r = t, o = e.skip ? t : e, a = ir(r, s), l = ir(o, r);
        let c = a / (a + l), h = l / (a + l);
        c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;
        const u = i * c, d = i * h;
        return {
          previous: {
            x: r.x - u * (o.x - s.x),
            y: r.y - u * (o.y - s.y)
          },
          next: {
            x: r.x + d * (o.x - s.x),
            y: r.y + d * (o.y - s.y)
          }
        };
      }
      function UE(n, t, e) {
        const i = n.length;
        let s, r, o, a, l, c = or(n, 0);
        for (let h = 0; h < i - 1; ++h) if (l = c, c = or(n, h + 1), !(!l || !c)) {
          if (Wr(t[h], 0, FE)) {
            e[h] = e[h + 1] = 0;
            continue;
          }
          s = e[h] / t[h], r = e[h + 1] / t[h], a = Math.pow(s, 2) + Math.pow(r, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), e[h] = s * o * t[h], e[h + 1] = r * o * t[h]);
        }
      }
      function BE(n, t, e = "x") {
        const i = mg(e), s = n.length;
        let r, o, a, l = or(n, 0);
        for (let c = 0; c < s; ++c) {
          if (o = a, a = l, l = or(n, c + 1), !a) continue;
          const h = a[e], u = a[i];
          o && (r = (h - o[e]) / 3, a[`cp1${e}`] = h - r, a[`cp1${i}`] = u - r * t[c]), l && (r = (l[e] - h) / 3, a[`cp2${e}`] = h + r, a[`cp2${i}`] = u + r * t[c]);
        }
      }
      function zE(n, t = "x") {
        const e = mg(t), i = n.length, s = Array(i).fill(0), r = Array(i);
        let o, a, l, c = or(n, 0);
        for (o = 0; o < i; ++o) if (a = l, l = c, c = or(n, o + 1), !!l) {
          if (c) {
            const h = c[t] - l[t];
            s[o] = h !== 0 ? (c[e] - l[e]) / h : 0;
          }
          r[o] = a ? c ? Hn(s[o - 1]) !== Hn(s[o]) ? 0 : (s[o - 1] + s[o]) / 2 : s[o - 1] : s[o];
        }
        UE(n, s, r), BE(n, r, t);
      }
      function sa(n, t, e) {
        return Math.max(Math.min(n, e), t);
      }
      function HE(n, t) {
        let e, i, s, r, o, a = li(n[0], t);
        for (e = 0, i = n.length; e < i; ++e) o = r, r = a, a = e < i - 1 && li(n[e + 1], t), r && (s = n[e], o && (s.cp1x = sa(s.cp1x, t.left, t.right), s.cp1y = sa(s.cp1y, t.top, t.bottom)), a && (s.cp2x = sa(s.cp2x, t.left, t.right), s.cp2y = sa(s.cp2y, t.top, t.bottom)));
      }
      function VE(n, t, e, i, s) {
        let r, o, a, l;
        if (t.spanGaps && (n = n.filter((c) => !c.skip)), t.cubicInterpolationMode === "monotone") zE(n, s);
        else {
          let c = i ? n[n.length - 1] : n[0];
          for (r = 0, o = n.length; r < o; ++r) a = n[r], l = NE(c, a, n[Math.min(r + 1, o - (i ? 0 : 1)) % o], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
        }
        t.capBezierPoints && HE(n, e);
      }
      function hu() {
        return typeof window < "u" && typeof document < "u";
      }
      function uu(n) {
        let t = n.parentNode;
        return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
      }
      function Xa(n, t, e) {
        let i;
        return typeof n == "string" ? (i = parseInt(n, 10), n.indexOf("%") !== -1 && (i = i / 100 * t.parentNode[e])) : i = n, i;
      }
      const rl = (n) => n.ownerDocument.defaultView.getComputedStyle(n, null);
      function WE(n, t) {
        return rl(n).getPropertyValue(t);
      }
      const GE = [
        "top",
        "right",
        "bottom",
        "left"
      ];
      function rs(n, t, e) {
        const i = {};
        e = e ? "-" + e : "";
        for (let s = 0; s < 4; s++) {
          const r = GE[s];
          i[r] = parseFloat(n[t + "-" + r + e]) || 0;
        }
        return i.width = i.left + i.right, i.height = i.top + i.bottom, i;
      }
      const XE = (n, t, e) => (n > 0 || t > 0) && (!e || !e.shadowRoot);
      function YE(n, t) {
        const e = n.touches, i = e && e.length ? e[0] : n, { offsetX: s, offsetY: r } = i;
        let o = false, a, l;
        if (XE(s, r, n.target)) a = s, l = r;
        else {
          const c = t.getBoundingClientRect();
          a = i.clientX - c.left, l = i.clientY - c.top, o = true;
        }
        return {
          x: a,
          y: l,
          box: o
        };
      }
      function Ki(n, t) {
        if ("native" in n) return n;
        const { canvas: e, currentDevicePixelRatio: i } = t, s = rl(e), r = s.boxSizing === "border-box", o = rs(s, "padding"), a = rs(s, "border", "width"), { x: l, y: c, box: h } = YE(n, e), u = o.left + (h && a.left), d = o.top + (h && a.top);
        let { width: f, height: g } = t;
        return r && (f -= o.width + a.width, g -= o.height + a.height), {
          x: Math.round((l - u) / f * e.width / i),
          y: Math.round((c - d) / g * e.height / i)
        };
      }
      function jE(n, t, e) {
        let i, s;
        if (t === void 0 || e === void 0) {
          const r = n && uu(n);
          if (!r) t = n.clientWidth, e = n.clientHeight;
          else {
            const o = r.getBoundingClientRect(), a = rl(r), l = rs(a, "border", "width"), c = rs(a, "padding");
            t = o.width - c.width - l.width, e = o.height - c.height - l.height, i = Xa(a.maxWidth, r, "clientWidth"), s = Xa(a.maxHeight, r, "clientHeight");
          }
        }
        return {
          width: t,
          height: e,
          maxWidth: i || Ha,
          maxHeight: s || Ha
        };
      }
      const ra = (n) => Math.round(n * 10) / 10;
      function qE(n, t, e, i) {
        const s = rl(n), r = rs(s, "margin"), o = Xa(s.maxWidth, n, "clientWidth") || Ha, a = Xa(s.maxHeight, n, "clientHeight") || Ha, l = jE(n, t, e);
        let { width: c, height: h } = l;
        if (s.boxSizing === "content-box") {
          const d = rs(s, "border", "width"), f = rs(s, "padding");
          c -= f.width + d.width, h -= f.height + d.height;
        }
        return c = Math.max(0, c - r.width), h = Math.max(0, i ? c / i : h - r.height), c = ra(Math.min(c, o, l.maxWidth)), h = ra(Math.min(h, a, l.maxHeight)), c && !h && (h = ra(c / 2)), (t !== void 0 || e !== void 0) && i && l.height && h > l.height && (h = l.height, c = ra(Math.floor(h * i))), {
          width: c,
          height: h
        };
      }
      function vf(n, t, e) {
        const i = t || 1, s = Math.floor(n.height * i), r = Math.floor(n.width * i);
        n.height = Math.floor(n.height), n.width = Math.floor(n.width);
        const o = n.canvas;
        return o.style && (e || !o.style.height && !o.style.width) && (o.style.height = `${n.height}px`, o.style.width = `${n.width}px`), n.currentDevicePixelRatio !== i || o.height !== s || o.width !== r ? (n.currentDevicePixelRatio = i, o.height = s, o.width = r, n.ctx.setTransform(i, 0, 0, i, 0, 0), true) : false;
      }
      const $E = function() {
        let n = false;
        try {
          const t = {
            get passive() {
              return n = true, false;
            }
          };
          hu() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
        } catch {
        }
        return n;
      }();
      function Mf(n, t) {
        const e = WE(n, t), i = e && e.match(/^(\d+)(\.\d+)?px$/);
        return i ? +i[1] : void 0;
      }
      function Zi(n, t, e, i) {
        return {
          x: n.x + e * (t.x - n.x),
          y: n.y + e * (t.y - n.y)
        };
      }
      function KE(n, t, e, i) {
        return {
          x: n.x + e * (t.x - n.x),
          y: i === "middle" ? e < 0.5 ? n.y : t.y : i === "after" ? e < 1 ? n.y : t.y : e > 0 ? t.y : n.y
        };
      }
      function ZE(n, t, e, i) {
        const s = {
          x: n.cp2x,
          y: n.cp2y
        }, r = {
          x: t.cp1x,
          y: t.cp1y
        }, o = Zi(n, s, e), a = Zi(s, r, e), l = Zi(r, t, e), c = Zi(o, a, e), h = Zi(a, l, e);
        return Zi(c, h, e);
      }
      const QE = function(n, t) {
        return {
          x(e) {
            return n + n + t - e;
          },
          setWidth(e) {
            t = e;
          },
          textAlign(e) {
            return e === "center" ? e : e === "right" ? "left" : "right";
          },
          xPlus(e, i) {
            return e - i;
          },
          leftForLtr(e, i) {
            return e - i;
          }
        };
      }, JE = function() {
        return {
          x(n) {
            return n;
          },
          setWidth(n) {
          },
          textAlign(n) {
            return n;
          },
          xPlus(n, t) {
            return n + t;
          },
          leftForLtr(n, t) {
            return n;
          }
        };
      };
      function $s(n, t, e) {
        return n ? QE(t, e) : JE();
      }
      function gg(n, t) {
        let e, i;
        (t === "ltr" || t === "rtl") && (e = n.canvas.style, i = [
          e.getPropertyValue("direction"),
          e.getPropertyPriority("direction")
        ], e.setProperty("direction", t, "important"), n.prevTextDirection = i);
      }
      function _g(n, t) {
        t !== void 0 && (delete n.prevTextDirection, n.canvas.style.setProperty("direction", t[0], t[1]));
      }
      function xg(n) {
        return n === "angle" ? {
          between: no,
          compare: tE,
          normalize: pn
        } : {
          between: oi,
          compare: (t, e) => t - e,
          normalize: (t) => t
        };
      }
      function Sf({ start: n, end: t, count: e, loop: i, style: s }) {
        return {
          start: n % e,
          end: t % e,
          loop: i && (t - n + 1) % e === 0,
          style: s
        };
      }
      function tT(n, t, e) {
        const { property: i, start: s, end: r } = e, { between: o, normalize: a } = xg(i), l = t.length;
        let { start: c, end: h, loop: u } = n, d, f;
        if (u) {
          for (c += l, h += l, d = 0, f = l; d < f && o(a(t[c % l][i]), s, r); ++d) c--, h--;
          c %= l, h %= l;
        }
        return h < c && (h += l), {
          start: c,
          end: h,
          loop: u,
          style: n.style
        };
      }
      function bg(n, t, e) {
        if (!e) return [
          n
        ];
        const { property: i, start: s, end: r } = e, o = t.length, { compare: a, between: l, normalize: c } = xg(i), { start: h, end: u, loop: d, style: f } = tT(n, t, e), g = [];
        let _ = false, m = null, p, y, w;
        const M = () => l(s, w, p) && a(s, w) !== 0, C = () => a(r, p) === 0 || l(r, w, p), R = () => _ || M(), T = () => !_ || C();
        for (let v = h, x = h; v <= u; ++v) y = t[v % o], !y.skip && (p = c(y[i]), p !== w && (_ = l(p, s, r), m === null && R() && (m = a(p, s) === 0 ? v : x), m !== null && T() && (g.push(Sf({
          start: m,
          end: v,
          loop: d,
          count: o,
          style: f
        })), m = null), x = v, w = p));
        return m !== null && g.push(Sf({
          start: m,
          end: u,
          loop: d,
          count: o,
          style: f
        })), g;
      }
      function yg(n, t) {
        const e = [], i = n.segments;
        for (let s = 0; s < i.length; s++) {
          const r = bg(i[s], n.points, t);
          r.length && e.push(...r);
        }
        return e;
      }
      function eT(n, t, e, i) {
        let s = 0, r = t - 1;
        if (e && !i) for (; s < t && !n[s].skip; ) s++;
        for (; s < t && n[s].skip; ) s++;
        for (s %= t, e && (r += s); r > s && n[r % t].skip; ) r--;
        return r %= t, {
          start: s,
          end: r
        };
      }
      function nT(n, t, e, i) {
        const s = n.length, r = [];
        let o = t, a = n[t], l;
        for (l = t + 1; l <= e; ++l) {
          const c = n[l % s];
          c.skip || c.stop ? a.skip || (i = false, r.push({
            start: t % s,
            end: (l - 1) % s,
            loop: i
          }), t = o = c.stop ? l : null) : (o = l, a.skip && (t = l)), a = c;
        }
        return o !== null && r.push({
          start: t % s,
          end: o % s,
          loop: i
        }), r;
      }
      function iT(n, t) {
        const e = n.points, i = n.options.spanGaps, s = e.length;
        if (!s) return [];
        const r = !!n._loop, { start: o, end: a } = eT(e, s, r, i);
        if (i === true) return wf(n, [
          {
            start: o,
            end: a,
            loop: r
          }
        ], e, t);
        const l = a < o ? a + s : a, c = !!n._fullLoop && o === 0 && a === s - 1;
        return wf(n, nT(e, o, l, c), e, t);
      }
      function wf(n, t, e, i) {
        return !i || !i.setContext || !e ? t : sT(n, t, e, i);
      }
      function sT(n, t, e, i) {
        const s = n._chart.getContext(), r = Ef(n.options), { _datasetIndex: o, options: { spanGaps: a } } = n, l = e.length, c = [];
        let h = r, u = t[0].start, d = u;
        function f(g, _, m, p) {
          const y = a ? -1 : 1;
          if (g !== _) {
            for (g += l; e[g % l].skip; ) g -= y;
            for (; e[_ % l].skip; ) _ += y;
            g % l !== _ % l && (c.push({
              start: g % l,
              end: _ % l,
              loop: m,
              style: p
            }), h = p, u = _ % l);
          }
        }
        for (const g of t) {
          u = a ? u : g.start;
          let _ = e[u % l], m;
          for (d = u + 1; d <= g.end; d++) {
            const p = e[d % l];
            m = Ef(i.setContext(Fi(s, {
              type: "segment",
              p0: _,
              p1: p,
              p0DataIndex: (d - 1) % l,
              p1DataIndex: d % l,
              datasetIndex: o
            }))), rT(m, h) && f(u, d - 1, g.loop, h), _ = p, h = m;
          }
          u < d - 1 && f(u, d - 1, g.loop, h);
        }
        return c;
      }
      function Ef(n) {
        return {
          backgroundColor: n.backgroundColor,
          borderCapStyle: n.borderCapStyle,
          borderDash: n.borderDash,
          borderDashOffset: n.borderDashOffset,
          borderJoinStyle: n.borderJoinStyle,
          borderWidth: n.borderWidth,
          borderColor: n.borderColor
        };
      }
      function rT(n, t) {
        if (!t) return false;
        const e = [], i = function(s, r) {
          return ru(r) ? (e.includes(r) || e.push(r), e.indexOf(r)) : r;
        };
        return JSON.stringify(n, i) !== JSON.stringify(t, i);
      }
      function oa(n, t, e) {
        return n.options.clip ? n[e] : t[e];
      }
      function oT(n, t) {
        const { xScale: e, yScale: i } = n;
        return e && i ? {
          left: oa(e, t, "left"),
          right: oa(e, t, "right"),
          top: oa(i, t, "top"),
          bottom: oa(i, t, "bottom")
        } : t;
      }
      function vg(n, t) {
        const e = t._clip;
        if (e.disabled) return false;
        const i = oT(t, n.chartArea);
        return {
          left: e.left === false ? 0 : i.left - (e.left === true ? 0 : e.left),
          right: e.right === false ? n.width : i.right + (e.right === true ? 0 : e.right),
          top: e.top === false ? 0 : i.top - (e.top === true ? 0 : e.top),
          bottom: e.bottom === false ? n.height : i.bottom + (e.bottom === true ? 0 : e.bottom)
        };
      }
      class aT {
        constructor() {
          this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
        }
        _notify(t, e, i, s) {
          const r = e.listeners[s], o = e.duration;
          r.forEach((a) => a({
            chart: t,
            initial: e.initial,
            numSteps: o,
            currentStep: Math.min(i - e.start, o)
          }));
        }
        _refresh() {
          this._request || (this._running = true, this._request = ig.call(window, () => {
            this._update(), this._request = null, this._running && this._refresh();
          }));
        }
        _update(t = Date.now()) {
          let e = 0;
          this._charts.forEach((i, s) => {
            if (!i.running || !i.items.length) return;
            const r = i.items;
            let o = r.length - 1, a = false, l;
            for (; o >= 0; --o) l = r[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(t), a = true) : (r[o] = r[r.length - 1], r.pop());
            a && (s.draw(), this._notify(s, i, t, "progress")), r.length || (i.running = false, this._notify(s, i, t, "complete"), i.initial = false), e += r.length;
          }), this._lastDate = t, e === 0 && (this._running = false);
        }
        _getAnims(t) {
          const e = this._charts;
          let i = e.get(t);
          return i || (i = {
            running: false,
            initial: true,
            items: [],
            listeners: {
              complete: [],
              progress: []
            }
          }, e.set(t, i)), i;
        }
        listen(t, e, i) {
          this._getAnims(t).listeners[e].push(i);
        }
        add(t, e) {
          !e || !e.length || this._getAnims(t).items.push(...e);
        }
        has(t) {
          return this._getAnims(t).items.length > 0;
        }
        start(t) {
          const e = this._charts.get(t);
          e && (e.running = true, e.start = Date.now(), e.duration = e.items.reduce((i, s) => Math.max(i, s._duration), 0), this._refresh());
        }
        running(t) {
          if (!this._running) return false;
          const e = this._charts.get(t);
          return !(!e || !e.running || !e.items.length);
        }
        stop(t) {
          const e = this._charts.get(t);
          if (!e || !e.items.length) return;
          const i = e.items;
          let s = i.length - 1;
          for (; s >= 0; --s) i[s].cancel();
          e.items = [], this._notify(t, e, Date.now(), "complete");
        }
        remove(t) {
          return this._charts.delete(t);
        }
      }
      var ti = new aT();
      const Tf = "transparent", lT = {
        boolean(n, t, e) {
          return e > 0.5 ? t : n;
        },
        color(n, t, e) {
          const i = gf(n || Tf), s = i.valid && gf(t || Tf);
          return s && s.valid ? s.mix(i, e).hexString() : t;
        },
        number(n, t, e) {
          return n + (t - n) * e;
        }
      };
      class cT {
        constructor(t, e, i, s) {
          const r = e[i];
          s = Nr([
            t.to,
            s,
            r,
            t.from
          ]);
          const o = Nr([
            t.from,
            r,
            s
          ]);
          this._active = true, this._fn = t.fn || lT[t.type || typeof o], this._easing = Gr[t.easing] || Gr.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0;
        }
        active() {
          return this._active;
        }
        update(t, e, i) {
          if (this._active) {
            this._notify(false);
            const s = this._target[this._prop], r = i - this._start, o = this._duration - r;
            this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += r, this._loop = !!t.loop, this._to = Nr([
              t.to,
              e,
              s,
              t.from
            ]), this._from = Nr([
              t.from,
              s,
              e
            ]);
          }
        }
        cancel() {
          this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
        }
        tick(t) {
          const e = t - this._start, i = this._duration, s = this._prop, r = this._from, o = this._loop, a = this._to;
          let l;
          if (this._active = r !== a && (o || e < i), !this._active) {
            this._target[s] = a, this._notify(true);
            return;
          }
          if (e < 0) {
            this._target[s] = r;
            return;
          }
          l = e / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[s] = this._fn(r, a, l);
        }
        wait() {
          const t = this._promises || (this._promises = []);
          return new Promise((e, i) => {
            t.push({
              res: e,
              rej: i
            });
          });
        }
        _notify(t) {
          const e = t ? "res" : "rej", i = this._promises || [];
          for (let s = 0; s < i.length; s++) i[s][e]();
        }
      }
      class du {
        constructor(t, e) {
          this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(e);
        }
        configure(t) {
          if (!Wt(t)) return;
          const e = Object.keys(be.animation), i = this._properties;
          Object.getOwnPropertyNames(t).forEach((s) => {
            const r = t[s];
            if (!Wt(r)) return;
            const o = {};
            for (const a of e) o[a] = r[a];
            (oe(r.properties) && r.properties || [
              s
            ]).forEach((a) => {
              (a === s || !i.has(a)) && i.set(a, o);
            });
          });
        }
        _animateOptions(t, e) {
          const i = e.options, s = uT(t, i);
          if (!s) return [];
          const r = this._createAnimations(s, i);
          return i.$shared && hT(t.options.$animations, i).then(() => {
            t.options = i;
          }, () => {
          }), r;
        }
        _createAnimations(t, e) {
          const i = this._properties, s = [], r = t.$animations || (t.$animations = {}), o = Object.keys(e), a = Date.now();
          let l;
          for (l = o.length - 1; l >= 0; --l) {
            const c = o[l];
            if (c.charAt(0) === "$") continue;
            if (c === "options") {
              s.push(...this._animateOptions(t, e));
              continue;
            }
            const h = e[c];
            let u = r[c];
            const d = i.get(c);
            if (u) if (d && u.active()) {
              u.update(d, h, a);
              continue;
            } else u.cancel();
            if (!d || !d.duration) {
              t[c] = h;
              continue;
            }
            r[c] = u = new cT(d, t, c, h), s.push(u);
          }
          return s;
        }
        update(t, e) {
          if (this._properties.size === 0) {
            Object.assign(t, e);
            return;
          }
          const i = this._createAnimations(t, e);
          if (i.length) return ti.add(this._chart, i), true;
        }
      }
      function hT(n, t) {
        const e = [], i = Object.keys(t);
        for (let s = 0; s < i.length; s++) {
          const r = n[i[s]];
          r && r.active() && e.push(r.wait());
        }
        return Promise.all(e);
      }
      function uT(n, t) {
        if (!t) return;
        let e = n.options;
        if (!e) {
          n.options = t;
          return;
        }
        return e.$shared && (n.options = e = Object.assign({}, e, {
          $shared: false,
          $animations: {}
        })), e;
      }
      function Af(n, t) {
        const e = n && n.options || {}, i = e.reverse, s = e.min === void 0 ? t : 0, r = e.max === void 0 ? t : 0;
        return {
          start: i ? r : s,
          end: i ? s : r
        };
      }
      function dT(n, t, e) {
        if (e === false) return false;
        const i = Af(n, e), s = Af(t, e);
        return {
          top: s.end,
          right: i.end,
          bottom: s.start,
          left: i.start
        };
      }
      function fT(n) {
        let t, e, i, s;
        return Wt(n) ? (t = n.top, e = n.right, i = n.bottom, s = n.left) : t = e = i = s = n, {
          top: t,
          right: e,
          bottom: i,
          left: s,
          disabled: n === false
        };
      }
      function Mg(n, t) {
        const e = [], i = n._getSortedDatasetMetas(t);
        let s, r;
        for (s = 0, r = i.length; s < r; ++s) e.push(i[s].index);
        return e;
      }
      function Cf(n, t, e, i = {}) {
        const s = n.keys, r = i.mode === "single";
        let o, a, l, c;
        if (t === null) return;
        let h = false;
        for (o = 0, a = s.length; o < a; ++o) {
          if (l = +s[o], l === e) {
            if (h = true, i.all) continue;
            break;
          }
          c = n.values[l], Me(c) && (r || t === 0 || Hn(t) === Hn(c)) && (t += c);
        }
        return !h && !i.all ? 0 : t;
      }
      function pT(n, t) {
        const { iScale: e, vScale: i } = t, s = e.axis === "x" ? "x" : "y", r = i.axis === "x" ? "x" : "y", o = Object.keys(n), a = new Array(o.length);
        let l, c, h;
        for (l = 0, c = o.length; l < c; ++l) h = o[l], a[l] = {
          [s]: h,
          [r]: n[h]
        };
        return a;
      }
      function oc(n, t) {
        const e = n && n.options.stacked;
        return e || e === void 0 && t.stack !== void 0;
      }
      function mT(n, t, e) {
        return `${n.id}.${t.id}.${e.stack || e.type}`;
      }
      function gT(n) {
        const { min: t, max: e, minDefined: i, maxDefined: s } = n.getUserBounds();
        return {
          min: i ? t : Number.NEGATIVE_INFINITY,
          max: s ? e : Number.POSITIVE_INFINITY
        };
      }
      function _T(n, t, e) {
        const i = n[t] || (n[t] = {});
        return i[e] || (i[e] = {});
      }
      function Rf(n, t, e, i) {
        for (const s of t.getMatchingVisibleMetas(i).reverse()) {
          const r = n[s.index];
          if (e && r > 0 || !e && r < 0) return s.index;
        }
        return null;
      }
      function Pf(n, t) {
        const { chart: e, _cachedMeta: i } = n, s = e._stacks || (e._stacks = {}), { iScale: r, vScale: o, index: a } = i, l = r.axis, c = o.axis, h = mT(r, o, i), u = t.length;
        let d;
        for (let f = 0; f < u; ++f) {
          const g = t[f], { [l]: _, [c]: m } = g, p = g._stacks || (g._stacks = {});
          d = p[c] = _T(s, h, _), d[a] = m, d._top = Rf(d, o, true, i.type), d._bottom = Rf(d, o, false, i.type);
          const y = d._visualValues || (d._visualValues = {});
          y[a] = m;
        }
      }
      function ac(n, t) {
        const e = n.scales;
        return Object.keys(e).filter((i) => e[i].axis === t).shift();
      }
      function xT(n, t) {
        return Fi(n, {
          active: false,
          dataset: void 0,
          datasetIndex: t,
          index: t,
          mode: "default",
          type: "dataset"
        });
      }
      function bT(n, t, e) {
        return Fi(n, {
          active: false,
          dataIndex: t,
          parsed: void 0,
          raw: void 0,
          element: e,
          index: t,
          mode: "default",
          type: "data"
        });
      }
      function wr(n, t) {
        const e = n.controller.index, i = n.vScale && n.vScale.axis;
        if (i) {
          t = t || n._parsed;
          for (const s of t) {
            const r = s._stacks;
            if (!r || r[i] === void 0 || r[i][e] === void 0) return;
            delete r[i][e], r[i]._visualValues !== void 0 && r[i]._visualValues[e] !== void 0 && delete r[i]._visualValues[e];
          }
        }
      }
      const lc = (n) => n === "reset" || n === "none", Df = (n, t) => t ? n : Object.assign({}, n), yT = (n, t, e) => n && !t.hidden && t._stacked && {
        keys: Mg(e, true),
        values: null
      };
      class Ni {
        constructor(t, e) {
          this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
        }
        initialize() {
          const t = this._cachedMeta;
          this.configure(), this.linkScales(), t._stacked = oc(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
        }
        updateIndex(t) {
          this.index !== t && wr(this._cachedMeta), this.index = t;
        }
        linkScales() {
          const t = this.chart, e = this._cachedMeta, i = this.getDataset(), s = (u, d, f, g) => u === "x" ? d : u === "r" ? g : f, r = e.xAxisID = Ut(i.xAxisID, ac(t, "x")), o = e.yAxisID = Ut(i.yAxisID, ac(t, "y")), a = e.rAxisID = Ut(i.rAxisID, ac(t, "r")), l = e.indexAxis, c = e.iAxisID = s(l, r, o, a), h = e.vAxisID = s(l, o, r, a);
          e.xScale = this.getScaleForId(r), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(t) {
          return this.chart.scales[t];
        }
        _getOtherScale(t) {
          const e = this._cachedMeta;
          return t === e.iScale ? e.vScale : e.iScale;
        }
        reset() {
          this._update("reset");
        }
        _destroy() {
          const t = this._cachedMeta;
          this._data && ff(this._data, this), t._stacked && wr(t);
        }
        _dataCheck() {
          const t = this.getDataset(), e = t.data || (t.data = []), i = this._data;
          if (Wt(e)) {
            const s = this._cachedMeta;
            this._data = pT(e, s);
          } else if (i !== e) {
            if (i) {
              ff(i, this);
              const s = this._cachedMeta;
              wr(s), s._parsed = [];
            }
            e && Object.isExtensible(e) && sE(e, this), this._syncList = [], this._data = e;
          }
        }
        addElements() {
          const t = this._cachedMeta;
          this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
        }
        buildOrUpdateElements(t) {
          const e = this._cachedMeta, i = this.getDataset();
          let s = false;
          this._dataCheck();
          const r = e._stacked;
          e._stacked = oc(e.vScale, e), e.stack !== i.stack && (s = true, wr(e), e.stack = i.stack), this._resyncElements(t), (s || r !== e._stacked) && (Pf(this, e._parsed), e._stacked = oc(e.vScale, e));
        }
        configure() {
          const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, true);
          this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
        }
        parse(t, e) {
          const { _cachedMeta: i, _data: s } = this, { iScale: r, _stacked: o } = i, a = r.axis;
          let l = t === 0 && e === s.length ? true : i._sorted, c = t > 0 && i._parsed[t - 1], h, u, d;
          if (this._parsing === false) i._parsed = s, i._sorted = true, d = s;
          else {
            oe(s[t]) ? d = this.parseArrayData(i, s, t, e) : Wt(s[t]) ? d = this.parseObjectData(i, s, t, e) : d = this.parsePrimitiveData(i, s, t, e);
            const f = () => u[a] === null || c && u[a] < c[a];
            for (h = 0; h < e; ++h) i._parsed[h + t] = u = d[h], l && (f() && (l = false), c = u);
            i._sorted = l;
          }
          o && Pf(this, d);
        }
        parsePrimitiveData(t, e, i, s) {
          const { iScale: r, vScale: o } = t, a = r.axis, l = o.axis, c = r.getLabels(), h = r === o, u = new Array(s);
          let d, f, g;
          for (d = 0, f = s; d < f; ++d) g = d + i, u[d] = {
            [a]: h || r.parse(c[g], g),
            [l]: o.parse(e[g], g)
          };
          return u;
        }
        parseArrayData(t, e, i, s) {
          const { xScale: r, yScale: o } = t, a = new Array(s);
          let l, c, h, u;
          for (l = 0, c = s; l < c; ++l) h = l + i, u = e[h], a[l] = {
            x: r.parse(u[0], h),
            y: o.parse(u[1], h)
          };
          return a;
        }
        parseObjectData(t, e, i, s) {
          const { xScale: r, yScale: o } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(s);
          let h, u, d, f;
          for (h = 0, u = s; h < u; ++h) d = h + i, f = e[d], c[h] = {
            x: r.parse(Ii(f, a), d),
            y: o.parse(Ii(f, l), d)
          };
          return c;
        }
        getParsed(t) {
          return this._cachedMeta._parsed[t];
        }
        getDataElement(t) {
          return this._cachedMeta.data[t];
        }
        applyStack(t, e, i) {
          const s = this.chart, r = this._cachedMeta, o = e[t.axis], a = {
            keys: Mg(s, true),
            values: e._stacks[t.axis]._visualValues
          };
          return Cf(a, o, r.index, {
            mode: i
          });
        }
        updateRangeFromParsed(t, e, i, s) {
          const r = i[e.axis];
          let o = r === null ? NaN : r;
          const a = s && i._stacks[e.axis];
          s && a && (s.values = a, o = Cf(s, r, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);
        }
        getMinMax(t, e) {
          const i = this._cachedMeta, s = i._parsed, r = i._sorted && t === i.iScale, o = s.length, a = this._getOtherScale(t), l = yT(e, i, this.chart), c = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
          }, { min: h, max: u } = gT(a);
          let d, f;
          function g() {
            f = s[d];
            const _ = f[a.axis];
            return !Me(f[t.axis]) || h > _ || u < _;
          }
          for (d = 0; d < o && !(!g() && (this.updateRangeFromParsed(c, t, f, l), r)); ++d) ;
          if (r) {
            for (d = o - 1; d >= 0; --d) if (!g()) {
              this.updateRangeFromParsed(c, t, f, l);
              break;
            }
          }
          return c;
        }
        getAllParsedValues(t) {
          const e = this._cachedMeta._parsed, i = [];
          let s, r, o;
          for (s = 0, r = e.length; s < r; ++s) o = e[s][t.axis], Me(o) && i.push(o);
          return i;
        }
        getMaxOverflow() {
          return false;
        }
        getLabelAndValue(t) {
          const e = this._cachedMeta, i = e.iScale, s = e.vScale, r = this.getParsed(t);
          return {
            label: i ? "" + i.getLabelForValue(r[i.axis]) : "",
            value: s ? "" + s.getLabelForValue(r[s.axis]) : ""
          };
        }
        _update(t) {
          const e = this._cachedMeta;
          this.update(t || "default"), e._clip = fT(Ut(this.options.clip, dT(e.xScale, e.yScale, this.getMaxOverflow())));
        }
        update(t) {
        }
        draw() {
          const t = this._ctx, e = this.chart, i = this._cachedMeta, s = i.data || [], r = e.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || s.length - a, c = this.options.drawActiveElementsOnTop;
          let h;
          for (i.dataset && i.dataset.draw(t, r, a, l), h = a; h < a + l; ++h) {
            const u = s[h];
            u.hidden || (u.active && c ? o.push(u) : u.draw(t, r));
          }
          for (h = 0; h < o.length; ++h) o[h].draw(t, r);
        }
        getStyle(t, e) {
          const i = e ? "active" : "default";
          return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);
        }
        getContext(t, e, i) {
          const s = this.getDataset();
          let r;
          if (t >= 0 && t < this._cachedMeta.data.length) {
            const o = this._cachedMeta.data[t];
            r = o.$context || (o.$context = bT(this.getContext(), t, o)), r.parsed = this.getParsed(t), r.raw = s.data[t], r.index = r.dataIndex = t;
          } else r = this.$context || (this.$context = xT(this.chart.getContext(), this.index)), r.dataset = s, r.index = r.datasetIndex = this.index;
          return r.active = !!e, r.mode = i, r;
        }
        resolveDatasetElementOptions(t) {
          return this._resolveElementOptions(this.datasetElementType.id, t);
        }
        resolveDataElementOptions(t, e) {
          return this._resolveElementOptions(this.dataElementType.id, e, t);
        }
        _resolveElementOptions(t, e = "default", i) {
          const s = e === "active", r = this._cachedDataOpts, o = t + "-" + e, a = r[o], l = this.enableOptionSharing && cn(i);
          if (a) return Df(a, l);
          const c = this.chart.config, h = c.datasetElementScopeKeys(this._type, t), u = s ? [
            `${t}Hover`,
            "hover",
            t,
            ""
          ] : [
            t,
            ""
          ], d = c.getOptionScopes(this.getDataset(), h), f = Object.keys(be.elements[t]), g = () => this.getContext(i, s, e), _ = c.resolveNamedOptions(d, f, g, u);
          return _.$shared && (_.$shared = l, r[o] = Object.freeze(Df(_, l))), _;
        }
        _resolveAnimations(t, e, i) {
          const s = this.chart, r = this._cachedDataOpts, o = `animation-${e}`, a = r[o];
          if (a) return a;
          let l;
          if (s.options.animation !== false) {
            const h = this.chart.config, u = h.datasetAnimationScopeKeys(this._type, e), d = h.getOptionScopes(this.getDataset(), u);
            l = h.createResolver(d, this.getContext(t, i, e));
          }
          const c = new du(s, l && l.animations);
          return l && l._cacheable && (r[o] = Object.freeze(c)), c;
        }
        getSharedOptions(t) {
          if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
        }
        includeOptions(t, e) {
          return !e || lc(t) || this.chart._animationsDisabled;
        }
        _getSharedOptions(t, e) {
          const i = this.resolveDataElementOptions(t, e), s = this._sharedOptions, r = this.getSharedOptions(i), o = this.includeOptions(e, r) || r !== s;
          return this.updateSharedOptions(r, e, i), {
            sharedOptions: r,
            includeOptions: o
          };
        }
        updateElement(t, e, i, s) {
          lc(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i);
        }
        updateSharedOptions(t, e, i) {
          t && !lc(e) && this._resolveAnimations(void 0, e).update(t, i);
        }
        _setStyle(t, e, i, s) {
          t.active = s;
          const r = this.getStyle(e, s);
          this._resolveAnimations(e, i, s).update(t, {
            options: !s && this.getSharedOptions(r) || r
          });
        }
        removeHoverStyle(t, e, i) {
          this._setStyle(t, i, "active", false);
        }
        setHoverStyle(t, e, i) {
          this._setStyle(t, i, "active", true);
        }
        _removeDatasetHoverStyle() {
          const t = this._cachedMeta.dataset;
          t && this._setStyle(t, void 0, "active", false);
        }
        _setDatasetHoverStyle() {
          const t = this._cachedMeta.dataset;
          t && this._setStyle(t, void 0, "active", true);
        }
        _resyncElements(t) {
          const e = this._data, i = this._cachedMeta.data;
          for (const [a, l, c] of this._syncList) this[a](l, c);
          this._syncList = [];
          const s = i.length, r = e.length, o = Math.min(r, s);
          o && this.parse(0, o), r > s ? this._insertElements(s, r - s, t) : r < s && this._removeElements(r, s - r);
        }
        _insertElements(t, e, i = true) {
          const s = this._cachedMeta, r = s.data, o = t + e;
          let a;
          const l = (c) => {
            for (c.length += e, a = c.length - 1; a >= o; a--) c[a] = c[a - e];
          };
          for (l(r), a = t; a < o; ++a) r[a] = new this.dataElementType();
          this._parsing && l(s._parsed), this.parse(t, e), i && this.updateElements(r, t, e, "reset");
        }
        updateElements(t, e, i, s) {
        }
        _removeElements(t, e) {
          const i = this._cachedMeta;
          if (this._parsing) {
            const s = i._parsed.splice(t, e);
            i._stacked && wr(i, s);
          }
          i.data.splice(t, e);
        }
        _sync(t) {
          if (this._parsing) this._syncList.push(t);
          else {
            const [e, i, s] = t;
            this[e](i, s);
          }
          this.chart._dataChanges.push([
            this.index,
            ...t
          ]);
        }
        _onDataPush() {
          const t = arguments.length;
          this._sync([
            "_insertElements",
            this.getDataset().data.length - t,
            t
          ]);
        }
        _onDataPop() {
          this._sync([
            "_removeElements",
            this._cachedMeta.data.length - 1,
            1
          ]);
        }
        _onDataShift() {
          this._sync([
            "_removeElements",
            0,
            1
          ]);
        }
        _onDataSplice(t, e) {
          e && this._sync([
            "_removeElements",
            t,
            e
          ]);
          const i = arguments.length - 2;
          i && this._sync([
            "_insertElements",
            t,
            i
          ]);
        }
        _onDataUnshift() {
          this._sync([
            "_insertElements",
            0,
            arguments.length
          ]);
        }
      }
      __publicField(Ni, "defaults", {});
      __publicField(Ni, "datasetElementType", null);
      __publicField(Ni, "dataElementType", null);
      function vT(n, t) {
        if (!n._cache.$bar) {
          const e = n.getMatchingVisibleMetas(t);
          let i = [];
          for (let s = 0, r = e.length; s < r; s++) i = i.concat(e[s].controller.getAllParsedValues(n));
          n._cache.$bar = ng(i.sort((s, r) => s - r));
        }
        return n._cache.$bar;
      }
      function MT(n) {
        const t = n.iScale, e = vT(t, n.type);
        let i = t._length, s, r, o, a;
        const l = () => {
          o === 32767 || o === -32768 || (cn(a) && (i = Math.min(i, Math.abs(o - a) || i)), a = o);
        };
        for (s = 0, r = e.length; s < r; ++s) o = t.getPixelForValue(e[s]), l();
        for (a = void 0, s = 0, r = t.ticks.length; s < r; ++s) o = t.getPixelForTick(s), l();
        return i;
      }
      function ST(n, t, e, i) {
        const s = e.barThickness;
        let r, o;
        return Kt(s) ? (r = t.min * e.categoryPercentage, o = e.barPercentage) : (r = s * i, o = 1), {
          chunk: r / i,
          ratio: o,
          start: t.pixels[n] - r / 2
        };
      }
      function wT(n, t, e, i) {
        const s = t.pixels, r = s[n];
        let o = n > 0 ? s[n - 1] : null, a = n < s.length - 1 ? s[n + 1] : null;
        const l = e.categoryPercentage;
        o === null && (o = r - (a === null ? t.end - t.start : a - r)), a === null && (a = r + r - o);
        const c = r - (r - Math.min(o, a)) / 2 * l;
        return {
          chunk: Math.abs(a - o) / 2 * l / i,
          ratio: e.barPercentage,
          start: c
        };
      }
      function ET(n, t, e, i) {
        const s = e.parse(n[0], i), r = e.parse(n[1], i), o = Math.min(s, r), a = Math.max(s, r);
        let l = o, c = a;
        Math.abs(o) > Math.abs(a) && (l = a, c = o), t[e.axis] = c, t._custom = {
          barStart: l,
          barEnd: c,
          start: s,
          end: r,
          min: o,
          max: a
        };
      }
      function Sg(n, t, e, i) {
        return oe(n) ? ET(n, t, e, i) : t[e.axis] = e.parse(n, i), t;
      }
      function Lf(n, t, e, i) {
        const s = n.iScale, r = n.vScale, o = s.getLabels(), a = s === r, l = [];
        let c, h, u, d;
        for (c = e, h = e + i; c < h; ++c) d = t[c], u = {}, u[s.axis] = a || s.parse(o[c], c), l.push(Sg(d, u, r, c));
        return l;
      }
      function cc(n) {
        return n && n.barStart !== void 0 && n.barEnd !== void 0;
      }
      function TT(n, t, e) {
        return n !== 0 ? Hn(n) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);
      }
      function AT(n) {
        let t, e, i, s, r;
        return n.horizontal ? (t = n.base > n.x, e = "left", i = "right") : (t = n.base < n.y, e = "bottom", i = "top"), t ? (s = "end", r = "start") : (s = "start", r = "end"), {
          start: e,
          end: i,
          reverse: t,
          top: s,
          bottom: r
        };
      }
      function CT(n, t, e, i) {
        let s = t.borderSkipped;
        const r = {};
        if (!s) {
          n.borderSkipped = r;
          return;
        }
        if (s === true) {
          n.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
          };
          return;
        }
        const { start: o, end: a, reverse: l, top: c, bottom: h } = AT(n);
        s === "middle" && e && (n.enableBorderRadius = true, (e._top || 0) === i ? s = c : (e._bottom || 0) === i ? s = h : (r[If(h, o, a, l)] = true, s = c)), r[If(s, o, a, l)] = true, n.borderSkipped = r;
      }
      function If(n, t, e, i) {
        return i ? (n = RT(n, t, e), n = Of(n, e, t)) : n = Of(n, t, e), n;
      }
      function RT(n, t, e) {
        return n === t ? e : n === e ? t : n;
      }
      function Of(n, t, e) {
        return n === "start" ? t : n === "end" ? e : n;
      }
      function PT(n, { inflateAmount: t }, e) {
        n.inflateAmount = t === "auto" ? e === 1 ? 0.33 : 0 : t;
      }
      class DT extends Ni {
        parsePrimitiveData(t, e, i, s) {
          return Lf(t, e, i, s);
        }
        parseArrayData(t, e, i, s) {
          return Lf(t, e, i, s);
        }
        parseObjectData(t, e, i, s) {
          const { iScale: r, vScale: o } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = r.axis === "x" ? a : l, h = o.axis === "x" ? a : l, u = [];
          let d, f, g, _;
          for (d = i, f = i + s; d < f; ++d) _ = e[d], g = {}, g[r.axis] = r.parse(Ii(_, c), d), u.push(Sg(Ii(_, h), g, o, d));
          return u;
        }
        updateRangeFromParsed(t, e, i, s) {
          super.updateRangeFromParsed(t, e, i, s);
          const r = i._custom;
          r && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, r.min), t.max = Math.max(t.max, r.max));
        }
        getMaxOverflow() {
          return 0;
        }
        getLabelAndValue(t) {
          const e = this._cachedMeta, { iScale: i, vScale: s } = e, r = this.getParsed(t), o = r._custom, a = cc(o) ? "[" + o.start + ", " + o.end + "]" : "" + s.getLabelForValue(r[s.axis]);
          return {
            label: "" + i.getLabelForValue(r[i.axis]),
            value: a
          };
        }
        initialize() {
          this.enableOptionSharing = true, super.initialize();
          const t = this._cachedMeta;
          t.stack = this.getDataset().stack;
        }
        update(t) {
          const e = this._cachedMeta;
          this.updateElements(e.data, 0, e.data.length, t);
        }
        updateElements(t, e, i, s) {
          const r = s === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), h = this._getRuler(), { sharedOptions: u, includeOptions: d } = this._getSharedOptions(e, s);
          for (let f = e; f < e + i; f++) {
            const g = this.getParsed(f), _ = r || Kt(g[a.axis]) ? {
              base: l,
              head: l
            } : this._calculateBarValuePixels(f), m = this._calculateBarIndexPixels(f, h), p = (g._stacks || {})[a.axis], y = {
              horizontal: c,
              base: _.base,
              enableBorderRadius: !p || cc(g._custom) || o === p._top || o === p._bottom,
              x: c ? _.head : m.center,
              y: c ? m.center : _.head,
              height: c ? m.size : Math.abs(_.size),
              width: c ? Math.abs(_.size) : m.size
            };
            d && (y.options = u || this.resolveDataElementOptions(f, t[f].active ? "active" : s));
            const w = y.options || t[f].options;
            CT(y, w, p, o), PT(y, w, h.ratio), this.updateElement(t[f], f, y, s);
          }
        }
        _getStacks(t, e) {
          const { iScale: i } = this._cachedMeta, s = i.getMatchingVisibleMetas(this._type).filter((h) => h.controller.options.grouped), r = i.options.stacked, o = [], a = this._cachedMeta.controller.getParsed(e), l = a && a[i.axis], c = (h) => {
            const u = h._parsed.find((f) => f[i.axis] === l), d = u && u[h.vScale.axis];
            if (Kt(d) || isNaN(d)) return true;
          };
          for (const h of s) if (!(e !== void 0 && c(h)) && ((r === false || o.indexOf(h.stack) === -1 || r === void 0 && h.stack === void 0) && o.push(h.stack), h.index === t)) break;
          return o.length || o.push(void 0), o;
        }
        _getStackCount(t) {
          return this._getStacks(void 0, t).length;
        }
        _getStackIndex(t, e, i) {
          const s = this._getStacks(t, i), r = e !== void 0 ? s.indexOf(e) : -1;
          return r === -1 ? s.length - 1 : r;
        }
        _getRuler() {
          const t = this.options, e = this._cachedMeta, i = e.iScale, s = [];
          let r, o;
          for (r = 0, o = e.data.length; r < o; ++r) s.push(i.getPixelForValue(this.getParsed(r)[i.axis], r));
          const a = t.barThickness;
          return {
            min: a || MT(e),
            pixels: s,
            start: i._startPixel,
            end: i._endPixel,
            stackCount: this._getStackCount(),
            scale: i,
            grouped: t.grouped,
            ratio: a ? 1 : t.categoryPercentage * t.barPercentage
          };
        }
        _calculateBarValuePixels(t) {
          const { _cachedMeta: { vScale: e, _stacked: i, index: s }, options: { base: r, minBarLength: o } } = this, a = r || 0, l = this.getParsed(t), c = l._custom, h = cc(c);
          let u = l[e.axis], d = 0, f = i ? this.applyStack(e, l, i) : u, g, _;
          f !== u && (d = f - u, f = u), h && (u = c.barStart, f = c.barEnd - c.barStart, u !== 0 && Hn(u) !== Hn(c.barEnd) && (d = 0), d += u);
          const m = !Kt(r) && !h ? r : d;
          let p = e.getPixelForValue(m);
          if (this.chart.getDataVisibility(t) ? g = e.getPixelForValue(d + f) : g = p, _ = g - p, Math.abs(_) < o) {
            _ = TT(_, e, a) * o, u === a && (p -= _ / 2);
            const y = e.getPixelForDecimal(0), w = e.getPixelForDecimal(1), M = Math.min(y, w), C = Math.max(y, w);
            p = Math.max(Math.min(p, C), M), g = p + _, i && !h && (l._stacks[e.axis]._visualValues[s] = e.getValueForPixel(g) - e.getValueForPixel(p));
          }
          if (p === e.getPixelForValue(a)) {
            const y = Hn(_) * e.getLineWidthForValue(a) / 2;
            p += y, _ -= y;
          }
          return {
            size: _,
            base: p,
            head: g,
            center: g + _ / 2
          };
        }
        _calculateBarIndexPixels(t, e) {
          const i = e.scale, s = this.options, r = s.skipNull, o = Ut(s.maxBarThickness, 1 / 0);
          let a, l;
          if (e.grouped) {
            const c = r ? this._getStackCount(t) : e.stackCount, h = s.barThickness === "flex" ? wT(t, e, s, c) : ST(t, e, s, c), u = this._getStackIndex(this.index, this._cachedMeta.stack, r ? t : void 0);
            a = h.start + h.chunk * u + h.chunk / 2, l = Math.min(o, h.chunk * h.ratio);
          } else a = i.getPixelForValue(this.getParsed(t)[i.axis], t), l = Math.min(o, e.min * e.ratio);
          return {
            base: a - l / 2,
            head: a + l / 2,
            center: a,
            size: l
          };
        }
        draw() {
          const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length;
          let r = 0;
          for (; r < s; ++r) this.getParsed(r)[e.axis] !== null && !i[r].hidden && i[r].draw(this._ctx);
        }
      }
      __publicField(DT, "id", "bar");
      __publicField(DT, "defaults", {
        datasetElementType: false,
        dataElementType: "bar",
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "base",
              "width",
              "height"
            ]
          }
        }
      });
      __publicField(DT, "overrides", {
        scales: {
          _index_: {
            type: "category",
            offset: true,
            grid: {
              offset: true
            }
          },
          _value_: {
            type: "linear",
            beginAtZero: true
          }
        }
      });
      class LT extends Ni {
        initialize() {
          this.enableOptionSharing = true, super.initialize();
        }
        parsePrimitiveData(t, e, i, s) {
          const r = super.parsePrimitiveData(t, e, i, s);
          for (let o = 0; o < r.length; o++) r[o]._custom = this.resolveDataElementOptions(o + i).radius;
          return r;
        }
        parseArrayData(t, e, i, s) {
          const r = super.parseArrayData(t, e, i, s);
          for (let o = 0; o < r.length; o++) {
            const a = e[i + o];
            r[o]._custom = Ut(a[2], this.resolveDataElementOptions(o + i).radius);
          }
          return r;
        }
        parseObjectData(t, e, i, s) {
          const r = super.parseObjectData(t, e, i, s);
          for (let o = 0; o < r.length; o++) {
            const a = e[i + o];
            r[o]._custom = Ut(a && a.r && +a.r, this.resolveDataElementOptions(o + i).radius);
          }
          return r;
        }
        getMaxOverflow() {
          const t = this._cachedMeta.data;
          let e = 0;
          for (let i = t.length - 1; i >= 0; --i) e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);
          return e > 0 && e;
        }
        getLabelAndValue(t) {
          const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: r } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), l = r.getLabelForValue(o.y), c = o._custom;
          return {
            label: i[t] || "",
            value: "(" + a + ", " + l + (c ? ", " + c : "") + ")"
          };
        }
        update(t) {
          const e = this._cachedMeta.data;
          this.updateElements(e, 0, e.length, t);
        }
        updateElements(t, e, i, s) {
          const r = s === "reset", { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(e, s), h = o.axis, u = a.axis;
          for (let d = e; d < e + i; d++) {
            const f = t[d], g = !r && this.getParsed(d), _ = {}, m = _[h] = r ? o.getPixelForDecimal(0.5) : o.getPixelForValue(g[h]), p = _[u] = r ? a.getBasePixel() : a.getPixelForValue(g[u]);
            _.skip = isNaN(m) || isNaN(p), c && (_.options = l || this.resolveDataElementOptions(d, f.active ? "active" : s), r && (_.options.radius = 0)), this.updateElement(f, d, _, s);
          }
        }
        resolveDataElementOptions(t, e) {
          const i = this.getParsed(t);
          let s = super.resolveDataElementOptions(t, e);
          s.$shared && (s = Object.assign({}, s, {
            $shared: false
          }));
          const r = s.radius;
          return e !== "active" && (s.radius = 0), s.radius += Ut(i && i._custom, r), s;
        }
      }
      __publicField(LT, "id", "bubble");
      __publicField(LT, "defaults", {
        datasetElementType: false,
        dataElementType: "point",
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "borderWidth",
              "radius"
            ]
          }
        }
      });
      __publicField(LT, "overrides", {
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        }
      });
      function IT(n, t, e) {
        let i = 1, s = 1, r = 0, o = 0;
        if (t < ge) {
          const a = n, l = a + t, c = Math.cos(a), h = Math.sin(a), u = Math.cos(l), d = Math.sin(l), f = (w, M, C) => no(w, a, l, true) ? 1 : Math.max(M, M * e, C, C * e), g = (w, M, C) => no(w, a, l, true) ? -1 : Math.min(M, M * e, C, C * e), _ = f(0, c, u), m = f(xe, h, d), p = g(Zt, c, u), y = g(Zt + xe, h, d);
          i = (_ - p) / 2, s = (m - y) / 2, r = -(_ + p) / 2, o = -(m + y) / 2;
        }
        return {
          ratioX: i,
          ratioY: s,
          offsetX: r,
          offsetY: o
        };
      }
      class ol extends Ni {
        constructor(t, e) {
          super(t, e), this.enableOptionSharing = true, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
        }
        linkScales() {
        }
        parse(t, e) {
          const i = this.getDataset().data, s = this._cachedMeta;
          if (this._parsing === false) s._parsed = i;
          else {
            let r = (l) => +i[l];
            if (Wt(i[t])) {
              const { key: l = "value" } = this._parsing;
              r = (c) => +Ii(i[c], l);
            }
            let o, a;
            for (o = t, a = t + e; o < a; ++o) s._parsed[o] = r(o);
          }
        }
        _getRotation() {
          return ke(this.options.rotation - 90);
        }
        _getCircumference() {
          return ke(this.options.circumference);
        }
        _getRotationExtents() {
          let t = ge, e = -ge;
          for (let i = 0; i < this.chart.data.datasets.length; ++i) if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
            const s = this.chart.getDatasetMeta(i).controller, r = s._getRotation(), o = s._getCircumference();
            t = Math.min(t, r), e = Math.max(e, r + o);
          }
          return {
            rotation: t,
            circumference: e - t
          };
        }
        update(t) {
          const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, r = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(r) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), l = Math.min(Gw(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: h, rotation: u } = this._getRotationExtents(), { ratioX: d, ratioY: f, offsetX: g, offsetY: _ } = IT(u, h, l), m = (i.width - o) / d, p = (i.height - o) / f, y = Math.max(Math.min(m, p) / 2, 0), w = Qm(this.options.radius, y), M = Math.max(w * l, 0), C = (w - M) / this._getVisibleDatasetWeightTotal();
          this.offsetX = g * w, this.offsetY = _ * w, s.total = this.calculateTotal(), this.outerRadius = w - C * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - C * c, 0), this.updateElements(r, 0, r.length, t);
        }
        _circumference(t, e) {
          const i = this.options, s = this._cachedMeta, r = this._getCircumference();
          return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || s._parsed[t] === null || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * r / ge);
        }
        updateElements(t, e, i, s) {
          const r = s === "reset", o = this.chart, a = o.chartArea, c = o.options.animation, h = (a.left + a.right) / 2, u = (a.top + a.bottom) / 2, d = r && c.animateScale, f = d ? 0 : this.innerRadius, g = d ? 0 : this.outerRadius, { sharedOptions: _, includeOptions: m } = this._getSharedOptions(e, s);
          let p = this._getRotation(), y;
          for (y = 0; y < e; ++y) p += this._circumference(y, r);
          for (y = e; y < e + i; ++y) {
            const w = this._circumference(y, r), M = t[y], C = {
              x: h + this.offsetX,
              y: u + this.offsetY,
              startAngle: p,
              endAngle: p + w,
              circumference: w,
              outerRadius: g,
              innerRadius: f
            };
            m && (C.options = _ || this.resolveDataElementOptions(y, M.active ? "active" : s)), p += w, this.updateElement(M, y, C, s);
          }
        }
        calculateTotal() {
          const t = this._cachedMeta, e = t.data;
          let i = 0, s;
          for (s = 0; s < e.length; s++) {
            const r = t._parsed[s];
            r !== null && !isNaN(r) && this.chart.getDataVisibility(s) && !e[s].hidden && (i += Math.abs(r));
          }
          return i;
        }
        calculateCircumference(t) {
          const e = this._cachedMeta.total;
          return e > 0 && !isNaN(t) ? ge * (Math.abs(t) / e) : 0;
        }
        getLabelAndValue(t) {
          const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], r = ho(e._parsed[t], i.options.locale);
          return {
            label: s[t] || "",
            value: r
          };
        }
        getMaxBorderWidth(t) {
          let e = 0;
          const i = this.chart;
          let s, r, o, a, l;
          if (!t) {
            for (s = 0, r = i.data.datasets.length; s < r; ++s) if (i.isDatasetVisible(s)) {
              o = i.getDatasetMeta(s), t = o.data, a = o.controller;
              break;
            }
          }
          if (!t) return 0;
          for (s = 0, r = t.length; s < r; ++s) l = a.resolveDataElementOptions(s), l.borderAlign !== "inner" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));
          return e;
        }
        getMaxOffset(t) {
          let e = 0;
          for (let i = 0, s = t.length; i < s; ++i) {
            const r = this.resolveDataElementOptions(i);
            e = Math.max(e, r.offset || 0, r.hoverOffset || 0);
          }
          return e;
        }
        _getRingWeightOffset(t) {
          let e = 0;
          for (let i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
          return e;
        }
        _getRingWeight(t) {
          return Math.max(Ut(this.chart.data.datasets[t].weight, 1), 0);
        }
        _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
      }
      __publicField(ol, "id", "doughnut");
      __publicField(ol, "defaults", {
        datasetElementType: false,
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: false
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "circumference",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "startAngle",
              "x",
              "y",
              "offset",
              "borderWidth",
              "spacing"
            ]
          }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
      });
      __publicField(ol, "descriptors", {
        _scriptable: (t) => t !== "spacing",
        _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
      });
      __publicField(ol, "overrides", {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(t) {
                const e = t.data;
                if (e.labels.length && e.datasets.length) {
                  const { labels: { pointStyle: i, color: s } } = t.legend.options;
                  return e.labels.map((r, o) => {
                    const l = t.getDatasetMeta(0).controller.getStyle(o);
                    return {
                      text: r,
                      fillStyle: l.backgroundColor,
                      strokeStyle: l.borderColor,
                      fontColor: s,
                      lineWidth: l.borderWidth,
                      pointStyle: i,
                      hidden: !t.getDataVisibility(o),
                      index: o
                    };
                  });
                }
                return [];
              }
            },
            onClick(t, e, i) {
              i.chart.toggleDataVisibility(e.index), i.chart.update();
            }
          }
        }
      });
      class OT extends Ni {
        initialize() {
          this.enableOptionSharing = true, this.supportsDecimation = true, super.initialize();
        }
        update(t) {
          const e = this._cachedMeta, { dataset: i, data: s = [], _dataset: r } = e, o = this.chart._animationsDisabled;
          let { start: a, count: l } = rg(e, s, o);
          this._drawStart = a, this._drawCount = l, og(e) && (a = 0, l = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!r._decimated, i.points = s;
          const c = this.resolveDatasetElementOptions(t);
          this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(i, void 0, {
            animated: !o,
            options: c
          }, t), this.updateElements(s, a, l, t);
        }
        updateElements(t, e, i, s) {
          const r = s === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: h, includeOptions: u } = this._getSharedOptions(e, s), d = o.axis, f = a.axis, { spanGaps: g, segment: _ } = this.options, m = Oi(g) ? g : Number.POSITIVE_INFINITY, p = this.chart._animationsDisabled || r || s === "none", y = e + i, w = t.length;
          let M = e > 0 && this.getParsed(e - 1);
          for (let C = 0; C < w; ++C) {
            const R = t[C], T = p ? R : {};
            if (C < e || C >= y) {
              T.skip = true;
              continue;
            }
            const v = this.getParsed(C), x = Kt(v[f]), b = T[d] = o.getPixelForValue(v[d], C), A = T[f] = r || x ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, v, l) : v[f], C);
            T.skip = isNaN(b) || isNaN(A) || x, T.stop = C > 0 && Math.abs(v[d] - M[d]) > m, _ && (T.parsed = v, T.raw = c.data[C]), u && (T.options = h || this.resolveDataElementOptions(C, R.active ? "active" : s)), p || this.updateElement(R, C, T, s), M = v;
          }
        }
        getMaxOverflow() {
          const t = this._cachedMeta, e = t.dataset, i = e.options && e.options.borderWidth || 0, s = t.data || [];
          if (!s.length) return i;
          const r = s[0].size(this.resolveDataElementOptions(0)), o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
          return Math.max(i, r, o) / 2;
        }
        draw() {
          const t = this._cachedMeta;
          t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
        }
      }
      __publicField(OT, "id", "line");
      __publicField(OT, "defaults", {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: true,
        spanGaps: false
      });
      __publicField(OT, "overrides", {
        scales: {
          _index_: {
            type: "category"
          },
          _value_: {
            type: "linear"
          }
        }
      });
      class wg extends Ni {
        constructor(t, e) {
          super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;
        }
        getLabelAndValue(t) {
          const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], r = ho(e._parsed[t].r, i.options.locale);
          return {
            label: s[t] || "",
            value: r
          };
        }
        parseObjectData(t, e, i, s) {
          return pg.bind(this)(t, e, i, s);
        }
        update(t) {
          const e = this._cachedMeta.data;
          this._updateRadius(), this.updateElements(e, 0, e.length, t);
        }
        getMinMax() {
          const t = this._cachedMeta, e = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
          };
          return t.data.forEach((i, s) => {
            const r = this.getParsed(s).r;
            !isNaN(r) && this.chart.getDataVisibility(s) && (r < e.min && (e.min = r), r > e.max && (e.max = r));
          }), e;
        }
        _updateRadius() {
          const t = this.chart, e = t.chartArea, i = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), r = Math.max(s / 2, 0), o = Math.max(i.cutoutPercentage ? r / 100 * i.cutoutPercentage : 1, 0), a = (r - o) / t.getVisibleDatasetCount();
          this.outerRadius = r - a * this.index, this.innerRadius = this.outerRadius - a;
        }
        updateElements(t, e, i, s) {
          const r = s === "reset", o = this.chart, l = o.options.animation, c = this._cachedMeta.rScale, h = c.xCenter, u = c.yCenter, d = c.getIndexAngle(0) - 0.5 * Zt;
          let f = d, g;
          const _ = 360 / this.countVisibleElements();
          for (g = 0; g < e; ++g) f += this._computeAngle(g, s, _);
          for (g = e; g < e + i; g++) {
            const m = t[g];
            let p = f, y = f + this._computeAngle(g, s, _), w = o.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;
            f = y, r && (l.animateScale && (w = 0), l.animateRotate && (p = y = d));
            const M = {
              x: h,
              y: u,
              innerRadius: 0,
              outerRadius: w,
              startAngle: p,
              endAngle: y,
              options: this.resolveDataElementOptions(g, m.active ? "active" : s)
            };
            this.updateElement(m, g, M, s);
          }
        }
        countVisibleElements() {
          const t = this._cachedMeta;
          let e = 0;
          return t.data.forEach((i, s) => {
            !isNaN(this.getParsed(s).r) && this.chart.getDataVisibility(s) && e++;
          }), e;
        }
        _computeAngle(t, e, i) {
          return this.chart.getDataVisibility(t) ? ke(this.resolveDataElementOptions(t, e).angle || i) : 0;
        }
      }
      __publicField(wg, "id", "polarArea");
      __publicField(wg, "defaults", {
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: true
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius"
            ]
          }
        },
        indexAxis: "r",
        startAngle: 0
      });
      __publicField(wg, "overrides", {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(t) {
                const e = t.data;
                if (e.labels.length && e.datasets.length) {
                  const { labels: { pointStyle: i, color: s } } = t.legend.options;
                  return e.labels.map((r, o) => {
                    const l = t.getDatasetMeta(0).controller.getStyle(o);
                    return {
                      text: r,
                      fillStyle: l.backgroundColor,
                      strokeStyle: l.borderColor,
                      fontColor: s,
                      lineWidth: l.borderWidth,
                      pointStyle: i,
                      hidden: !t.getDataVisibility(o),
                      index: o
                    };
                  });
                }
                return [];
              }
            },
            onClick(t, e, i) {
              i.chart.toggleDataVisibility(e.index), i.chart.update();
            }
          }
        },
        scales: {
          r: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            beginAtZero: true,
            grid: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            startAngle: 0
          }
        }
      });
      class kT extends ol {
      }
      __publicField(kT, "id", "pie");
      __publicField(kT, "defaults", {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
      });
      class FT extends Ni {
        getLabelAndValue(t) {
          const e = this._cachedMeta.vScale, i = this.getParsed(t);
          return {
            label: e.getLabels()[t],
            value: "" + e.getLabelForValue(i[e.axis])
          };
        }
        parseObjectData(t, e, i, s) {
          return pg.bind(this)(t, e, i, s);
        }
        update(t) {
          const e = this._cachedMeta, i = e.dataset, s = e.data || [], r = e.iScale.getLabels();
          if (i.points = s, t !== "resize") {
            const o = this.resolveDatasetElementOptions(t);
            this.options.showLine || (o.borderWidth = 0);
            const a = {
              _loop: true,
              _fullLoop: r.length === s.length,
              options: o
            };
            this.updateElement(i, void 0, a, t);
          }
          this.updateElements(s, 0, s.length, t);
        }
        updateElements(t, e, i, s) {
          const r = this._cachedMeta.rScale, o = s === "reset";
          for (let a = e; a < e + i; a++) {
            const l = t[a], c = this.resolveDataElementOptions(a, l.active ? "active" : s), h = r.getPointPositionForValue(a, this.getParsed(a).r), u = o ? r.xCenter : h.x, d = o ? r.yCenter : h.y, f = {
              x: u,
              y: d,
              angle: h.angle,
              skip: isNaN(u) || isNaN(d),
              options: c
            };
            this.updateElement(l, a, f, s);
          }
        }
      }
      __publicField(FT, "id", "radar");
      __publicField(FT, "defaults", {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: true,
        elements: {
          line: {
            fill: "start"
          }
        }
      });
      __publicField(FT, "overrides", {
        aspectRatio: 1,
        scales: {
          r: {
            type: "radialLinear"
          }
        }
      });
      class NT extends Ni {
        getLabelAndValue(t) {
          const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: r } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), l = r.getLabelForValue(o.y);
          return {
            label: i[t] || "",
            value: "(" + a + ", " + l + ")"
          };
        }
        update(t) {
          const e = this._cachedMeta, { data: i = [] } = e, s = this.chart._animationsDisabled;
          let { start: r, count: o } = rg(e, i, s);
          if (this._drawStart = r, this._drawCount = o, og(e) && (r = 0, o = i.length), this.options.showLine) {
            this.datasetElementType || this.addElements();
            const { dataset: a, _dataset: l } = e;
            a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = i;
            const c = this.resolveDatasetElementOptions(t);
            c.segment = this.options.segment, this.updateElement(a, void 0, {
              animated: !s,
              options: c
            }, t);
          } else this.datasetElementType && (delete e.dataset, this.datasetElementType = false);
          this.updateElements(i, r, o, t);
        }
        addElements() {
          const { showLine: t } = this.options;
          !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
        }
        updateElements(t, e, i, s) {
          const r = s === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, h = this.resolveDataElementOptions(e, s), u = this.getSharedOptions(h), d = this.includeOptions(s, u), f = o.axis, g = a.axis, { spanGaps: _, segment: m } = this.options, p = Oi(_) ? _ : Number.POSITIVE_INFINITY, y = this.chart._animationsDisabled || r || s === "none";
          let w = e > 0 && this.getParsed(e - 1);
          for (let M = e; M < e + i; ++M) {
            const C = t[M], R = this.getParsed(M), T = y ? C : {}, v = Kt(R[g]), x = T[f] = o.getPixelForValue(R[f], M), b = T[g] = r || v ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, R, l) : R[g], M);
            T.skip = isNaN(x) || isNaN(b) || v, T.stop = M > 0 && Math.abs(R[f] - w[f]) > p, m && (T.parsed = R, T.raw = c.data[M]), d && (T.options = u || this.resolveDataElementOptions(M, C.active ? "active" : s)), y || this.updateElement(C, M, T, s), w = R;
          }
          this.updateSharedOptions(u, s, h);
        }
        getMaxOverflow() {
          const t = this._cachedMeta, e = t.data || [];
          if (!this.options.showLine) {
            let a = 0;
            for (let l = e.length - 1; l >= 0; --l) a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);
            return a > 0 && a;
          }
          const i = t.dataset, s = i.options && i.options.borderWidth || 0;
          if (!e.length) return s;
          const r = e[0].size(this.resolveDataElementOptions(0)), o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
          return Math.max(s, r, o) / 2;
        }
      }
      __publicField(NT, "id", "scatter");
      __publicField(NT, "defaults", {
        datasetElementType: false,
        dataElementType: "point",
        showLine: false,
        fill: false
      });
      __publicField(NT, "overrides", {
        interaction: {
          mode: "point"
        },
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        }
      });
      var UT = Object.freeze({
        __proto__: null,
        BarController: DT,
        BubbleController: LT,
        DoughnutController: ol,
        LineController: OT,
        PieController: kT,
        PolarAreaController: wg,
        RadarController: FT,
        ScatterController: NT
      });
      function ji() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
      }
      class fu {
        constructor(t) {
          __publicField(this, "options");
          this.options = t || {};
        }
        static override(t) {
          Object.assign(fu.prototype, t);
        }
        init() {
        }
        formats() {
          return ji();
        }
        parse() {
          return ji();
        }
        format() {
          return ji();
        }
        add() {
          return ji();
        }
        diff() {
          return ji();
        }
        startOf() {
          return ji();
        }
        endOf() {
          return ji();
        }
      }
      var Eg = {
        _date: fu
      };
      function BT(n, t, e, i) {
        const { controller: s, data: r, _sorted: o } = n, a = s._cachedMeta.iScale, l = n.dataset && n.dataset.options ? n.dataset.options.spanGaps : null;
        if (a && t === a.axis && t !== "r" && o && r.length) {
          const c = a._reversePixels ? nE : ai;
          if (i) {
            if (s._sharedOptions) {
              const h = r[0], u = typeof h.getRange == "function" && h.getRange(t);
              if (u) {
                const d = c(r, t, e - u), f = c(r, t, e + u);
                return {
                  lo: d.lo,
                  hi: f.hi
                };
              }
            }
          } else {
            const h = c(r, t, e);
            if (l) {
              const { vScale: u } = s._cachedMeta, { _parsed: d } = n, f = d.slice(0, h.lo + 1).reverse().findIndex((_) => !Kt(_[u.axis]));
              h.lo -= Math.max(0, f);
              const g = d.slice(h.hi).findIndex((_) => !Kt(_[u.axis]));
              h.hi += Math.max(0, g);
            }
            return h;
          }
        }
        return {
          lo: 0,
          hi: r.length - 1
        };
      }
      function al(n, t, e, i, s) {
        const r = n.getSortedVisibleDatasetMetas(), o = e[t];
        for (let a = 0, l = r.length; a < l; ++a) {
          const { index: c, data: h } = r[a], { lo: u, hi: d } = BT(r[a], t, o, s);
          for (let f = u; f <= d; ++f) {
            const g = h[f];
            g.skip || i(g, c, f);
          }
        }
      }
      function zT(n) {
        const t = n.indexOf("x") !== -1, e = n.indexOf("y") !== -1;
        return function(i, s) {
          const r = t ? Math.abs(i.x - s.x) : 0, o = e ? Math.abs(i.y - s.y) : 0;
          return Math.sqrt(Math.pow(r, 2) + Math.pow(o, 2));
        };
      }
      function hc(n, t, e, i, s) {
        const r = [];
        return !s && !n.isPointInArea(t) || al(n, e, t, function(a, l, c) {
          !s && !li(a, n.chartArea, 0) || a.inRange(t.x, t.y, i) && r.push({
            element: a,
            datasetIndex: l,
            index: c
          });
        }, true), r;
      }
      function HT(n, t, e, i) {
        let s = [];
        function r(o, a, l) {
          const { startAngle: c, endAngle: h } = o.getProps([
            "startAngle",
            "endAngle"
          ], i), { angle: u } = Wa(o, {
            x: t.x,
            y: t.y
          });
          no(u, c, h) && s.push({
            element: o,
            datasetIndex: a,
            index: l
          });
        }
        return al(n, e, t, r), s;
      }
      function VT(n, t, e, i, s, r) {
        let o = [];
        const a = zT(e);
        let l = Number.POSITIVE_INFINITY;
        function c(h, u, d) {
          const f = h.inRange(t.x, t.y, s);
          if (i && !f) return;
          const g = h.getCenterPoint(s);
          if (!(!!r || n.isPointInArea(g)) && !f) return;
          const m = a(t, g);
          m < l ? (o = [
            {
              element: h,
              datasetIndex: u,
              index: d
            }
          ], l = m) : m === l && o.push({
            element: h,
            datasetIndex: u,
            index: d
          });
        }
        return al(n, e, t, c), o;
      }
      function uc(n, t, e, i, s, r) {
        return !r && !n.isPointInArea(t) ? [] : e === "r" && !i ? HT(n, t, e, s) : VT(n, t, e, i, s, r);
      }
      function kf(n, t, e, i, s) {
        const r = [], o = e === "x" ? "inXRange" : "inYRange";
        let a = false;
        return al(n, e, t, (l, c, h) => {
          l[o] && l[o](t[e], s) && (r.push({
            element: l,
            datasetIndex: c,
            index: h
          }), a = a || l.inRange(t.x, t.y, s));
        }), i && !a ? [] : r;
      }
      var WT = {
        modes: {
          index(n, t, e, i) {
            const s = Ki(t, n), r = e.axis || "x", o = e.includeInvisible || false, a = e.intersect ? hc(n, s, r, i, o) : uc(n, s, r, false, i, o), l = [];
            return a.length ? (n.getSortedVisibleDatasetMetas().forEach((c) => {
              const h = a[0].index, u = c.data[h];
              u && !u.skip && l.push({
                element: u,
                datasetIndex: c.index,
                index: h
              });
            }), l) : [];
          },
          dataset(n, t, e, i) {
            const s = Ki(t, n), r = e.axis || "xy", o = e.includeInvisible || false;
            let a = e.intersect ? hc(n, s, r, i, o) : uc(n, s, r, false, i, o);
            if (a.length > 0) {
              const l = a[0].datasetIndex, c = n.getDatasetMeta(l).data;
              a = [];
              for (let h = 0; h < c.length; ++h) a.push({
                element: c[h],
                datasetIndex: l,
                index: h
              });
            }
            return a;
          },
          point(n, t, e, i) {
            const s = Ki(t, n), r = e.axis || "xy", o = e.includeInvisible || false;
            return hc(n, s, r, i, o);
          },
          nearest(n, t, e, i) {
            const s = Ki(t, n), r = e.axis || "xy", o = e.includeInvisible || false;
            return uc(n, s, r, e.intersect, i, o);
          },
          x(n, t, e, i) {
            const s = Ki(t, n);
            return kf(n, s, "x", e.intersect, i);
          },
          y(n, t, e, i) {
            const s = Ki(t, n);
            return kf(n, s, "y", e.intersect, i);
          }
        }
      };
      const Tg = [
        "left",
        "top",
        "right",
        "bottom"
      ];
      function Er(n, t) {
        return n.filter((e) => e.pos === t);
      }
      function Ff(n, t) {
        return n.filter((e) => Tg.indexOf(e.pos) === -1 && e.box.axis === t);
      }
      function Tr(n, t) {
        return n.sort((e, i) => {
          const s = t ? i : e, r = t ? e : i;
          return s.weight === r.weight ? s.index - r.index : s.weight - r.weight;
        });
      }
      function GT(n) {
        const t = [];
        let e, i, s, r, o, a;
        for (e = 0, i = (n || []).length; e < i; ++e) s = n[e], { position: r, options: { stack: o, stackWeight: a = 1 } } = s, t.push({
          index: e,
          box: s,
          pos: r,
          horizontal: s.isHorizontal(),
          weight: s.weight,
          stack: o && r + o,
          stackWeight: a
        });
        return t;
      }
      function XT(n) {
        const t = {};
        for (const e of n) {
          const { stack: i, pos: s, stackWeight: r } = e;
          if (!i || !Tg.includes(s)) continue;
          const o = t[i] || (t[i] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
          });
          o.count++, o.weight += r;
        }
        return t;
      }
      function YT(n, t) {
        const e = XT(n), { vBoxMaxWidth: i, hBoxMaxHeight: s } = t;
        let r, o, a;
        for (r = 0, o = n.length; r < o; ++r) {
          a = n[r];
          const { fullSize: l } = a.box, c = e[a.stack], h = c && a.stackWeight / c.weight;
          a.horizontal ? (a.width = h ? h * i : l && t.availableWidth, a.height = s) : (a.width = i, a.height = h ? h * s : l && t.availableHeight);
        }
        return e;
      }
      function jT(n) {
        const t = GT(n), e = Tr(t.filter((c) => c.box.fullSize), true), i = Tr(Er(t, "left"), true), s = Tr(Er(t, "right")), r = Tr(Er(t, "top"), true), o = Tr(Er(t, "bottom")), a = Ff(t, "x"), l = Ff(t, "y");
        return {
          fullSize: e,
          leftAndTop: i.concat(r),
          rightAndBottom: s.concat(l).concat(o).concat(a),
          chartArea: Er(t, "chartArea"),
          vertical: i.concat(s).concat(l),
          horizontal: r.concat(o).concat(a)
        };
      }
      function Nf(n, t, e, i) {
        return Math.max(n[e], t[e]) + Math.max(n[i], t[i]);
      }
      function Ag(n, t) {
        n.top = Math.max(n.top, t.top), n.left = Math.max(n.left, t.left), n.bottom = Math.max(n.bottom, t.bottom), n.right = Math.max(n.right, t.right);
      }
      function qT(n, t, e, i) {
        const { pos: s, box: r } = e, o = n.maxPadding;
        if (!Wt(s)) {
          e.size && (n[s] -= e.size);
          const u = i[e.stack] || {
            size: 0,
            count: 1
          };
          u.size = Math.max(u.size, e.horizontal ? r.height : r.width), e.size = u.size / u.count, n[s] += e.size;
        }
        r.getPadding && Ag(o, r.getPadding());
        const a = Math.max(0, t.outerWidth - Nf(o, n, "left", "right")), l = Math.max(0, t.outerHeight - Nf(o, n, "top", "bottom")), c = a !== n.w, h = l !== n.h;
        return n.w = a, n.h = l, e.horizontal ? {
          same: c,
          other: h
        } : {
          same: h,
          other: c
        };
      }
      function $T(n) {
        const t = n.maxPadding;
        function e(i) {
          const s = Math.max(t[i] - n[i], 0);
          return n[i] += s, s;
        }
        n.y += e("top"), n.x += e("left"), e("right"), e("bottom");
      }
      function KT(n, t) {
        const e = t.maxPadding;
        function i(s) {
          const r = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          };
          return s.forEach((o) => {
            r[o] = Math.max(t[o], e[o]);
          }), r;
        }
        return i(n ? [
          "left",
          "right"
        ] : [
          "top",
          "bottom"
        ]);
      }
      function Ur(n, t, e, i) {
        const s = [];
        let r, o, a, l, c, h;
        for (r = 0, o = n.length, c = 0; r < o; ++r) {
          a = n[r], l = a.box, l.update(a.width || t.w, a.height || t.h, KT(a.horizontal, t));
          const { same: u, other: d } = qT(t, e, a, i);
          c |= u && s.length, h = h || d, l.fullSize || s.push(a);
        }
        return c && Ur(s, t, e, i) || h;
      }
      function aa(n, t, e, i, s) {
        n.top = e, n.left = t, n.right = t + i, n.bottom = e + s, n.width = i, n.height = s;
      }
      function Uf(n, t, e, i) {
        const s = e.padding;
        let { x: r, y: o } = t;
        for (const a of n) {
          const l = a.box, c = i[a.stack] || {
            placed: 0,
            weight: 1
          }, h = a.stackWeight / c.weight || 1;
          if (a.horizontal) {
            const u = t.w * h, d = c.size || l.height;
            cn(c.start) && (o = c.start), l.fullSize ? aa(l, s.left, o, e.outerWidth - s.right - s.left, d) : aa(l, t.left + c.placed, o, u, d), c.start = o, c.placed += u, o = l.bottom;
          } else {
            const u = t.h * h, d = c.size || l.width;
            cn(c.start) && (r = c.start), l.fullSize ? aa(l, r, s.top, d, e.outerHeight - s.bottom - s.top) : aa(l, r, t.top + c.placed, d, u), c.start = r, c.placed += u, r = l.right;
          }
        }
        t.x = r, t.y = o;
      }
      var qe = {
        addBox(n, t) {
          n.boxes || (n.boxes = []), t.fullSize = t.fullSize || false, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
            return [
              {
                z: 0,
                draw(e) {
                  t.draw(e);
                }
              }
            ];
          }, n.boxes.push(t);
        },
        removeBox(n, t) {
          const e = n.boxes ? n.boxes.indexOf(t) : -1;
          e !== -1 && n.boxes.splice(e, 1);
        },
        configure(n, t, e) {
          t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;
        },
        update(n, t, e, i) {
          if (!n) return;
          const s = Fe(n.options.layout.padding), r = Math.max(t - s.width, 0), o = Math.max(e - s.height, 0), a = jT(n.boxes), l = a.vertical, c = a.horizontal;
          he(n.boxes, (_) => {
            typeof _.beforeLayout == "function" && _.beforeLayout();
          });
          const h = l.reduce((_, m) => m.box.options && m.box.options.display === false ? _ : _ + 1, 0) || 1, u = Object.freeze({
            outerWidth: t,
            outerHeight: e,
            padding: s,
            availableWidth: r,
            availableHeight: o,
            vBoxMaxWidth: r / 2 / h,
            hBoxMaxHeight: o / 2
          }), d = Object.assign({}, s);
          Ag(d, Fe(i));
          const f = Object.assign({
            maxPadding: d,
            w: r,
            h: o,
            x: s.left,
            y: s.top
          }, s), g = YT(l.concat(c), u);
          Ur(a.fullSize, f, u, g), Ur(l, f, u, g), Ur(c, f, u, g) && Ur(l, f, u, g), $T(f), Uf(a.leftAndTop, f, u, g), f.x += f.w, f.y += f.h, Uf(a.rightAndBottom, f, u, g), n.chartArea = {
            left: f.left,
            top: f.top,
            right: f.left + f.w,
            bottom: f.top + f.h,
            height: f.h,
            width: f.w
          }, he(a.chartArea, (_) => {
            const m = _.box;
            Object.assign(m, n.chartArea), m.update(f.w, f.h, {
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            });
          });
        }
      };
      class Cg {
        acquireContext(t, e) {
        }
        releaseContext(t) {
          return false;
        }
        addEventListener(t, e, i) {
        }
        removeEventListener(t, e, i) {
        }
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(t, e, i, s) {
          return e = Math.max(0, e || t.width), i = i || t.height, {
            width: e,
            height: Math.max(0, s ? Math.floor(e / s) : i)
          };
        }
        isAttached(t) {
          return true;
        }
        updateConfig(t) {
        }
      }
      class ZT extends Cg {
        acquireContext(t) {
          return t && t.getContext && t.getContext("2d") || null;
        }
        updateConfig(t) {
          t.options.animation = false;
        }
      }
      const Ta = "$chartjs", QT = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
      }, Bf = (n) => n === null || n === "";
      function JT(n, t) {
        const e = n.style, i = n.getAttribute("height"), s = n.getAttribute("width");
        if (n[Ta] = {
          initial: {
            height: i,
            width: s,
            style: {
              display: e.display,
              height: e.height,
              width: e.width
            }
          }
        }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", Bf(s)) {
          const r = Mf(n, "width");
          r !== void 0 && (n.width = r);
        }
        if (Bf(i)) if (n.style.height === "") n.height = n.width / (t || 2);
        else {
          const r = Mf(n, "height");
          r !== void 0 && (n.height = r);
        }
        return n;
      }
      const Rg = $E ? {
        passive: true
      } : false;
      function tA(n, t, e) {
        n && n.addEventListener(t, e, Rg);
      }
      function eA(n, t, e) {
        n && n.canvas && n.canvas.removeEventListener(t, e, Rg);
      }
      function nA(n, t) {
        const e = QT[n.type] || n.type, { x: i, y: s } = Ki(n, t);
        return {
          type: e,
          chart: t,
          native: n,
          x: i !== void 0 ? i : null,
          y: s !== void 0 ? s : null
        };
      }
      function Ya(n, t) {
        for (const e of n) if (e === t || e.contains(t)) return true;
      }
      function iA(n, t, e) {
        const i = n.canvas, s = new MutationObserver((r) => {
          let o = false;
          for (const a of r) o = o || Ya(a.addedNodes, i), o = o && !Ya(a.removedNodes, i);
          o && e();
        });
        return s.observe(document, {
          childList: true,
          subtree: true
        }), s;
      }
      function sA(n, t, e) {
        const i = n.canvas, s = new MutationObserver((r) => {
          let o = false;
          for (const a of r) o = o || Ya(a.removedNodes, i), o = o && !Ya(a.addedNodes, i);
          o && e();
        });
        return s.observe(document, {
          childList: true,
          subtree: true
        }), s;
      }
      const io = /* @__PURE__ */ new Map();
      let zf = 0;
      function Pg() {
        const n = window.devicePixelRatio;
        n !== zf && (zf = n, io.forEach((t, e) => {
          e.currentDevicePixelRatio !== n && t();
        }));
      }
      function rA(n, t) {
        io.size || window.addEventListener("resize", Pg), io.set(n, t);
      }
      function oA(n) {
        io.delete(n), io.size || window.removeEventListener("resize", Pg);
      }
      function aA(n, t, e) {
        const i = n.canvas, s = i && uu(i);
        if (!s) return;
        const r = sg((a, l) => {
          const c = s.clientWidth;
          e(a, l), c < s.clientWidth && e();
        }, window), o = new ResizeObserver((a) => {
          const l = a[0], c = l.contentRect.width, h = l.contentRect.height;
          c === 0 && h === 0 || r(c, h);
        });
        return o.observe(s), rA(n, r), o;
      }
      function dc(n, t, e) {
        e && e.disconnect(), t === "resize" && oA(n);
      }
      function lA(n, t, e) {
        const i = n.canvas, s = sg((r) => {
          n.ctx !== null && e(nA(r, n));
        }, n);
        return tA(i, t, s), s;
      }
      class cA extends Cg {
        acquireContext(t, e) {
          const i = t && t.getContext && t.getContext("2d");
          return i && i.canvas === t ? (JT(t, e), i) : null;
        }
        releaseContext(t) {
          const e = t.canvas;
          if (!e[Ta]) return false;
          const i = e[Ta].initial;
          [
            "height",
            "width"
          ].forEach((r) => {
            const o = i[r];
            Kt(o) ? e.removeAttribute(r) : e.setAttribute(r, o);
          });
          const s = i.style || {};
          return Object.keys(s).forEach((r) => {
            e.style[r] = s[r];
          }), e.width = e.width, delete e[Ta], true;
        }
        addEventListener(t, e, i) {
          this.removeEventListener(t, e);
          const s = t.$proxies || (t.$proxies = {}), o = {
            attach: iA,
            detach: sA,
            resize: aA
          }[e] || lA;
          s[e] = o(t, e, i);
        }
        removeEventListener(t, e) {
          const i = t.$proxies || (t.$proxies = {}), s = i[e];
          if (!s) return;
          ({
            attach: dc,
            detach: dc,
            resize: dc
          }[e] || eA)(t, e, s), i[e] = void 0;
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(t, e, i, s) {
          return qE(t, e, i, s);
        }
        isAttached(t) {
          const e = t && uu(t);
          return !!(e && e.isConnected);
        }
      }
      function hA(n) {
        return !hu() || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas ? ZT : cA;
      }
      class Ke {
        constructor() {
          __publicField(this, "x");
          __publicField(this, "y");
          __publicField(this, "active", false);
          __publicField(this, "options");
          __publicField(this, "$animations");
        }
        tooltipPosition(t) {
          const { x: e, y: i } = this.getProps([
            "x",
            "y"
          ], t);
          return {
            x: e,
            y: i
          };
        }
        hasValue() {
          return Oi(this.x) && Oi(this.y);
        }
        getProps(t, e) {
          const i = this.$animations;
          if (!e || !i) return this;
          const s = {};
          return t.forEach((r) => {
            s[r] = i[r] && i[r].active() ? i[r]._to : this[r];
          }), s;
        }
      }
      __publicField(Ke, "defaults", {});
      __publicField(Ke, "defaultRoutes");
      function uA(n, t) {
        const e = n.options.ticks, i = dA(n), s = Math.min(e.maxTicksLimit || i, i), r = e.major.enabled ? pA(t) : [], o = r.length, a = r[0], l = r[o - 1], c = [];
        if (o > s) return mA(t, c, r, o / s), c;
        const h = fA(r, t, s);
        if (o > 0) {
          let u, d;
          const f = o > 1 ? Math.round((l - a) / (o - 1)) : null;
          for (la(t, c, h, Kt(f) ? 0 : a - f, a), u = 0, d = o - 1; u < d; u++) la(t, c, h, r[u], r[u + 1]);
          return la(t, c, h, l, Kt(f) ? t.length : l + f), c;
        }
        return la(t, c, h), c;
      }
      function dA(n) {
        const t = n.options.offset, e = n._tickSize(), i = n._length / e + (t ? 0 : 1), s = n._maxLength / e;
        return Math.floor(Math.min(i, s));
      }
      function fA(n, t, e) {
        const i = gA(n), s = t.length / e;
        if (!i) return Math.max(s, 1);
        const r = Zw(i);
        for (let o = 0, a = r.length - 1; o < a; o++) {
          const l = r[o];
          if (l > s) return l;
        }
        return Math.max(s, 1);
      }
      function pA(n) {
        const t = [];
        let e, i;
        for (e = 0, i = n.length; e < i; e++) n[e].major && t.push(e);
        return t;
      }
      function mA(n, t, e, i) {
        let s = 0, r = e[0], o;
        for (i = Math.ceil(i), o = 0; o < n.length; o++) o === r && (t.push(n[o]), s++, r = e[s * i]);
      }
      function la(n, t, e, i, s) {
        const r = Ut(i, 0), o = Math.min(Ut(s, n.length), n.length);
        let a = 0, l, c, h;
        for (e = Math.ceil(e), s && (l = s - i, e = l / Math.floor(l / e)), h = r; h < 0; ) a++, h = Math.round(r + a * e);
        for (c = Math.max(r, 0); c < o; c++) c === h && (t.push(n[c]), a++, h = Math.round(r + a * e));
      }
      function gA(n) {
        const t = n.length;
        let e, i;
        if (t < 2) return false;
        for (i = n[0], e = 1; e < t; ++e) if (n[e] - n[e - 1] !== i) return false;
        return i;
      }
      const _A = (n) => n === "left" ? "right" : n === "right" ? "left" : n, Hf = (n, t, e) => t === "top" || t === "left" ? n[t] + e : n[t] - e, Vf = (n, t) => Math.min(t || n, n);
      function Wf(n, t) {
        const e = [], i = n.length / t, s = n.length;
        let r = 0;
        for (; r < s; r += i) e.push(n[Math.floor(r)]);
        return e;
      }
      function xA(n, t, e) {
        const i = n.ticks.length, s = Math.min(t, i - 1), r = n._startPixel, o = n._endPixel, a = 1e-6;
        let l = n.getPixelForTick(s), c;
        if (!(e && (i === 1 ? c = Math.max(l - r, o - l) : t === 0 ? c = (n.getPixelForTick(1) - l) / 2 : c = (l - n.getPixelForTick(s - 1)) / 2, l += s < t ? c : -c, l < r - a || l > o + a))) return l;
      }
      function bA(n, t) {
        he(n, (e) => {
          const i = e.gc, s = i.length / 2;
          let r;
          if (s > t) {
            for (r = 0; r < s; ++r) delete e.data[i[r]];
            i.splice(0, s);
          }
        });
      }
      function Ar(n) {
        return n.drawTicks ? n.tickLength : 0;
      }
      function Gf(n, t) {
        if (!n.display) return 0;
        const e = Te(n.font, t), i = Fe(n.padding);
        return (oe(n.text) ? n.text.length : 1) * e.lineHeight + i.height;
      }
      function yA(n, t) {
        return Fi(n, {
          scale: t,
          type: "scale"
        });
      }
      function vA(n, t, e) {
        return Fi(n, {
          tick: e,
          index: t,
          type: "tick"
        });
      }
      function MA(n, t, e) {
        let i = su(n);
        return (e && t !== "right" || !e && t === "right") && (i = _A(i)), i;
      }
      function SA(n, t, e, i) {
        const { top: s, left: r, bottom: o, right: a, chart: l } = n, { chartArea: c, scales: h } = l;
        let u = 0, d, f, g;
        const _ = o - s, m = a - r;
        if (n.isHorizontal()) {
          if (f = je(i, r, a), Wt(e)) {
            const p = Object.keys(e)[0], y = e[p];
            g = h[p].getPixelForValue(y) + _ - t;
          } else e === "center" ? g = (c.bottom + c.top) / 2 + _ - t : g = Hf(n, e, t);
          d = a - r;
        } else {
          if (Wt(e)) {
            const p = Object.keys(e)[0], y = e[p];
            f = h[p].getPixelForValue(y) - m + t;
          } else e === "center" ? f = (c.left + c.right) / 2 - m + t : f = Hf(n, e, t);
          g = je(i, o, s), u = e === "left" ? -xe : xe;
        }
        return {
          titleX: f,
          titleY: g,
          maxWidth: d,
          rotation: u
        };
      }
      class ms extends Ke {
        constructor(t) {
          super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
        }
        init(t) {
          this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
        }
        parse(t, e) {
          return t;
        }
        getUserBounds() {
          let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this;
          return t = fn(t, Number.POSITIVE_INFINITY), e = fn(e, Number.NEGATIVE_INFINITY), i = fn(i, Number.POSITIVE_INFINITY), s = fn(s, Number.NEGATIVE_INFINITY), {
            min: fn(t, i),
            max: fn(e, s),
            minDefined: Me(t),
            maxDefined: Me(e)
          };
        }
        getMinMax(t) {
          let { min: e, max: i, minDefined: s, maxDefined: r } = this.getUserBounds(), o;
          if (s && r) return {
            min: e,
            max: i
          };
          const a = this.getMatchingVisibleMetas();
          for (let l = 0, c = a.length; l < c; ++l) o = a[l].controller.getMinMax(this, t), s || (e = Math.min(e, o.min)), r || (i = Math.max(i, o.max));
          return e = r && e > i ? i : e, i = s && e > i ? e : i, {
            min: fn(e, fn(i, e)),
            max: fn(i, fn(e, i))
          };
        }
        getPadding() {
          return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
          };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const t = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
        }
        getLabelItems(t = this.chart.chartArea) {
          return this._labelItems || (this._labelItems = this._computeLabelItems(t));
        }
        beforeLayout() {
          this._cache = {}, this._dataLimitsCached = false;
        }
        beforeUpdate() {
          ce(this.options.beforeUpdate, [
            this
          ]);
        }
        update(t, e, i) {
          const { beginAtZero: s, grace: r, ticks: o } = this.options, a = o.sampleSize;
          this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = TE(this, r, s), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
          const l = a < this.ticks.length;
          this._convertTicksToLabels(l ? Wf(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = uA(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
        }
        configure() {
          let t = this.options.reverse, e, i;
          this.isHorizontal() ? (e = this.left, i = this.right) : (e = this.top, i = this.bottom, t = !t), this._startPixel = e, this._endPixel = i, this._reversePixels = t, this._length = i - e, this._alignToPixels = this.options.alignToPixels;
        }
        afterUpdate() {
          ce(this.options.afterUpdate, [
            this
          ]);
        }
        beforeSetDimensions() {
          ce(this.options.beforeSetDimensions, [
            this
          ]);
        }
        setDimensions() {
          this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
        }
        afterSetDimensions() {
          ce(this.options.afterSetDimensions, [
            this
          ]);
        }
        _callHooks(t) {
          this.chart.notifyPlugins(t, this.getContext()), ce(this.options[t], [
            this
          ]);
        }
        beforeDataLimits() {
          this._callHooks("beforeDataLimits");
        }
        determineDataLimits() {
        }
        afterDataLimits() {
          this._callHooks("afterDataLimits");
        }
        beforeBuildTicks() {
          this._callHooks("beforeBuildTicks");
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks("afterBuildTicks");
        }
        beforeTickToLabelConversion() {
          ce(this.options.beforeTickToLabelConversion, [
            this
          ]);
        }
        generateTickLabels(t) {
          const e = this.options.ticks;
          let i, s, r;
          for (i = 0, s = t.length; i < s; i++) r = t[i], r.label = ce(e.callback, [
            r.value,
            i,
            t
          ], this);
        }
        afterTickToLabelConversion() {
          ce(this.options.afterTickToLabelConversion, [
            this
          ]);
        }
        beforeCalculateLabelRotation() {
          ce(this.options.beforeCalculateLabelRotation, [
            this
          ]);
        }
        calculateLabelRotation() {
          const t = this.options, e = t.ticks, i = Vf(this.ticks.length, t.ticks.maxTicksLimit), s = e.minRotation || 0, r = e.maxRotation;
          let o = s, a, l, c;
          if (!this._isVisible() || !e.display || s >= r || i <= 1 || !this.isHorizontal()) {
            this.labelRotation = s;
            return;
          }
          const h = this._getLabelSizes(), u = h.widest.width, d = h.highest.height, f = Ve(this.chart.width - u, 0, this.maxWidth);
          a = t.offset ? this.maxWidth / i : f / (i - 1), u + 6 > a && (a = f / (i - (t.offset ? 0.5 : 1)), l = this.maxHeight - Ar(t.grid) - e.padding - Gf(t.title, this.chart.options.font), c = Math.sqrt(u * u + d * d), o = il(Math.min(Math.asin(Ve((h.highest.height + 6) / a, -1, 1)), Math.asin(Ve(l / c, -1, 1)) - Math.asin(Ve(d / c, -1, 1)))), o = Math.max(s, Math.min(r, o))), this.labelRotation = o;
        }
        afterCalculateLabelRotation() {
          ce(this.options.afterCalculateLabelRotation, [
            this
          ]);
        }
        afterAutoSkip() {
        }
        beforeFit() {
          ce(this.options.beforeFit, [
            this
          ]);
        }
        fit() {
          const t = {
            width: 0,
            height: 0
          }, { chart: e, options: { ticks: i, title: s, grid: r } } = this, o = this._isVisible(), a = this.isHorizontal();
          if (o) {
            const l = Gf(s, e.options.font);
            if (a ? (t.width = this.maxWidth, t.height = Ar(r) + l) : (t.height = this.maxHeight, t.width = Ar(r) + l), i.display && this.ticks.length) {
              const { first: c, last: h, widest: u, highest: d } = this._getLabelSizes(), f = i.padding * 2, g = ke(this.labelRotation), _ = Math.cos(g), m = Math.sin(g);
              if (a) {
                const p = i.mirror ? 0 : m * u.width + _ * d.height;
                t.height = Math.min(this.maxHeight, t.height + p + f);
              } else {
                const p = i.mirror ? 0 : _ * u.width + m * d.height;
                t.width = Math.min(this.maxWidth, t.width + p + f);
              }
              this._calculatePadding(c, h, m, _);
            }
          }
          this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);
        }
        _calculatePadding(t, e, i, s) {
          const { ticks: { align: r, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
          if (this.isHorizontal()) {
            const h = this.getPixelForTick(0) - this.left, u = this.right - this.getPixelForTick(this.ticks.length - 1);
            let d = 0, f = 0;
            l ? c ? (d = s * t.width, f = i * e.height) : (d = i * t.height, f = s * e.width) : r === "start" ? f = e.width : r === "end" ? d = t.width : r !== "inner" && (d = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((d - h + o) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - u + o) * this.width / (this.width - u), 0);
          } else {
            let h = e.height / 2, u = t.height / 2;
            r === "start" ? (h = 0, u = t.height) : r === "end" && (h = e.height, u = 0), this.paddingTop = h + o, this.paddingBottom = u + o;
          }
        }
        _handleMargins() {
          this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
        }
        afterFit() {
          ce(this.options.afterFit, [
            this
          ]);
        }
        isHorizontal() {
          const { axis: t, position: e } = this.options;
          return e === "top" || e === "bottom" || t === "x";
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(t) {
          this.beforeTickToLabelConversion(), this.generateTickLabels(t);
          let e, i;
          for (e = 0, i = t.length; e < i; e++) Kt(t[e].label) && (t.splice(e, 1), i--, e--);
          this.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          let t = this._labelSizes;
          if (!t) {
            const e = this.options.ticks.sampleSize;
            let i = this.ticks;
            e < i.length && (i = Wf(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);
          }
          return t;
        }
        _computeLabelSizes(t, e, i) {
          const { ctx: s, _longestTextCache: r } = this, o = [], a = [], l = Math.floor(e / Vf(e, i));
          let c = 0, h = 0, u, d, f, g, _, m, p, y, w, M, C;
          for (u = 0; u < e; u += l) {
            if (g = t[u].label, _ = this._resolveTickFontOptions(u), s.font = m = _.string, p = r[m] = r[m] || {
              data: {},
              gc: []
            }, y = _.lineHeight, w = M = 0, !Kt(g) && !oe(g)) w = Ga(s, p.data, p.gc, w, g), M = y;
            else if (oe(g)) for (d = 0, f = g.length; d < f; ++d) C = g[d], !Kt(C) && !oe(C) && (w = Ga(s, p.data, p.gc, w, C), M += y);
            o.push(w), a.push(M), c = Math.max(w, c), h = Math.max(M, h);
          }
          bA(r, e);
          const R = o.indexOf(c), T = a.indexOf(h), v = (x) => ({
            width: o[x] || 0,
            height: a[x] || 0
          });
          return {
            first: v(0),
            last: v(e - 1),
            widest: v(R),
            highest: v(T),
            widths: o,
            heights: a
          };
        }
        getLabelForValue(t) {
          return t;
        }
        getPixelForValue(t, e) {
          return NaN;
        }
        getValueForPixel(t) {
        }
        getPixelForTick(t) {
          const e = this.ticks;
          return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
        }
        getPixelForDecimal(t) {
          this._reversePixels && (t = 1 - t);
          const e = this._startPixel + t * this._length;
          return eE(this._alignToPixels ? Yi(this.chart, e, 0) : e);
        }
        getDecimalForPixel(t) {
          const e = (t - this._startPixel) / this._length;
          return this._reversePixels ? 1 - e : e;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const { min: t, max: e } = this;
          return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
        }
        getContext(t) {
          const e = this.ticks || [];
          if (t >= 0 && t < e.length) {
            const i = e[t];
            return i.$context || (i.$context = vA(this.getContext(), t, i));
          }
          return this.$context || (this.$context = yA(this.chart.getContext(), this));
        }
        _tickSize() {
          const t = this.options.ticks, e = ke(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), r = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = r ? r.widest.width + o : 0, l = r ? r.highest.height + o : 0;
          return this.isHorizontal() ? l * i > a * s ? a / i : l / s : l * s < a * i ? l / i : a / s;
        }
        _isVisible() {
          const t = this.options.display;
          return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(t) {
          const e = this.axis, i = this.chart, s = this.options, { grid: r, position: o, border: a } = s, l = r.offset, c = this.isHorizontal(), u = this.ticks.length + (l ? 1 : 0), d = Ar(r), f = [], g = a.setContext(this.getContext()), _ = g.display ? g.width : 0, m = _ / 2, p = function(z) {
            return Yi(i, z, _);
          };
          let y, w, M, C, R, T, v, x, b, A, L, I;
          if (o === "top") y = p(this.bottom), T = this.bottom - d, x = y - m, A = p(t.top) + m, I = t.bottom;
          else if (o === "bottom") y = p(this.top), A = t.top, I = p(t.bottom) - m, T = y + m, x = this.top + d;
          else if (o === "left") y = p(this.right), R = this.right - d, v = y - m, b = p(t.left) + m, L = t.right;
          else if (o === "right") y = p(this.left), b = t.left, L = p(t.right) - m, R = y + m, v = this.left + d;
          else if (e === "x") {
            if (o === "center") y = p((t.top + t.bottom) / 2 + 0.5);
            else if (Wt(o)) {
              const z = Object.keys(o)[0], V = o[z];
              y = p(this.chart.scales[z].getPixelForValue(V));
            }
            A = t.top, I = t.bottom, T = y + m, x = T + d;
          } else if (e === "y") {
            if (o === "center") y = p((t.left + t.right) / 2);
            else if (Wt(o)) {
              const z = Object.keys(o)[0], V = o[z];
              y = p(this.chart.scales[z].getPixelForValue(V));
            }
            R = y - m, v = R - d, b = t.left, L = t.right;
          }
          const H = Ut(s.ticks.maxTicksLimit, u), j = Math.max(1, Math.ceil(u / H));
          for (w = 0; w < u; w += j) {
            const z = this.getContext(w), V = r.setContext(z), U = a.setContext(z), q = V.lineWidth, rt = V.color, et = U.dash || [], ut = U.dashOffset, ot = V.tickWidth, W = V.tickColor, J = V.tickBorderDash || [], ct = V.tickBorderDashOffset;
            M = xA(this, w, l), M !== void 0 && (C = Yi(i, M, q), c ? R = v = b = L = C : T = x = A = I = C, f.push({
              tx1: R,
              ty1: T,
              tx2: v,
              ty2: x,
              x1: b,
              y1: A,
              x2: L,
              y2: I,
              width: q,
              color: rt,
              borderDash: et,
              borderDashOffset: ut,
              tickWidth: ot,
              tickColor: W,
              tickBorderDash: J,
              tickBorderDashOffset: ct
            }));
          }
          return this._ticksLength = u, this._borderValue = y, f;
        }
        _computeLabelItems(t) {
          const e = this.axis, i = this.options, { position: s, ticks: r } = i, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: h, mirror: u } = r, d = Ar(i.grid), f = d + h, g = u ? -h : f, _ = -ke(this.labelRotation), m = [];
          let p, y, w, M, C, R, T, v, x, b, A, L, I = "middle";
          if (s === "top") R = this.bottom - g, T = this._getXAxisLabelAlignment();
          else if (s === "bottom") R = this.top + g, T = this._getXAxisLabelAlignment();
          else if (s === "left") {
            const j = this._getYAxisLabelAlignment(d);
            T = j.textAlign, C = j.x;
          } else if (s === "right") {
            const j = this._getYAxisLabelAlignment(d);
            T = j.textAlign, C = j.x;
          } else if (e === "x") {
            if (s === "center") R = (t.top + t.bottom) / 2 + f;
            else if (Wt(s)) {
              const j = Object.keys(s)[0], z = s[j];
              R = this.chart.scales[j].getPixelForValue(z) + f;
            }
            T = this._getXAxisLabelAlignment();
          } else if (e === "y") {
            if (s === "center") C = (t.left + t.right) / 2 - f;
            else if (Wt(s)) {
              const j = Object.keys(s)[0], z = s[j];
              C = this.chart.scales[j].getPixelForValue(z);
            }
            T = this._getYAxisLabelAlignment(d).textAlign;
          }
          e === "y" && (l === "start" ? I = "top" : l === "end" && (I = "bottom"));
          const H = this._getLabelSizes();
          for (p = 0, y = a.length; p < y; ++p) {
            w = a[p], M = w.label;
            const j = r.setContext(this.getContext(p));
            v = this.getPixelForTick(p) + r.labelOffset, x = this._resolveTickFontOptions(p), b = x.lineHeight, A = oe(M) ? M.length : 1;
            const z = A / 2, V = j.color, U = j.textStrokeColor, q = j.textStrokeWidth;
            let rt = T;
            o ? (C = v, T === "inner" && (p === y - 1 ? rt = this.options.reverse ? "left" : "right" : p === 0 ? rt = this.options.reverse ? "right" : "left" : rt = "center"), s === "top" ? c === "near" || _ !== 0 ? L = -A * b + b / 2 : c === "center" ? L = -H.highest.height / 2 - z * b + b : L = -H.highest.height + b / 2 : c === "near" || _ !== 0 ? L = b / 2 : c === "center" ? L = H.highest.height / 2 - z * b : L = H.highest.height - A * b, u && (L *= -1), _ !== 0 && !j.showLabelBackdrop && (C += b / 2 * Math.sin(_))) : (R = v, L = (1 - A) * b / 2);
            let et;
            if (j.showLabelBackdrop) {
              const ut = Fe(j.backdropPadding), ot = H.heights[p], W = H.widths[p];
              let J = L - ut.top, ct = 0 - ut.left;
              switch (I) {
                case "middle":
                  J -= ot / 2;
                  break;
                case "bottom":
                  J -= ot;
                  break;
              }
              switch (T) {
                case "center":
                  ct -= W / 2;
                  break;
                case "right":
                  ct -= W;
                  break;
                case "inner":
                  p === y - 1 ? ct -= W : p > 0 && (ct -= W / 2);
                  break;
              }
              et = {
                left: ct,
                top: J,
                width: W + ut.width,
                height: ot + ut.height,
                color: j.backdropColor
              };
            }
            m.push({
              label: M,
              font: x,
              textOffset: L,
              options: {
                rotation: _,
                color: V,
                strokeColor: U,
                strokeWidth: q,
                textAlign: rt,
                textBaseline: I,
                translation: [
                  C,
                  R
                ],
                backdrop: et
              }
            });
          }
          return m;
        }
        _getXAxisLabelAlignment() {
          const { position: t, ticks: e } = this.options;
          if (-ke(this.labelRotation)) return t === "top" ? "left" : "right";
          let s = "center";
          return e.align === "start" ? s = "left" : e.align === "end" ? s = "right" : e.align === "inner" && (s = "inner"), s;
        }
        _getYAxisLabelAlignment(t) {
          const { position: e, ticks: { crossAlign: i, mirror: s, padding: r } } = this.options, o = this._getLabelSizes(), a = t + r, l = o.widest.width;
          let c, h;
          return e === "left" ? s ? (h = this.right + r, i === "near" ? c = "left" : i === "center" ? (c = "center", h += l / 2) : (c = "right", h += l)) : (h = this.right - a, i === "near" ? c = "right" : i === "center" ? (c = "center", h -= l / 2) : (c = "left", h = this.left)) : e === "right" ? s ? (h = this.left + r, i === "near" ? c = "right" : i === "center" ? (c = "center", h -= l / 2) : (c = "left", h -= l)) : (h = this.left + a, i === "near" ? c = "left" : i === "center" ? (c = "center", h += l / 2) : (c = "right", h = this.right)) : c = "right", {
            textAlign: c,
            x: h
          };
        }
        _computeLabelArea() {
          if (this.options.ticks.mirror) return;
          const t = this.chart, e = this.options.position;
          if (e === "left" || e === "right") return {
            top: 0,
            left: this.left,
            bottom: t.height,
            right: this.right
          };
          if (e === "top" || e === "bottom") return {
            top: this.top,
            left: 0,
            bottom: this.bottom,
            right: t.width
          };
        }
        drawBackground() {
          const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: r, height: o } = this;
          e && (t.save(), t.fillStyle = e, t.fillRect(i, s, r, o), t.restore());
        }
        getLineWidthForValue(t) {
          const e = this.options.grid;
          if (!this._isVisible() || !e.display) return 0;
          const s = this.ticks.findIndex((r) => r.value === t);
          return s >= 0 ? e.setContext(this.getContext(s)).lineWidth : 0;
        }
        drawGrid(t) {
          const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
          let r, o;
          const a = (l, c, h) => {
            !h.width || !h.color || (i.save(), i.lineWidth = h.width, i.strokeStyle = h.color, i.setLineDash(h.borderDash || []), i.lineDashOffset = h.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(c.x, c.y), i.stroke(), i.restore());
          };
          if (e.display) for (r = 0, o = s.length; r < o; ++r) {
            const l = s[r];
            e.drawOnChartArea && a({
              x: l.x1,
              y: l.y1
            }, {
              x: l.x2,
              y: l.y2
            }, l), e.drawTicks && a({
              x: l.tx1,
              y: l.ty1
            }, {
              x: l.tx2,
              y: l.ty2
            }, {
              color: l.tickColor,
              width: l.tickWidth,
              borderDash: l.tickBorderDash,
              borderDashOffset: l.tickBorderDashOffset
            });
          }
        }
        drawBorder() {
          const { chart: t, ctx: e, options: { border: i, grid: s } } = this, r = i.setContext(this.getContext()), o = i.display ? r.width : 0;
          if (!o) return;
          const a = s.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
          let c, h, u, d;
          this.isHorizontal() ? (c = Yi(t, this.left, o) - o / 2, h = Yi(t, this.right, a) + a / 2, u = d = l) : (u = Yi(t, this.top, o) - o / 2, d = Yi(t, this.bottom, a) + a / 2, c = h = l), e.save(), e.lineWidth = r.width, e.strokeStyle = r.color, e.beginPath(), e.moveTo(c, u), e.lineTo(h, d), e.stroke(), e.restore();
        }
        drawLabels(t) {
          if (!this.options.ticks.display) return;
          const i = this.ctx, s = this._computeLabelArea();
          s && uo(i, s);
          const r = this.getLabelItems(t);
          for (const o of r) {
            const a = o.options, l = o.font, c = o.label, h = o.textOffset;
            us(i, c, 0, h, l, a);
          }
          s && fo(i);
        }
        drawTitle() {
          const { ctx: t, options: { position: e, title: i, reverse: s } } = this;
          if (!i.display) return;
          const r = Te(i.font), o = Fe(i.padding), a = i.align;
          let l = r.lineHeight / 2;
          e === "bottom" || e === "center" || Wt(e) ? (l += o.bottom, oe(i.text) && (l += r.lineHeight * (i.text.length - 1))) : l += o.top;
          const { titleX: c, titleY: h, maxWidth: u, rotation: d } = SA(this, l, e, a);
          us(t, i.text, 0, 0, r, {
            color: i.color,
            maxWidth: u,
            rotation: d,
            textAlign: MA(a, e, s),
            textBaseline: "middle",
            translation: [
              c,
              h
            ]
          });
        }
        draw(t) {
          this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
        }
        _layers() {
          const t = this.options, e = t.ticks && t.ticks.z || 0, i = Ut(t.grid && t.grid.z, -1), s = Ut(t.border && t.border.z, 0);
          return !this._isVisible() || this.draw !== ms.prototype.draw ? [
            {
              z: e,
              draw: (r) => {
                this.draw(r);
              }
            }
          ] : [
            {
              z: i,
              draw: (r) => {
                this.drawBackground(), this.drawGrid(r), this.drawTitle();
              }
            },
            {
              z: s,
              draw: () => {
                this.drawBorder();
              }
            },
            {
              z: e,
              draw: (r) => {
                this.drawLabels(r);
              }
            }
          ];
        }
        getMatchingVisibleMetas(t) {
          const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", s = [];
          let r, o;
          for (r = 0, o = e.length; r < o; ++r) {
            const a = e[r];
            a[i] === this.id && (!t || a.type === t) && s.push(a);
          }
          return s;
        }
        _resolveTickFontOptions(t) {
          const e = this.options.ticks.setContext(this.getContext(t));
          return Te(e.font);
        }
        _maxDigits() {
          const t = this._resolveTickFontOptions(0).lineHeight;
          return (this.isHorizontal() ? this.width : this.height) / t;
        }
      }
      class ca {
        constructor(t, e, i) {
          this.type = t, this.scope = e, this.override = i, this.items = /* @__PURE__ */ Object.create(null);
        }
        isForType(t) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
        }
        register(t) {
          const e = Object.getPrototypeOf(t);
          let i;
          TA(e) && (i = this.register(e));
          const s = this.items, r = t.id, o = this.scope + "." + r;
          if (!r) throw new Error("class does not have id: " + t);
          return r in s || (s[r] = t, wA(t, o, i), this.override && be.override(t.id, t.overrides)), o;
        }
        get(t) {
          return this.items[t];
        }
        unregister(t) {
          const e = this.items, i = t.id, s = this.scope;
          i in e && delete e[i], s && i in be[s] && (delete be[s][i], this.override && delete hs[i]);
        }
      }
      function wA(n, t, e) {
        const i = eo(/* @__PURE__ */ Object.create(null), [
          e ? be.get(e) : {},
          be.get(t),
          n.defaults
        ]);
        be.set(t, i), n.defaultRoutes && EA(t, n.defaultRoutes), n.descriptors && be.describe(t, n.descriptors);
      }
      function EA(n, t) {
        Object.keys(t).forEach((e) => {
          const i = e.split("."), s = i.pop(), r = [
            n
          ].concat(i).join("."), o = t[e].split("."), a = o.pop(), l = o.join(".");
          be.route(r, s, l, a);
        });
      }
      function TA(n) {
        return "id" in n && "defaults" in n;
      }
      class AA {
        constructor() {
          this.controllers = new ca(Ni, "datasets", true), this.elements = new ca(Ke, "elements"), this.plugins = new ca(Object, "plugins"), this.scales = new ca(ms, "scales"), this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
          ];
        }
        add(...t) {
          this._each("register", t);
        }
        remove(...t) {
          this._each("unregister", t);
        }
        addControllers(...t) {
          this._each("register", t, this.controllers);
        }
        addElements(...t) {
          this._each("register", t, this.elements);
        }
        addPlugins(...t) {
          this._each("register", t, this.plugins);
        }
        addScales(...t) {
          this._each("register", t, this.scales);
        }
        getController(t) {
          return this._get(t, this.controllers, "controller");
        }
        getElement(t) {
          return this._get(t, this.elements, "element");
        }
        getPlugin(t) {
          return this._get(t, this.plugins, "plugin");
        }
        getScale(t) {
          return this._get(t, this.scales, "scale");
        }
        removeControllers(...t) {
          this._each("unregister", t, this.controllers);
        }
        removeElements(...t) {
          this._each("unregister", t, this.elements);
        }
        removePlugins(...t) {
          this._each("unregister", t, this.plugins);
        }
        removeScales(...t) {
          this._each("unregister", t, this.scales);
        }
        _each(t, e, i) {
          [
            ...e
          ].forEach((s) => {
            const r = i || this._getRegistryForType(s);
            i || r.isForType(s) || r === this.plugins && s.id ? this._exec(t, r, s) : he(s, (o) => {
              const a = i || this._getRegistryForType(o);
              this._exec(t, a, o);
            });
          });
        }
        _exec(t, e, i) {
          const s = eu(t);
          ce(i["before" + s], [], i), e[t](i), ce(i["after" + s], [], i);
        }
        _getRegistryForType(t) {
          for (let e = 0; e < this._typedRegistries.length; e++) {
            const i = this._typedRegistries[e];
            if (i.isForType(t)) return i;
          }
          return this.plugins;
        }
        _get(t, e, i) {
          const s = e.get(t);
          if (s === void 0) throw new Error('"' + t + '" is not a registered ' + i + ".");
          return s;
        }
      }
      var kn = new AA();
      class CA {
        constructor() {
          this._init = [];
        }
        notify(t, e, i, s) {
          e === "beforeInit" && (this._init = this._createDescriptors(t, true), this._notify(this._init, t, "install"));
          const r = s ? this._descriptors(t).filter(s) : this._descriptors(t), o = this._notify(r, t, e, i);
          return e === "afterDestroy" && (this._notify(r, t, "stop"), this._notify(this._init, t, "uninstall")), o;
        }
        _notify(t, e, i, s) {
          s = s || {};
          for (const r of t) {
            const o = r.plugin, a = o[i], l = [
              e,
              s,
              r.options
            ];
            if (ce(a, l, o) === false && s.cancelable) return false;
          }
          return true;
        }
        invalidate() {
          Kt(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
        }
        _descriptors(t) {
          if (this._cache) return this._cache;
          const e = this._cache = this._createDescriptors(t);
          return this._notifyStateChanges(t), e;
        }
        _createDescriptors(t, e) {
          const i = t && t.config, s = Ut(i.options && i.options.plugins, {}), r = RA(i);
          return s === false && !e ? [] : DA(t, r, s, e);
        }
        _notifyStateChanges(t) {
          const e = this._oldCache || [], i = this._cache, s = (r, o) => r.filter((a) => !o.some((l) => a.plugin.id === l.plugin.id));
          this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start");
        }
      }
      function RA(n) {
        const t = {}, e = [], i = Object.keys(kn.plugins.items);
        for (let r = 0; r < i.length; r++) e.push(kn.getPlugin(i[r]));
        const s = n.plugins || [];
        for (let r = 0; r < s.length; r++) {
          const o = s[r];
          e.indexOf(o) === -1 && (e.push(o), t[o.id] = true);
        }
        return {
          plugins: e,
          localIds: t
        };
      }
      function PA(n, t) {
        return !t && n === false ? null : n === true ? {} : n;
      }
      function DA(n, { plugins: t, localIds: e }, i, s) {
        const r = [], o = n.getContext();
        for (const a of t) {
          const l = a.id, c = PA(i[l], s);
          c !== null && r.push({
            plugin: a,
            options: LA(n.config, {
              plugin: a,
              local: e[l]
            }, c, o)
          });
        }
        return r;
      }
      function LA(n, { plugin: t, local: e }, i, s) {
        const r = n.pluginScopeKeys(t), o = n.getOptionScopes(i, r);
        return e && t.defaults && o.push(t.defaults), n.createResolver(o, s, [
          ""
        ], {
          scriptable: false,
          indexable: false,
          allKeys: true
        });
      }
      function mh(n, t) {
        const e = be.datasets[n] || {};
        return ((t.datasets || {})[n] || {}).indexAxis || t.indexAxis || e.indexAxis || "x";
      }
      function IA(n, t) {
        let e = n;
        return n === "_index_" ? e = t : n === "_value_" && (e = t === "x" ? "y" : "x"), e;
      }
      function OA(n, t) {
        return n === t ? "_index_" : "_value_";
      }
      function Xf(n) {
        if (n === "x" || n === "y" || n === "r") return n;
      }
      function kA(n) {
        if (n === "top" || n === "bottom") return "x";
        if (n === "left" || n === "right") return "y";
      }
      function gh(n, ...t) {
        if (Xf(n)) return n;
        for (const e of t) {
          const i = e.axis || kA(e.position) || n.length > 1 && Xf(n[0].toLowerCase());
          if (i) return i;
        }
        throw new Error(`Cannot determine type of '${n}' axis. Please provide 'axis' or 'position' option.`);
      }
      function Yf(n, t, e) {
        if (e[t + "AxisID"] === n) return {
          axis: t
        };
      }
      function FA(n, t) {
        if (t.data && t.data.datasets) {
          const e = t.data.datasets.filter((i) => i.xAxisID === n || i.yAxisID === n);
          if (e.length) return Yf(n, "x", e[0]) || Yf(n, "y", e[0]);
        }
        return {};
      }
      function NA(n, t) {
        const e = hs[n.type] || {
          scales: {}
        }, i = t.scales || {}, s = mh(n.type, t), r = /* @__PURE__ */ Object.create(null);
        return Object.keys(i).forEach((o) => {
          const a = i[o];
          if (!Wt(a)) return console.error(`Invalid scale configuration for scale: ${o}`);
          if (a._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
          const l = gh(o, a, FA(o, n), be.scales[a.type]), c = OA(l, s), h = e.scales || {};
          r[o] = Vr(/* @__PURE__ */ Object.create(null), [
            {
              axis: l
            },
            a,
            h[l],
            h[c]
          ]);
        }), n.data.datasets.forEach((o) => {
          const a = o.type || n.type, l = o.indexAxis || mh(a, t), h = (hs[a] || {}).scales || {};
          Object.keys(h).forEach((u) => {
            const d = IA(u, l), f = o[d + "AxisID"] || d;
            r[f] = r[f] || /* @__PURE__ */ Object.create(null), Vr(r[f], [
              {
                axis: d
              },
              i[f],
              h[u]
            ]);
          });
        }), Object.keys(r).forEach((o) => {
          const a = r[o];
          Vr(a, [
            be.scales[a.type],
            be.scale
          ]);
        }), r;
      }
      function Dg(n) {
        const t = n.options || (n.options = {});
        t.plugins = Ut(t.plugins, {}), t.scales = NA(n, t);
      }
      function Lg(n) {
        return n = n || {}, n.datasets = n.datasets || [], n.labels = n.labels || [], n;
      }
      function UA(n) {
        return n = n || {}, n.data = Lg(n.data), Dg(n), n;
      }
      const jf = /* @__PURE__ */ new Map(), Ig = /* @__PURE__ */ new Set();
      function ha(n, t) {
        let e = jf.get(n);
        return e || (e = t(), jf.set(n, e), Ig.add(e)), e;
      }
      const Cr = (n, t, e) => {
        const i = Ii(t, e);
        i !== void 0 && n.add(i);
      };
      class BA {
        constructor(t) {
          this._config = UA(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
        }
        get platform() {
          return this._config.platform;
        }
        get type() {
          return this._config.type;
        }
        set type(t) {
          this._config.type = t;
        }
        get data() {
          return this._config.data;
        }
        set data(t) {
          this._config.data = Lg(t);
        }
        get options() {
          return this._config.options;
        }
        set options(t) {
          this._config.options = t;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const t = this._config;
          this.clearCache(), Dg(t);
        }
        clearCache() {
          this._scopeCache.clear(), this._resolverCache.clear();
        }
        datasetScopeKeys(t) {
          return ha(t, () => [
            [
              `datasets.${t}`,
              ""
            ]
          ]);
        }
        datasetAnimationScopeKeys(t, e) {
          return ha(`${t}.transition.${e}`, () => [
            [
              `datasets.${t}.transitions.${e}`,
              `transitions.${e}`
            ],
            [
              `datasets.${t}`,
              ""
            ]
          ]);
        }
        datasetElementScopeKeys(t, e) {
          return ha(`${t}-${e}`, () => [
            [
              `datasets.${t}.elements.${e}`,
              `datasets.${t}`,
              `elements.${e}`,
              ""
            ]
          ]);
        }
        pluginScopeKeys(t) {
          const e = t.id, i = this.type;
          return ha(`${i}-plugin-${e}`, () => [
            [
              `plugins.${e}`,
              ...t.additionalOptionScopes || []
            ]
          ]);
        }
        _cachedScopes(t, e) {
          const i = this._scopeCache;
          let s = i.get(t);
          return (!s || e) && (s = /* @__PURE__ */ new Map(), i.set(t, s)), s;
        }
        getOptionScopes(t, e, i) {
          const { options: s, type: r } = this, o = this._cachedScopes(t, i), a = o.get(e);
          if (a) return a;
          const l = /* @__PURE__ */ new Set();
          e.forEach((h) => {
            t && (l.add(t), h.forEach((u) => Cr(l, t, u))), h.forEach((u) => Cr(l, s, u)), h.forEach((u) => Cr(l, hs[r] || {}, u)), h.forEach((u) => Cr(l, be, u)), h.forEach((u) => Cr(l, fh, u));
          });
          const c = Array.from(l);
          return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), Ig.has(e) && o.set(e, c), c;
        }
        chartOptionScopes() {
          const { options: t, type: e } = this;
          return [
            t,
            hs[e] || {},
            be.datasets[e] || {},
            {
              type: e
            },
            be,
            fh
          ];
        }
        resolveNamedOptions(t, e, i, s = [
          ""
        ]) {
          const r = {
            $shared: true
          }, { resolver: o, subPrefixes: a } = qf(this._resolverCache, t, s);
          let l = o;
          if (HA(o, e)) {
            r.$shared = false, i = ln(i) ? i() : i;
            const c = this.createResolver(t, i, a);
            l = rr(o, i, c);
          }
          for (const c of e) r[c] = l[c];
          return r;
        }
        createResolver(t, e, i = [
          ""
        ], s) {
          const { resolver: r } = qf(this._resolverCache, t, i);
          return Wt(e) ? rr(r, e, void 0, s) : r;
        }
      }
      function qf(n, t, e) {
        let i = n.get(t);
        i || (i = /* @__PURE__ */ new Map(), n.set(t, i));
        const s = e.join();
        let r = i.get(s);
        return r || (r = {
          resolver: au(t, e),
          subPrefixes: e.filter((a) => !a.toLowerCase().includes("hover"))
        }, i.set(s, r)), r;
      }
      const zA = (n) => Wt(n) && Object.getOwnPropertyNames(n).some((t) => ln(n[t]));
      function HA(n, t) {
        const { isScriptable: e, isIndexable: i } = hg(n);
        for (const s of t) {
          const r = e(s), o = i(s), a = (o || r) && n[s];
          if (r && (ln(a) || zA(a)) || o && oe(a)) return true;
        }
        return false;
      }
      var VA = "4.4.9";
      const WA = [
        "top",
        "bottom",
        "left",
        "right",
        "chartArea"
      ];
      function $f(n, t) {
        return n === "top" || n === "bottom" || WA.indexOf(n) === -1 && t === "x";
      }
      function Kf(n, t) {
        return function(e, i) {
          return e[n] === i[n] ? e[t] - i[t] : e[n] - i[n];
        };
      }
      function Zf(n) {
        const t = n.chart, e = t.options.animation;
        t.notifyPlugins("afterRender"), ce(e && e.onComplete, [
          n
        ], t);
      }
      function GA(n) {
        const t = n.chart, e = t.options.animation;
        ce(e && e.onProgress, [
          n
        ], t);
      }
      function Og(n) {
        return hu() && typeof n == "string" ? n = document.getElementById(n) : n && n.length && (n = n[0]), n && n.canvas && (n = n.canvas), n;
      }
      const Aa = {}, Qf = (n) => {
        const t = Og(n);
        return Object.values(Aa).filter((e) => e.canvas === t).pop();
      };
      function XA(n, t, e) {
        const i = Object.keys(n);
        for (const s of i) {
          const r = +s;
          if (r >= t) {
            const o = n[s];
            delete n[s], (e > 0 || r > t) && (n[r + e] = o);
          }
        }
      }
      function YA(n, t, e, i) {
        return !e || n.type === "mouseout" ? null : i ? t : n;
      }
      class Ri {
        static register(...t) {
          kn.add(...t), Jf();
        }
        static unregister(...t) {
          kn.remove(...t), Jf();
        }
        constructor(t, e) {
          const i = this.config = new BA(e), s = Og(t), r = Qf(s);
          if (r) throw new Error("Canvas is already in use. Chart with ID '" + r.id + "' must be destroyed before the canvas with ID '" + r.canvas.id + "' can be reused.");
          const o = i.createResolver(i.chartOptionScopes(), this.getContext());
          this.platform = new (i.platform || hA(s))(), this.platform.updateConfig(i);
          const a = this.platform.acquireContext(s, o.aspectRatio), l = a && a.canvas, c = l && l.height, h = l && l.width;
          if (this.id = Ww(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new CA(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = rE((u) => this.update(u), o.resizeDelay || 0), this._dataChanges = [], Aa[this.id] = this, !a || !l) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }
          ti.listen(this, "complete", Zf), ti.listen(this, "progress", GA), this._initialize(), this.attached && this.update();
        }
        get aspectRatio() {
          const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: s, _aspectRatio: r } = this;
          return Kt(t) ? e && r ? r : s ? i / s : null : t;
        }
        get data() {
          return this.config.data;
        }
        set data(t) {
          this.config.data = t;
        }
        get options() {
          return this._options;
        }
        set options(t) {
          this.config.options = t;
        }
        get registry() {
          return kn;
        }
        _initialize() {
          return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : vf(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
        }
        clear() {
          return xf(this.canvas, this.ctx), this;
        }
        stop() {
          return ti.stop(this), this;
        }
        resize(t, e) {
          ti.running(this) ? this._resizeBeforeDraw = {
            width: t,
            height: e
          } : this._resize(t, e);
        }
        _resize(t, e) {
          const i = this.options, s = this.canvas, r = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(s, t, e, r), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
          this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, vf(this, a, true) && (this.notifyPlugins("resize", {
            size: o
          }), ce(i.onResize, [
            this,
            o
          ], this), this.attached && this._doResize(l) && this.render());
        }
        ensureScalesHaveIDs() {
          const e = this.options.scales || {};
          he(e, (i, s) => {
            i.id = s;
          });
        }
        buildOrUpdateScales() {
          const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((o, a) => (o[a] = false, o), {});
          let r = [];
          e && (r = r.concat(Object.keys(e).map((o) => {
            const a = e[o], l = gh(o, a), c = l === "r", h = l === "x";
            return {
              options: a,
              dposition: c ? "chartArea" : h ? "bottom" : "left",
              dtype: c ? "radialLinear" : h ? "category" : "linear"
            };
          }))), he(r, (o) => {
            const a = o.options, l = a.id, c = gh(l, a), h = Ut(a.type, o.dtype);
            (a.position === void 0 || $f(a.position, c) !== $f(o.dposition)) && (a.position = o.dposition), s[l] = true;
            let u = null;
            if (l in i && i[l].type === h) u = i[l];
            else {
              const d = kn.getScale(h);
              u = new d({
                id: l,
                type: h,
                ctx: this.ctx,
                chart: this
              }), i[u.id] = u;
            }
            u.init(a, t);
          }), he(s, (o, a) => {
            o || delete i[a];
          }), he(i, (o) => {
            qe.configure(this, o, o.options), qe.addBox(this, o);
          });
        }
        _updateMetasets() {
          const t = this._metasets, e = this.data.datasets.length, i = t.length;
          if (t.sort((s, r) => s.index - r.index), i > e) {
            for (let s = e; s < i; ++s) this._destroyDatasetMeta(s);
            t.splice(e, i - e);
          }
          this._sortedMetasets = t.slice(0).sort(Kf("order", "index"));
        }
        _removeUnreferencedMetasets() {
          const { _metasets: t, data: { datasets: e } } = this;
          t.length > e.length && delete this._stacks, t.forEach((i, s) => {
            e.filter((r) => r === i._dataset).length === 0 && this._destroyDatasetMeta(s);
          });
        }
        buildOrUpdateControllers() {
          const t = [], e = this.data.datasets;
          let i, s;
          for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) {
            const r = e[i];
            let o = this.getDatasetMeta(i);
            const a = r.type || this.config.type;
            if (o.type && o.type !== a && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = a, o.indexAxis = r.indexAxis || mh(a, this.options), o.order = r.order || 0, o.index = i, o.label = "" + r.label, o.visible = this.isDatasetVisible(i), o.controller) o.controller.updateIndex(i), o.controller.linkScales();
            else {
              const l = kn.getController(a), { datasetElementType: c, dataElementType: h } = be.datasets[a];
              Object.assign(l, {
                dataElementType: kn.getElement(h),
                datasetElementType: c && kn.getElement(c)
              }), o.controller = new l(this, i), t.push(o.controller);
            }
          }
          return this._updateMetasets(), t;
        }
        _resetElements() {
          he(this.data.datasets, (t, e) => {
            this.getDatasetMeta(e).controller.reset();
          }, this);
        }
        reset() {
          this._resetElements(), this.notifyPlugins("reset");
        }
        update(t) {
          const e = this.config;
          e.update();
          const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation;
          if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
            mode: t,
            cancelable: true
          }) === false) return;
          const r = this.buildOrUpdateControllers();
          this.notifyPlugins("beforeElementsUpdate");
          let o = 0;
          for (let c = 0, h = this.data.datasets.length; c < h; c++) {
            const { controller: u } = this.getDatasetMeta(c), d = !s && r.indexOf(u) === -1;
            u.buildOrUpdateElements(d), o = Math.max(+u.getMaxOverflow(), o);
          }
          o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || he(r, (c) => {
            c.reset();
          }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
            mode: t
          }), this._layers.sort(Kf("z", "_idx"));
          const { _active: a, _lastEvent: l } = this;
          l ? this._eventHandler(l, true) : a.length && this._updateHoverStyles(a, a, true), this.render();
        }
        _updateScales() {
          he(this.scales, (t) => {
            qe.removeBox(this, t);
          }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
        }
        _checkEventBindings() {
          const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events);
          (!hf(e, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
        }
        _updateHiddenIndices() {
          const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];
          for (const { method: i, start: s, count: r } of e) {
            const o = i === "_removeElements" ? -r : r;
            XA(t, s, o);
          }
        }
        _getUniformDataChanges() {
          const t = this._dataChanges;
          if (!t || !t.length) return;
          this._dataChanges = [];
          const e = this.data.datasets.length, i = (r) => new Set(t.filter((o) => o[0] === r).map((o, a) => a + "," + o.splice(1).join(","))), s = i(0);
          for (let r = 1; r < e; r++) if (!hf(s, i(r))) return;
          return Array.from(s).map((r) => r.split(",")).map((r) => ({
            method: r[1],
            start: +r[2],
            count: +r[3]
          }));
        }
        _updateLayout(t) {
          if (this.notifyPlugins("beforeLayout", {
            cancelable: true
          }) === false) return;
          qe.update(this, this.width, this.height, t);
          const e = this.chartArea, i = e.width <= 0 || e.height <= 0;
          this._layers = [], he(this.boxes, (s) => {
            i && s.position === "chartArea" || (s.configure && s.configure(), this._layers.push(...s._layers()));
          }, this), this._layers.forEach((s, r) => {
            s._idx = r;
          }), this.notifyPlugins("afterLayout");
        }
        _updateDatasets(t) {
          if (this.notifyPlugins("beforeDatasetsUpdate", {
            mode: t,
            cancelable: true
          }) !== false) {
            for (let e = 0, i = this.data.datasets.length; e < i; ++e) this.getDatasetMeta(e).controller.configure();
            for (let e = 0, i = this.data.datasets.length; e < i; ++e) this._updateDataset(e, ln(t) ? t({
              datasetIndex: e
            }) : t);
            this.notifyPlugins("afterDatasetsUpdate", {
              mode: t
            });
          }
        }
        _updateDataset(t, e) {
          const i = this.getDatasetMeta(t), s = {
            meta: i,
            index: t,
            mode: e,
            cancelable: true
          };
          this.notifyPlugins("beforeDatasetUpdate", s) !== false && (i.controller._update(e), s.cancelable = false, this.notifyPlugins("afterDatasetUpdate", s));
        }
        render() {
          this.notifyPlugins("beforeRender", {
            cancelable: true
          }) !== false && (ti.has(this) ? this.attached && !ti.running(this) && ti.start(this) : (this.draw(), Zf({
            chart: this
          })));
        }
        draw() {
          let t;
          if (this._resizeBeforeDraw) {
            const { width: i, height: s } = this._resizeBeforeDraw;
            this._resizeBeforeDraw = null, this._resize(i, s);
          }
          if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
            cancelable: true
          }) === false) return;
          const e = this._layers;
          for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);
          for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);
          this.notifyPlugins("afterDraw");
        }
        _getSortedDatasetMetas(t) {
          const e = this._sortedMetasets, i = [];
          let s, r;
          for (s = 0, r = e.length; s < r; ++s) {
            const o = e[s];
            (!t || o.visible) && i.push(o);
          }
          return i;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
          if (this.notifyPlugins("beforeDatasetsDraw", {
            cancelable: true
          }) === false) return;
          const t = this.getSortedVisibleDatasetMetas();
          for (let e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);
          this.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(t) {
          const e = this.ctx, i = {
            meta: t,
            index: t.index,
            cancelable: true
          }, s = vg(this, t);
          this.notifyPlugins("beforeDatasetDraw", i) !== false && (s && uo(e, s), t.controller.draw(), s && fo(e), i.cancelable = false, this.notifyPlugins("afterDatasetDraw", i));
        }
        isPointInArea(t) {
          return li(t, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(t, e, i, s) {
          const r = WT.modes[e];
          return typeof r == "function" ? r(this, t, i, s) : [];
        }
        getDatasetMeta(t) {
          const e = this.data.datasets[t], i = this._metasets;
          let s = i.filter((r) => r && r._dataset === e).pop();
          return s || (s = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: e && e.order || 0,
            index: t,
            _dataset: e,
            _parsed: [],
            _sorted: false
          }, i.push(s)), s;
        }
        getContext() {
          return this.$context || (this.$context = Fi(null, {
            chart: this,
            type: "chart"
          }));
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(t) {
          const e = this.data.datasets[t];
          if (!e) return false;
          const i = this.getDatasetMeta(t);
          return typeof i.hidden == "boolean" ? !i.hidden : !e.hidden;
        }
        setDatasetVisibility(t, e) {
          const i = this.getDatasetMeta(t);
          i.hidden = !e;
        }
        toggleDataVisibility(t) {
          this._hiddenIndices[t] = !this._hiddenIndices[t];
        }
        getDataVisibility(t) {
          return !this._hiddenIndices[t];
        }
        _updateVisibility(t, e, i) {
          const s = i ? "show" : "hide", r = this.getDatasetMeta(t), o = r.controller._resolveAnimations(void 0, s);
          cn(e) ? (r.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(r, {
            visible: i
          }), this.update((a) => a.datasetIndex === t ? s : void 0));
        }
        hide(t, e) {
          this._updateVisibility(t, e, false);
        }
        show(t, e) {
          this._updateVisibility(t, e, true);
        }
        _destroyDatasetMeta(t) {
          const e = this._metasets[t];
          e && e.controller && e.controller._destroy(), delete this._metasets[t];
        }
        _stop() {
          let t, e;
          for (this.stop(), ti.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t);
        }
        destroy() {
          this.notifyPlugins("beforeDestroy");
          const { canvas: t, ctx: e } = this;
          this._stop(), this.config.clearCache(), t && (this.unbindEvents(), xf(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Aa[this.id], this.notifyPlugins("afterDestroy");
        }
        toBase64Image(...t) {
          return this.canvas.toDataURL(...t);
        }
        bindEvents() {
          this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
        }
        bindUserEvents() {
          const t = this._listeners, e = this.platform, i = (r, o) => {
            e.addEventListener(this, r, o), t[r] = o;
          }, s = (r, o, a) => {
            r.offsetX = o, r.offsetY = a, this._eventHandler(r);
          };
          he(this.options.events, (r) => i(r, s));
        }
        bindResponsiveEvents() {
          this._responsiveListeners || (this._responsiveListeners = {});
          const t = this._responsiveListeners, e = this.platform, i = (l, c) => {
            e.addEventListener(this, l, c), t[l] = c;
          }, s = (l, c) => {
            t[l] && (e.removeEventListener(this, l, c), delete t[l]);
          }, r = (l, c) => {
            this.canvas && this.resize(l, c);
          };
          let o;
          const a = () => {
            s("attach", a), this.attached = true, this.resize(), i("resize", r), i("detach", o);
          };
          o = () => {
            this.attached = false, s("resize", r), this._stop(), this._resize(0, 0), i("attach", a);
          }, e.isAttached(this.canvas) ? a() : o();
        }
        unbindEvents() {
          he(this._listeners, (t, e) => {
            this.platform.removeEventListener(this, e, t);
          }), this._listeners = {}, he(this._responsiveListeners, (t, e) => {
            this.platform.removeEventListener(this, e, t);
          }), this._responsiveListeners = void 0;
        }
        updateHoverStyle(t, e, i) {
          const s = i ? "set" : "remove";
          let r, o, a, l;
          for (e === "dataset" && (r = this.getDatasetMeta(t[0].datasetIndex), r.controller["_" + s + "DatasetHoverStyle"]()), a = 0, l = t.length; a < l; ++a) {
            o = t[a];
            const c = o && this.getDatasetMeta(o.datasetIndex).controller;
            c && c[s + "HoverStyle"](o.element, o.datasetIndex, o.index);
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(t) {
          const e = this._active || [], i = t.map(({ datasetIndex: r, index: o }) => {
            const a = this.getDatasetMeta(r);
            if (!a) throw new Error("No dataset found at index " + r);
            return {
              datasetIndex: r,
              element: a.data[o],
              index: o
            };
          });
          !Ba(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e));
        }
        notifyPlugins(t, e, i) {
          return this._plugins.notify(this, t, e, i);
        }
        isPluginEnabled(t) {
          return this._plugins._cache.filter((e) => e.plugin.id === t).length === 1;
        }
        _updateHoverStyles(t, e, i) {
          const s = this.options.hover, r = (l, c) => l.filter((h) => !c.some((u) => h.datasetIndex === u.datasetIndex && h.index === u.index)), o = r(e, t), a = i ? t : r(t, e);
          o.length && this.updateHoverStyle(o, s.mode, false), a.length && s.mode && this.updateHoverStyle(a, s.mode, true);
        }
        _eventHandler(t, e) {
          const i = {
            event: t,
            replay: e,
            cancelable: true,
            inChartArea: this.isPointInArea(t)
          }, s = (o) => (o.options.events || this.options.events).includes(t.native.type);
          if (this.notifyPlugins("beforeEvent", i, s) === false) return;
          const r = this._handleEvent(t, e, i.inChartArea);
          return i.cancelable = false, this.notifyPlugins("afterEvent", i, s), (r || i.changed) && this.render(), this;
        }
        _handleEvent(t, e, i) {
          const { _active: s = [], options: r } = this, o = e, a = this._getActiveElements(t, s, i, o), l = $w(t), c = YA(t, this._lastEvent, i, l);
          i && (this._lastEvent = null, ce(r.onHover, [
            t,
            a,
            this
          ], this), l && ce(r.onClick, [
            t,
            a,
            this
          ], this));
          const h = !Ba(a, s);
          return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = c, h;
        }
        _getActiveElements(t, e, i, s) {
          if (t.type === "mouseout") return [];
          if (!i) return e;
          const r = this.options.hover;
          return this.getElementsAtEventForMode(t, r.mode, r, s);
        }
      }
      __publicField(Ri, "defaults", be);
      __publicField(Ri, "instances", Aa);
      __publicField(Ri, "overrides", hs);
      __publicField(Ri, "registry", kn);
      __publicField(Ri, "version", VA);
      __publicField(Ri, "getChart", Qf);
      function Jf() {
        return he(Ri.instances, (n) => n._plugins.invalidate());
      }
      function jA(n, t, e) {
        const { startAngle: i, pixelMargin: s, x: r, y: o, outerRadius: a, innerRadius: l } = t;
        let c = s / a;
        n.beginPath(), n.arc(r, o, a, i - c, e + c), l > s ? (c = s / l, n.arc(r, o, l, e + c, i - c, true)) : n.arc(r, o, s, e + xe, i - xe), n.closePath(), n.clip();
      }
      function qA(n) {
        return ou(n, [
          "outerStart",
          "outerEnd",
          "innerStart",
          "innerEnd"
        ]);
      }
      function $A(n, t, e, i) {
        const s = qA(n.options.borderRadius), r = (e - t) / 2, o = Math.min(r, i * t / 2), a = (l) => {
          const c = (e - Math.min(r, l)) * i / 2;
          return Ve(l, 0, Math.min(r, c));
        };
        return {
          outerStart: a(s.outerStart),
          outerEnd: a(s.outerEnd),
          innerStart: Ve(s.innerStart, 0, o),
          innerEnd: Ve(s.innerEnd, 0, o)
        };
      }
      function zs(n, t, e, i) {
        return {
          x: e + n * Math.cos(t),
          y: i + n * Math.sin(t)
        };
      }
      function ja(n, t, e, i, s, r) {
        const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: h } = t, u = Math.max(t.outerRadius + i + e - c, 0), d = h > 0 ? h + i + e + c : 0;
        let f = 0;
        const g = s - l;
        if (i) {
          const j = h > 0 ? h - i : 0, z = u > 0 ? u - i : 0, V = (j + z) / 2, U = V !== 0 ? g * V / (V + i) : g;
          f = (g - U) / 2;
        }
        const _ = Math.max(1e-3, g * u - e / Zt) / u, m = (g - _) / 2, p = l + m + f, y = s - m - f, { outerStart: w, outerEnd: M, innerStart: C, innerEnd: R } = $A(t, d, u, y - p), T = u - w, v = u - M, x = p + w / T, b = y - M / v, A = d + C, L = d + R, I = p + C / A, H = y - R / L;
        if (n.beginPath(), r) {
          const j = (x + b) / 2;
          if (n.arc(o, a, u, x, j), n.arc(o, a, u, j, b), M > 0) {
            const q = zs(v, b, o, a);
            n.arc(q.x, q.y, M, b, y + xe);
          }
          const z = zs(L, y, o, a);
          if (n.lineTo(z.x, z.y), R > 0) {
            const q = zs(L, H, o, a);
            n.arc(q.x, q.y, R, y + xe, H + Math.PI);
          }
          const V = (y - R / d + (p + C / d)) / 2;
          if (n.arc(o, a, d, y - R / d, V, true), n.arc(o, a, d, V, p + C / d, true), C > 0) {
            const q = zs(A, I, o, a);
            n.arc(q.x, q.y, C, I + Math.PI, p - xe);
          }
          const U = zs(T, p, o, a);
          if (n.lineTo(U.x, U.y), w > 0) {
            const q = zs(T, x, o, a);
            n.arc(q.x, q.y, w, p - xe, x);
          }
        } else {
          n.moveTo(o, a);
          const j = Math.cos(x) * u + o, z = Math.sin(x) * u + a;
          n.lineTo(j, z);
          const V = Math.cos(b) * u + o, U = Math.sin(b) * u + a;
          n.lineTo(V, U);
        }
        n.closePath();
      }
      function KA(n, t, e, i, s) {
        const { fullCircles: r, startAngle: o, circumference: a } = t;
        let l = t.endAngle;
        if (r) {
          ja(n, t, e, i, l, s);
          for (let c = 0; c < r; ++c) n.fill();
          isNaN(a) || (l = o + (a % ge || ge));
        }
        return ja(n, t, e, i, l, s), n.fill(), l;
      }
      function ZA(n, t, e, i, s) {
        const { fullCircles: r, startAngle: o, circumference: a, options: l } = t, { borderWidth: c, borderJoinStyle: h, borderDash: u, borderDashOffset: d } = l, f = l.borderAlign === "inner";
        if (!c) return;
        n.setLineDash(u || []), n.lineDashOffset = d, f ? (n.lineWidth = c * 2, n.lineJoin = h || "round") : (n.lineWidth = c, n.lineJoin = h || "bevel");
        let g = t.endAngle;
        if (r) {
          ja(n, t, e, i, g, s);
          for (let _ = 0; _ < r; ++_) n.stroke();
          isNaN(a) || (g = o + (a % ge || ge));
        }
        f && jA(n, t, g), r || (ja(n, t, e, i, g, s), n.stroke());
      }
      class QA extends Ke {
        constructor(t) {
          super();
          __publicField(this, "circumference");
          __publicField(this, "endAngle");
          __publicField(this, "fullCircles");
          __publicField(this, "innerRadius");
          __publicField(this, "outerRadius");
          __publicField(this, "pixelMargin");
          __publicField(this, "startAngle");
          this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
        }
        inRange(t, e, i) {
          const s = this.getProps([
            "x",
            "y"
          ], i), { angle: r, distance: o } = Wa(s, {
            x: t,
            y: e
          }), { startAngle: a, endAngle: l, innerRadius: c, outerRadius: h, circumference: u } = this.getProps([
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], i), d = (this.options.spacing + this.options.borderWidth) / 2, f = Ut(u, l - a), g = no(r, a, l) && a !== l, _ = f >= ge || g, m = oi(o, c + d, h + d);
          return _ && m;
        }
        getCenterPoint(t) {
          const { x: e, y: i, startAngle: s, endAngle: r, innerRadius: o, outerRadius: a } = this.getProps([
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius"
          ], t), { offset: l, spacing: c } = this.options, h = (s + r) / 2, u = (o + a + c + l) / 2;
          return {
            x: e + Math.cos(h) * u,
            y: i + Math.sin(h) * u
          };
        }
        tooltipPosition(t) {
          return this.getCenterPoint(t);
        }
        draw(t) {
          const { options: e, circumference: i } = this, s = (e.offset || 0) / 4, r = (e.spacing || 0) / 2, o = e.circular;
          if (this.pixelMargin = e.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = i > ge ? Math.floor(i / ge) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;
          t.save();
          const a = (this.startAngle + this.endAngle) / 2;
          t.translate(Math.cos(a) * s, Math.sin(a) * s);
          const l = 1 - Math.sin(Math.min(Zt, i || 0)), c = s * l;
          t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, KA(t, this, c, r, o), ZA(t, this, c, r, o), t.restore();
        }
      }
      __publicField(QA, "id", "arc");
      __publicField(QA, "defaults", {
        borderAlign: "center",
        borderColor: "#fff",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: void 0,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0,
        circular: true
      });
      __publicField(QA, "defaultRoutes", {
        backgroundColor: "backgroundColor"
      });
      __publicField(QA, "descriptors", {
        _scriptable: true,
        _indexable: (t) => t !== "borderDash"
      });
      function kg(n, t, e = t) {
        n.lineCap = Ut(e.borderCapStyle, t.borderCapStyle), n.setLineDash(Ut(e.borderDash, t.borderDash)), n.lineDashOffset = Ut(e.borderDashOffset, t.borderDashOffset), n.lineJoin = Ut(e.borderJoinStyle, t.borderJoinStyle), n.lineWidth = Ut(e.borderWidth, t.borderWidth), n.strokeStyle = Ut(e.borderColor, t.borderColor);
      }
      function JA(n, t, e) {
        n.lineTo(e.x, e.y);
      }
      function t1(n) {
        return n.stepped ? _E : n.tension || n.cubicInterpolationMode === "monotone" ? xE : JA;
      }
      function Fg(n, t, e = {}) {
        const i = n.length, { start: s = 0, end: r = i - 1 } = e, { start: o, end: a } = t, l = Math.max(s, o), c = Math.min(r, a), h = s < o && r < o || s > a && r > a;
        return {
          count: i,
          start: l,
          loop: t.loop,
          ilen: c < l && !h ? i + c - l : c - l
        };
      }
      function e1(n, t, e, i) {
        const { points: s, options: r } = t, { count: o, start: a, loop: l, ilen: c } = Fg(s, e, i), h = t1(r);
        let { move: u = true, reverse: d } = i || {}, f, g, _;
        for (f = 0; f <= c; ++f) g = s[(a + (d ? c - f : f)) % o], !g.skip && (u ? (n.moveTo(g.x, g.y), u = false) : h(n, _, g, d, r.stepped), _ = g);
        return l && (g = s[(a + (d ? c : 0)) % o], h(n, _, g, d, r.stepped)), !!l;
      }
      function n1(n, t, e, i) {
        const s = t.points, { count: r, start: o, ilen: a } = Fg(s, e, i), { move: l = true, reverse: c } = i || {};
        let h = 0, u = 0, d, f, g, _, m, p;
        const y = (M) => (o + (c ? a - M : M)) % r, w = () => {
          _ !== m && (n.lineTo(h, m), n.lineTo(h, _), n.lineTo(h, p));
        };
        for (l && (f = s[y(0)], n.moveTo(f.x, f.y)), d = 0; d <= a; ++d) {
          if (f = s[y(d)], f.skip) continue;
          const M = f.x, C = f.y, R = M | 0;
          R === g ? (C < _ ? _ = C : C > m && (m = C), h = (u * h + M) / ++u) : (w(), n.lineTo(M, C), g = R, u = 0, _ = m = C), p = C;
        }
        w();
      }
      function _h(n) {
        const t = n.options, e = t.borderDash && t.borderDash.length;
        return !n._decimated && !n._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !e ? n1 : e1;
      }
      function i1(n) {
        return n.stepped ? KE : n.tension || n.cubicInterpolationMode === "monotone" ? ZE : Zi;
      }
      function s1(n, t, e, i) {
        let s = t._path;
        s || (s = t._path = new Path2D(), t.path(s, e, i) && s.closePath()), kg(n, t.options), n.stroke(s);
      }
      function r1(n, t, e, i) {
        const { segments: s, options: r } = t, o = _h(t);
        for (const a of s) kg(n, r, a.style), n.beginPath(), o(n, t, a, {
          start: e,
          end: e + i - 1
        }) && n.closePath(), n.stroke();
      }
      const o1 = typeof Path2D == "function";
      function a1(n, t, e, i) {
        o1 && !t.options.segment ? s1(n, t, e, i) : r1(n, t, e, i);
      }
      class ll extends Ke {
        constructor(t) {
          super(), this.animated = true, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, this._datasetIndex = void 0, t && Object.assign(this, t);
        }
        updateControlPoints(t, e) {
          const i = this.options;
          if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) {
            const s = i.spanGaps ? this._loop : this._fullLoop;
            VE(this._points, i, t, s, e), this._pointsUpdated = true;
          }
        }
        set points(t) {
          this._points = t, delete this._segments, delete this._path, this._pointsUpdated = false;
        }
        get points() {
          return this._points;
        }
        get segments() {
          return this._segments || (this._segments = iT(this, this.options.segment));
        }
        first() {
          const t = this.segments, e = this.points;
          return t.length && e[t[0].start];
        }
        last() {
          const t = this.segments, e = this.points, i = t.length;
          return i && e[t[i - 1].end];
        }
        interpolate(t, e) {
          const i = this.options, s = t[e], r = this.points, o = yg(this, {
            property: e,
            start: s,
            end: s
          });
          if (!o.length) return;
          const a = [], l = i1(i);
          let c, h;
          for (c = 0, h = o.length; c < h; ++c) {
            const { start: u, end: d } = o[c], f = r[u], g = r[d];
            if (f === g) {
              a.push(f);
              continue;
            }
            const _ = Math.abs((s - f[e]) / (g[e] - f[e])), m = l(f, g, _, i.stepped);
            m[e] = t[e], a.push(m);
          }
          return a.length === 1 ? a[0] : a;
        }
        pathSegment(t, e, i) {
          return _h(this)(t, this, e, i);
        }
        path(t, e, i) {
          const s = this.segments, r = _h(this);
          let o = this._loop;
          e = e || 0, i = i || this.points.length - e;
          for (const a of s) o &= r(t, this, a, {
            start: e,
            end: e + i - 1
          });
          return !!o;
        }
        draw(t, e, i, s) {
          const r = this.options || {};
          (this.points || []).length && r.borderWidth && (t.save(), a1(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = false, this._path = void 0);
        }
      }
      __publicField(ll, "id", "line");
      __publicField(ll, "defaults", {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: "default",
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
      });
      __publicField(ll, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      });
      __publicField(ll, "descriptors", {
        _scriptable: true,
        _indexable: (t) => t !== "borderDash" && t !== "fill"
      });
      function tp(n, t, e, i) {
        const s = n.options, { [e]: r } = n.getProps([
          e
        ], i);
        return Math.abs(t - r) < s.radius + s.hitRadius;
      }
      class l1 extends Ke {
        constructor(t) {
          super();
          __publicField(this, "parsed");
          __publicField(this, "skip");
          __publicField(this, "stop");
          this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
        }
        inRange(t, e, i) {
          const s = this.options, { x: r, y: o } = this.getProps([
            "x",
            "y"
          ], i);
          return Math.pow(t - r, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2);
        }
        inXRange(t, e) {
          return tp(this, t, "x", e);
        }
        inYRange(t, e) {
          return tp(this, t, "y", e);
        }
        getCenterPoint(t) {
          const { x: e, y: i } = this.getProps([
            "x",
            "y"
          ], t);
          return {
            x: e,
            y: i
          };
        }
        size(t) {
          t = t || this.options || {};
          let e = t.radius || 0;
          e = Math.max(e, e && t.hoverRadius || 0);
          const i = e && t.borderWidth || 0;
          return (e + i) * 2;
        }
        draw(t, e) {
          const i = this.options;
          this.skip || i.radius < 0.1 || !li(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, ph(t, i, this.x, this.y));
        }
        getRange() {
          const t = this.options || {};
          return t.radius + t.hitRadius;
        }
      }
      __publicField(l1, "id", "point");
      __publicField(l1, "defaults", {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
      });
      __publicField(l1, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      });
      function Ng(n, t) {
        const { x: e, y: i, base: s, width: r, height: o } = n.getProps([
          "x",
          "y",
          "base",
          "width",
          "height"
        ], t);
        let a, l, c, h, u;
        return n.horizontal ? (u = o / 2, a = Math.min(e, s), l = Math.max(e, s), c = i - u, h = i + u) : (u = r / 2, a = e - u, l = e + u, c = Math.min(i, s), h = Math.max(i, s)), {
          left: a,
          top: c,
          right: l,
          bottom: h
        };
      }
      function Si(n, t, e, i) {
        return n ? 0 : Ve(t, e, i);
      }
      function c1(n, t, e) {
        const i = n.options.borderWidth, s = n.borderSkipped, r = cg(i);
        return {
          t: Si(s.top, r.top, 0, e),
          r: Si(s.right, r.right, 0, t),
          b: Si(s.bottom, r.bottom, 0, e),
          l: Si(s.left, r.left, 0, t)
        };
      }
      function h1(n, t, e) {
        const { enableBorderRadius: i } = n.getProps([
          "enableBorderRadius"
        ]), s = n.options.borderRadius, r = Ci(s), o = Math.min(t, e), a = n.borderSkipped, l = i || Wt(s);
        return {
          topLeft: Si(!l || a.top || a.left, r.topLeft, 0, o),
          topRight: Si(!l || a.top || a.right, r.topRight, 0, o),
          bottomLeft: Si(!l || a.bottom || a.left, r.bottomLeft, 0, o),
          bottomRight: Si(!l || a.bottom || a.right, r.bottomRight, 0, o)
        };
      }
      function u1(n) {
        const t = Ng(n), e = t.right - t.left, i = t.bottom - t.top, s = c1(n, e / 2, i / 2), r = h1(n, e / 2, i / 2);
        return {
          outer: {
            x: t.left,
            y: t.top,
            w: e,
            h: i,
            radius: r
          },
          inner: {
            x: t.left + s.l,
            y: t.top + s.t,
            w: e - s.l - s.r,
            h: i - s.t - s.b,
            radius: {
              topLeft: Math.max(0, r.topLeft - Math.max(s.t, s.l)),
              topRight: Math.max(0, r.topRight - Math.max(s.t, s.r)),
              bottomLeft: Math.max(0, r.bottomLeft - Math.max(s.b, s.l)),
              bottomRight: Math.max(0, r.bottomRight - Math.max(s.b, s.r))
            }
          }
        };
      }
      function fc(n, t, e, i) {
        const s = t === null, r = e === null, a = n && !(s && r) && Ng(n, i);
        return a && (s || oi(t, a.left, a.right)) && (r || oi(e, a.top, a.bottom));
      }
      function d1(n) {
        return n.topLeft || n.topRight || n.bottomLeft || n.bottomRight;
      }
      function f1(n, t) {
        n.rect(t.x, t.y, t.w, t.h);
      }
      function pc(n, t, e = {}) {
        const i = n.x !== e.x ? -t : 0, s = n.y !== e.y ? -t : 0, r = (n.x + n.w !== e.x + e.w ? t : 0) - i, o = (n.y + n.h !== e.y + e.h ? t : 0) - s;
        return {
          x: n.x + i,
          y: n.y + s,
          w: n.w + r,
          h: n.h + o,
          radius: n.radius
        };
      }
      class p1 extends Ke {
        constructor(t) {
          super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
        }
        draw(t) {
          const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: r, outer: o } = u1(this), a = d1(o.radius) ? sr : f1;
          t.save(), (o.w !== r.w || o.h !== r.h) && (t.beginPath(), a(t, pc(o, e, r)), t.clip(), a(t, pc(r, -e, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), a(t, pc(r, e)), t.fillStyle = s, t.fill(), t.restore();
        }
        inRange(t, e, i) {
          return fc(this, t, e, i);
        }
        inXRange(t, e) {
          return fc(this, t, null, e);
        }
        inYRange(t, e) {
          return fc(this, null, t, e);
        }
        getCenterPoint(t) {
          const { x: e, y: i, base: s, horizontal: r } = this.getProps([
            "x",
            "y",
            "base",
            "horizontal"
          ], t);
          return {
            x: r ? (e + s) / 2 : e,
            y: r ? i : (i + s) / 2
          };
        }
        getRange(t) {
          return t === "x" ? this.width / 2 : this.height / 2;
        }
      }
      __publicField(p1, "id", "bar");
      __publicField(p1, "defaults", {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: void 0
      });
      __publicField(p1, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      });
      var m1 = Object.freeze({
        __proto__: null,
        ArcElement: QA,
        BarElement: p1,
        LineElement: ll,
        PointElement: l1
      });
      const xh = [
        "rgb(54, 162, 235)",
        "rgb(255, 99, 132)",
        "rgb(255, 159, 64)",
        "rgb(255, 205, 86)",
        "rgb(75, 192, 192)",
        "rgb(153, 102, 255)",
        "rgb(201, 203, 207)"
      ], ep = xh.map((n) => n.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
      function Ug(n) {
        return xh[n % xh.length];
      }
      function Bg(n) {
        return ep[n % ep.length];
      }
      function g1(n, t) {
        return n.borderColor = Ug(t), n.backgroundColor = Bg(t), ++t;
      }
      function _1(n, t) {
        return n.backgroundColor = n.data.map(() => Ug(t++)), t;
      }
      function x1(n, t) {
        return n.backgroundColor = n.data.map(() => Bg(t++)), t;
      }
      function b1(n) {
        let t = 0;
        return (e, i) => {
          const s = n.getDatasetMeta(i).controller;
          s instanceof ol ? t = _1(e, t) : s instanceof wg ? t = x1(e, t) : s && (t = g1(e, t));
        };
      }
      function np(n) {
        let t;
        for (t in n) if (n[t].borderColor || n[t].backgroundColor) return true;
        return false;
      }
      function y1(n) {
        return n && (n.borderColor || n.backgroundColor);
      }
      function v1() {
        return be.borderColor !== "rgba(0,0,0,0.1)" || be.backgroundColor !== "rgba(0,0,0,0.1)";
      }
      var M1 = {
        id: "colors",
        defaults: {
          enabled: true,
          forceOverride: false
        },
        beforeLayout(n, t, e) {
          if (!e.enabled) return;
          const { data: { datasets: i }, options: s } = n.config, { elements: r } = s, o = np(i) || y1(s) || r && np(r) || v1();
          if (!e.forceOverride && o) return;
          const a = b1(n);
          i.forEach(a);
        }
      };
      function S1(n, t, e, i, s) {
        const r = s.samples || i;
        if (r >= e) return n.slice(t, t + e);
        const o = [], a = (e - 2) / (r - 2);
        let l = 0;
        const c = t + e - 1;
        let h = t, u, d, f, g, _;
        for (o[l++] = n[h], u = 0; u < r - 2; u++) {
          let m = 0, p = 0, y;
          const w = Math.floor((u + 1) * a) + 1 + t, M = Math.min(Math.floor((u + 2) * a) + 1, e) + t, C = M - w;
          for (y = w; y < M; y++) m += n[y].x, p += n[y].y;
          m /= C, p /= C;
          const R = Math.floor(u * a) + 1 + t, T = Math.min(Math.floor((u + 1) * a) + 1, e) + t, { x: v, y: x } = n[h];
          for (f = g = -1, y = R; y < T; y++) g = 0.5 * Math.abs((v - m) * (n[y].y - x) - (v - n[y].x) * (p - x)), g > f && (f = g, d = n[y], _ = y);
          o[l++] = d, h = _;
        }
        return o[l++] = n[c], o;
      }
      function w1(n, t, e, i) {
        let s = 0, r = 0, o, a, l, c, h, u, d, f, g, _;
        const m = [], p = t + e - 1, y = n[t].x, M = n[p].x - y;
        for (o = t; o < t + e; ++o) {
          a = n[o], l = (a.x - y) / M * i, c = a.y;
          const C = l | 0;
          if (C === h) c < g ? (g = c, u = o) : c > _ && (_ = c, d = o), s = (r * s + a.x) / ++r;
          else {
            const R = o - 1;
            if (!Kt(u) && !Kt(d)) {
              const T = Math.min(u, d), v = Math.max(u, d);
              T !== f && T !== R && m.push({
                ...n[T],
                x: s
              }), v !== f && v !== R && m.push({
                ...n[v],
                x: s
              });
            }
            o > 0 && R !== f && m.push(n[R]), m.push(a), h = C, r = 0, g = _ = c, u = d = f = o;
          }
        }
        return m;
      }
      function zg(n) {
        if (n._decimated) {
          const t = n._data;
          delete n._decimated, delete n._data, Object.defineProperty(n, "data", {
            configurable: true,
            enumerable: true,
            writable: true,
            value: t
          });
        }
      }
      function ip(n) {
        n.data.datasets.forEach((t) => {
          zg(t);
        });
      }
      function E1(n, t) {
        const e = t.length;
        let i = 0, s;
        const { iScale: r } = n, { min: o, max: a, minDefined: l, maxDefined: c } = r.getUserBounds();
        return l && (i = Ve(ai(t, r.axis, o).lo, 0, e - 1)), c ? s = Ve(ai(t, r.axis, a).hi + 1, i, e) - i : s = e - i, {
          start: i,
          count: s
        };
      }
      var T1 = {
        id: "decimation",
        defaults: {
          algorithm: "min-max",
          enabled: false
        },
        beforeElementsUpdate: (n, t, e) => {
          if (!e.enabled) {
            ip(n);
            return;
          }
          const i = n.width;
          n.data.datasets.forEach((s, r) => {
            const { _data: o, indexAxis: a } = s, l = n.getDatasetMeta(r), c = o || s.data;
            if (Nr([
              a,
              n.options.indexAxis
            ]) === "y" || !l.controller.supportsDecimation) return;
            const h = n.scales[l.xAxisID];
            if (h.type !== "linear" && h.type !== "time" || n.options.parsing) return;
            let { start: u, count: d } = E1(l, c);
            const f = e.threshold || 4 * i;
            if (d <= f) {
              zg(s);
              return;
            }
            Kt(o) && (s._data = c, delete s.data, Object.defineProperty(s, "data", {
              configurable: true,
              enumerable: true,
              get: function() {
                return this._decimated;
              },
              set: function(_) {
                this._data = _;
              }
            }));
            let g;
            switch (e.algorithm) {
              case "lttb":
                g = S1(c, u, d, i, e);
                break;
              case "min-max":
                g = w1(c, u, d, i);
                break;
              default:
                throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`);
            }
            s._decimated = g;
          });
        },
        destroy(n) {
          ip(n);
        }
      };
      function A1(n, t, e) {
        const i = n.segments, s = n.points, r = t.points, o = [];
        for (const a of i) {
          let { start: l, end: c } = a;
          c = pu(l, c, s);
          const h = bh(e, s[l], s[c], a.loop);
          if (!t.segments) {
            o.push({
              source: a,
              target: h,
              start: s[l],
              end: s[c]
            });
            continue;
          }
          const u = yg(t, h);
          for (const d of u) {
            const f = bh(e, r[d.start], r[d.end], d.loop), g = bg(a, s, f);
            for (const _ of g) o.push({
              source: _,
              target: d,
              start: {
                [e]: sp(h, f, "start", Math.max)
              },
              end: {
                [e]: sp(h, f, "end", Math.min)
              }
            });
          }
        }
        return o;
      }
      function bh(n, t, e, i) {
        if (i) return;
        let s = t[n], r = e[n];
        return n === "angle" && (s = pn(s), r = pn(r)), {
          property: n,
          start: s,
          end: r
        };
      }
      function C1(n, t) {
        const { x: e = null, y: i = null } = n || {}, s = t.points, r = [];
        return t.segments.forEach(({ start: o, end: a }) => {
          a = pu(o, a, s);
          const l = s[o], c = s[a];
          i !== null ? (r.push({
            x: l.x,
            y: i
          }), r.push({
            x: c.x,
            y: i
          })) : e !== null && (r.push({
            x: e,
            y: l.y
          }), r.push({
            x: e,
            y: c.y
          }));
        }), r;
      }
      function pu(n, t, e) {
        for (; t > n; t--) {
          const i = e[t];
          if (!isNaN(i.x) && !isNaN(i.y)) break;
        }
        return t;
      }
      function sp(n, t, e, i) {
        return n && t ? i(n[e], t[e]) : n ? n[e] : t ? t[e] : 0;
      }
      function Hg(n, t) {
        let e = [], i = false;
        return oe(n) ? (i = true, e = n) : e = C1(n, t), e.length ? new ll({
          points: e,
          options: {
            tension: 0
          },
          _loop: i,
          _fullLoop: i
        }) : null;
      }
      function rp(n) {
        return n && n.fill !== false;
      }
      function R1(n, t, e) {
        let s = n[t].fill;
        const r = [
          t
        ];
        let o;
        if (!e) return s;
        for (; s !== false && r.indexOf(s) === -1; ) {
          if (!Me(s)) return s;
          if (o = n[s], !o) return false;
          if (o.visible) return s;
          r.push(s), s = o.fill;
        }
        return false;
      }
      function P1(n, t, e) {
        const i = O1(n);
        if (Wt(i)) return isNaN(i.value) ? false : i;
        let s = parseFloat(i);
        return Me(s) && Math.floor(s) === s ? D1(i[0], t, s, e) : [
          "origin",
          "start",
          "end",
          "stack",
          "shape"
        ].indexOf(i) >= 0 && i;
      }
      function D1(n, t, e, i) {
        return (n === "-" || n === "+") && (e = t + e), e === t || e < 0 || e >= i ? false : e;
      }
      function L1(n, t) {
        let e = null;
        return n === "start" ? e = t.bottom : n === "end" ? e = t.top : Wt(n) ? e = t.getPixelForValue(n.value) : t.getBasePixel && (e = t.getBasePixel()), e;
      }
      function I1(n, t, e) {
        let i;
        return n === "start" ? i = e : n === "end" ? i = t.options.reverse ? t.min : t.max : Wt(n) ? i = n.value : i = t.getBaseValue(), i;
      }
      function O1(n) {
        const t = n.options, e = t.fill;
        let i = Ut(e && e.target, e);
        return i === void 0 && (i = !!t.backgroundColor), i === false || i === null ? false : i === true ? "origin" : i;
      }
      function k1(n) {
        const { scale: t, index: e, line: i } = n, s = [], r = i.segments, o = i.points, a = F1(t, e);
        a.push(Hg({
          x: null,
          y: t.bottom
        }, i));
        for (let l = 0; l < r.length; l++) {
          const c = r[l];
          for (let h = c.start; h <= c.end; h++) N1(s, o[h], a);
        }
        return new ll({
          points: s,
          options: {}
        });
      }
      function F1(n, t) {
        const e = [], i = n.getMatchingVisibleMetas("line");
        for (let s = 0; s < i.length; s++) {
          const r = i[s];
          if (r.index === t) break;
          r.hidden || e.unshift(r.dataset);
        }
        return e;
      }
      function N1(n, t, e) {
        const i = [];
        for (let s = 0; s < e.length; s++) {
          const r = e[s], { first: o, last: a, point: l } = U1(r, t, "x");
          if (!(!l || o && a)) {
            if (o) i.unshift(l);
            else if (n.push(l), !a) break;
          }
        }
        n.push(...i);
      }
      function U1(n, t, e) {
        const i = n.interpolate(t, e);
        if (!i) return {};
        const s = i[e], r = n.segments, o = n.points;
        let a = false, l = false;
        for (let c = 0; c < r.length; c++) {
          const h = r[c], u = o[h.start][e], d = o[h.end][e];
          if (oi(s, u, d)) {
            a = s === u, l = s === d;
            break;
          }
        }
        return {
          first: a,
          last: l,
          point: i
        };
      }
      class Vg {
        constructor(t) {
          this.x = t.x, this.y = t.y, this.radius = t.radius;
        }
        pathSegment(t, e, i) {
          const { x: s, y: r, radius: o } = this;
          return e = e || {
            start: 0,
            end: ge
          }, t.arc(s, r, o, e.end, e.start, true), !i.bounds;
        }
        interpolate(t) {
          const { x: e, y: i, radius: s } = this, r = t.angle;
          return {
            x: e + Math.cos(r) * s,
            y: i + Math.sin(r) * s,
            angle: r
          };
        }
      }
      function B1(n) {
        const { chart: t, fill: e, line: i } = n;
        if (Me(e)) return z1(t, e);
        if (e === "stack") return k1(n);
        if (e === "shape") return true;
        const s = H1(n);
        return s instanceof Vg ? s : Hg(s, i);
      }
      function z1(n, t) {
        const e = n.getDatasetMeta(t);
        return e && n.isDatasetVisible(t) ? e.dataset : null;
      }
      function H1(n) {
        return (n.scale || {}).getPointPositionForValue ? W1(n) : V1(n);
      }
      function V1(n) {
        const { scale: t = {}, fill: e } = n, i = L1(e, t);
        if (Me(i)) {
          const s = t.isHorizontal();
          return {
            x: s ? i : null,
            y: s ? null : i
          };
        }
        return null;
      }
      function W1(n) {
        const { scale: t, fill: e } = n, i = t.options, s = t.getLabels().length, r = i.reverse ? t.max : t.min, o = I1(e, t, r), a = [];
        if (i.grid.circular) {
          const l = t.getPointPositionForValue(0, r);
          return new Vg({
            x: l.x,
            y: l.y,
            radius: t.getDistanceFromCenterForValue(o)
          });
        }
        for (let l = 0; l < s; ++l) a.push(t.getPointPositionForValue(l, o));
        return a;
      }
      function mc(n, t, e) {
        const i = B1(t), { chart: s, index: r, line: o, scale: a, axis: l } = t, c = o.options, h = c.fill, u = c.backgroundColor, { above: d = u, below: f = u } = h || {}, g = s.getDatasetMeta(r), _ = vg(s, g);
        i && o.points.length && (uo(n, e), G1(n, {
          line: o,
          target: i,
          above: d,
          below: f,
          area: e,
          scale: a,
          axis: l,
          clip: _
        }), fo(n));
      }
      function G1(n, t) {
        const { line: e, target: i, above: s, below: r, area: o, scale: a, clip: l } = t, c = e._loop ? "angle" : t.axis;
        n.save(), c === "x" && r !== s && (op(n, i, o.top), ap(n, {
          line: e,
          target: i,
          color: s,
          scale: a,
          property: c,
          clip: l
        }), n.restore(), n.save(), op(n, i, o.bottom)), ap(n, {
          line: e,
          target: i,
          color: r,
          scale: a,
          property: c,
          clip: l
        }), n.restore();
      }
      function op(n, t, e) {
        const { segments: i, points: s } = t;
        let r = true, o = false;
        n.beginPath();
        for (const a of i) {
          const { start: l, end: c } = a, h = s[l], u = s[pu(l, c, s)];
          r ? (n.moveTo(h.x, h.y), r = false) : (n.lineTo(h.x, e), n.lineTo(h.x, h.y)), o = !!t.pathSegment(n, a, {
            move: o
          }), o ? n.closePath() : n.lineTo(u.x, e);
        }
        n.lineTo(t.first().x, e), n.closePath(), n.clip();
      }
      function ap(n, t) {
        const { line: e, target: i, property: s, color: r, scale: o, clip: a } = t, l = A1(e, i, s);
        for (const { source: c, target: h, start: u, end: d } of l) {
          const { style: { backgroundColor: f = r } = {} } = c, g = i !== true;
          n.save(), n.fillStyle = f, X1(n, o, a, g && bh(s, u, d)), n.beginPath();
          const _ = !!e.pathSegment(n, c);
          let m;
          if (g) {
            _ ? n.closePath() : lp(n, i, d, s);
            const p = !!i.pathSegment(n, h, {
              move: _,
              reverse: true
            });
            m = _ && p, m || lp(n, i, u, s);
          }
          n.closePath(), n.fill(m ? "evenodd" : "nonzero"), n.restore();
        }
      }
      function X1(n, t, e, i) {
        const s = t.chart.chartArea, { property: r, start: o, end: a } = i || {};
        if (r === "x" || r === "y") {
          let l, c, h, u;
          r === "x" ? (l = o, c = s.top, h = a, u = s.bottom) : (l = s.left, c = o, h = s.right, u = a), n.beginPath(), e && (l = Math.max(l, e.left), h = Math.min(h, e.right), c = Math.max(c, e.top), u = Math.min(u, e.bottom)), n.rect(l, c, h - l, u - c), n.clip();
        }
      }
      function lp(n, t, e, i) {
        const s = t.interpolate(e, i);
        s && n.lineTo(s.x, s.y);
      }
      var Y1 = {
        id: "filler",
        afterDatasetsUpdate(n, t, e) {
          const i = (n.data.datasets || []).length, s = [];
          let r, o, a, l;
          for (o = 0; o < i; ++o) r = n.getDatasetMeta(o), a = r.dataset, l = null, a && a.options && a instanceof ll && (l = {
            visible: n.isDatasetVisible(o),
            index: o,
            fill: P1(a, o, i),
            chart: n,
            axis: r.controller.options.indexAxis,
            scale: r.vScale,
            line: a
          }), r.$filler = l, s.push(l);
          for (o = 0; o < i; ++o) l = s[o], !(!l || l.fill === false) && (l.fill = R1(s, o, e.propagate));
        },
        beforeDraw(n, t, e) {
          const i = e.drawTime === "beforeDraw", s = n.getSortedVisibleDatasetMetas(), r = n.chartArea;
          for (let o = s.length - 1; o >= 0; --o) {
            const a = s[o].$filler;
            a && (a.line.updateControlPoints(r, a.axis), i && a.fill && mc(n.ctx, a, r));
          }
        },
        beforeDatasetsDraw(n, t, e) {
          if (e.drawTime !== "beforeDatasetsDraw") return;
          const i = n.getSortedVisibleDatasetMetas();
          for (let s = i.length - 1; s >= 0; --s) {
            const r = i[s].$filler;
            rp(r) && mc(n.ctx, r, n.chartArea);
          }
        },
        beforeDatasetDraw(n, t, e) {
          const i = t.meta.$filler;
          !rp(i) || e.drawTime !== "beforeDatasetDraw" || mc(n.ctx, i, n.chartArea);
        },
        defaults: {
          propagate: true,
          drawTime: "beforeDatasetDraw"
        }
      };
      const cp = (n, t) => {
        let { boxHeight: e = t, boxWidth: i = t } = n;
        return n.usePointStyle && (e = Math.min(e, t), i = n.pointStyleWidth || Math.min(i, t)), {
          boxWidth: i,
          boxHeight: e,
          itemHeight: Math.max(t, e)
        };
      }, j1 = (n, t) => n !== null && t !== null && n.datasetIndex === t.datasetIndex && n.index === t.index;
      class hp extends Ke {
        constructor(t) {
          super(), this._added = false, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
        }
        update(t, e, i) {
          this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();
        }
        setDimensions() {
          this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
        }
        buildLabels() {
          const t = this.options.labels || {};
          let e = ce(t.generateLabels, [
            this.chart
          ], this) || [];
          t.filter && (e = e.filter((i) => t.filter(i, this.chart.data))), t.sort && (e = e.sort((i, s) => t.sort(i, s, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;
        }
        fit() {
          const { options: t, ctx: e } = this;
          if (!t.display) {
            this.width = this.height = 0;
            return;
          }
          const i = t.labels, s = Te(i.font), r = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = cp(i, r);
          let c, h;
          e.font = s.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(o, r, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(o, s, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);
        }
        _fitRows(t, e, i, s) {
          const { ctx: r, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
            0
          ], h = s + a;
          let u = t;
          r.textAlign = "left", r.textBaseline = "middle";
          let d = -1, f = -h;
          return this.legendItems.forEach((g, _) => {
            const m = i + e / 2 + r.measureText(g.text).width;
            (_ === 0 || c[c.length - 1] + m + 2 * a > o) && (u += h, c[c.length - (_ > 0 ? 0 : 1)] = 0, f += h, d++), l[_] = {
              left: 0,
              top: f,
              row: d,
              width: m,
              height: s
            }, c[c.length - 1] += m + a;
          }), u;
        }
        _fitCols(t, e, i, s) {
          const { ctx: r, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], h = o - t;
          let u = a, d = 0, f = 0, g = 0, _ = 0;
          return this.legendItems.forEach((m, p) => {
            const { itemWidth: y, itemHeight: w } = q1(i, e, r, m, s);
            p > 0 && f + w + 2 * a > h && (u += d + a, c.push({
              width: d,
              height: f
            }), g += d + a, _++, d = f = 0), l[p] = {
              left: g,
              top: f,
              col: _,
              width: y,
              height: w
            }, d = Math.max(d, y), f += w + a;
          }), u += d, c.push({
            width: d,
            height: f
          }), u;
        }
        adjustHitBoxes() {
          if (!this.options.display) return;
          const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: r } } = this, o = $s(r, this.left, this.width);
          if (this.isHorizontal()) {
            let a = 0, l = je(i, this.left + s, this.right - this.lineWidths[a]);
            for (const c of e) a !== c.row && (a = c.row, l = je(i, this.left + s, this.right - this.lineWidths[a])), c.top += this.top + t + s, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + s;
          } else {
            let a = 0, l = je(i, this.top + t + s, this.bottom - this.columnSizes[a].height);
            for (const c of e) c.col !== a && (a = c.col, l = je(i, this.top + t + s, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + s, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + s;
          }
        }
        isHorizontal() {
          return this.options.position === "top" || this.options.position === "bottom";
        }
        draw() {
          if (this.options.display) {
            const t = this.ctx;
            uo(t, this), this._draw(), fo(t);
          }
        }
        _draw() {
          const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: r, labels: o } = t, a = be.color, l = $s(t.rtl, this.left, this.width), c = Te(o.font), { padding: h } = o, u = c.size, d = u / 2;
          let f;
          this.drawTitle(), s.textAlign = l.textAlign("left"), s.textBaseline = "middle", s.lineWidth = 0.5, s.font = c.string;
          const { boxWidth: g, boxHeight: _, itemHeight: m } = cp(o, u), p = function(R, T, v) {
            if (isNaN(g) || g <= 0 || isNaN(_) || _ < 0) return;
            s.save();
            const x = Ut(v.lineWidth, 1);
            if (s.fillStyle = Ut(v.fillStyle, a), s.lineCap = Ut(v.lineCap, "butt"), s.lineDashOffset = Ut(v.lineDashOffset, 0), s.lineJoin = Ut(v.lineJoin, "miter"), s.lineWidth = x, s.strokeStyle = Ut(v.strokeStyle, a), s.setLineDash(Ut(v.lineDash, [])), o.usePointStyle) {
              const b = {
                radius: _ * Math.SQRT2 / 2,
                pointStyle: v.pointStyle,
                rotation: v.rotation,
                borderWidth: x
              }, A = l.xPlus(R, g / 2), L = T + d;
              lg(s, b, A, L, o.pointStyleWidth && g);
            } else {
              const b = T + Math.max((u - _) / 2, 0), A = l.leftForLtr(R, g), L = Ci(v.borderRadius);
              s.beginPath(), Object.values(L).some((I) => I !== 0) ? sr(s, {
                x: A,
                y: b,
                w: g,
                h: _,
                radius: L
              }) : s.rect(A, b, g, _), s.fill(), x !== 0 && s.stroke();
            }
            s.restore();
          }, y = function(R, T, v) {
            us(s, v.text, R, T + m / 2, c, {
              strikethrough: v.hidden,
              textAlign: l.textAlign(v.textAlign)
            });
          }, w = this.isHorizontal(), M = this._computeTitleHeight();
          w ? f = {
            x: je(r, this.left + h, this.right - i[0]),
            y: this.top + h + M,
            line: 0
          } : f = {
            x: this.left + h,
            y: je(r, this.top + M + h, this.bottom - e[0].height),
            line: 0
          }, gg(this.ctx, t.textDirection);
          const C = m + h;
          this.legendItems.forEach((R, T) => {
            s.strokeStyle = R.fontColor, s.fillStyle = R.fontColor;
            const v = s.measureText(R.text).width, x = l.textAlign(R.textAlign || (R.textAlign = o.textAlign)), b = g + d + v;
            let A = f.x, L = f.y;
            l.setWidth(this.width), w ? T > 0 && A + b + h > this.right && (L = f.y += C, f.line++, A = f.x = je(r, this.left + h, this.right - i[f.line])) : T > 0 && L + C > this.bottom && (A = f.x = A + e[f.line].width + h, f.line++, L = f.y = je(r, this.top + M + h, this.bottom - e[f.line].height));
            const I = l.x(A);
            if (p(I, L, R), A = oE(x, A + g + d, w ? A + b : this.right, t.rtl), y(l.x(A), L, R), w) f.x += b + h;
            else if (typeof R.text != "string") {
              const H = c.lineHeight;
              f.y += Wg(R, H) + h;
            } else f.y += C;
          }), _g(this.ctx, t.textDirection);
        }
        drawTitle() {
          const t = this.options, e = t.title, i = Te(e.font), s = Fe(e.padding);
          if (!e.display) return;
          const r = $s(t.rtl, this.left, this.width), o = this.ctx, a = e.position, l = i.size / 2, c = s.top + l;
          let h, u = this.left, d = this.width;
          if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + c, u = je(t.align, u, this.right - d);
          else {
            const g = this.columnSizes.reduce((_, m) => Math.max(_, m.height), 0);
            h = c + je(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());
          }
          const f = je(a, u, u + d);
          o.textAlign = r.textAlign(su(a)), o.textBaseline = "middle", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, us(o, e.text, f, h, i);
        }
        _computeTitleHeight() {
          const t = this.options.title, e = Te(t.font), i = Fe(t.padding);
          return t.display ? e.lineHeight + i.height : 0;
        }
        _getLegendItemAt(t, e) {
          let i, s, r;
          if (oi(t, this.left, this.right) && oi(e, this.top, this.bottom)) {
            for (r = this.legendHitBoxes, i = 0; i < r.length; ++i) if (s = r[i], oi(t, s.left, s.left + s.width) && oi(e, s.top, s.top + s.height)) return this.legendItems[i];
          }
          return null;
        }
        handleEvent(t) {
          const e = this.options;
          if (!Z1(t.type, e)) return;
          const i = this._getLegendItemAt(t.x, t.y);
          if (t.type === "mousemove" || t.type === "mouseout") {
            const s = this._hoveredItem, r = j1(s, i);
            s && !r && ce(e.onLeave, [
              t,
              s,
              this
            ], this), this._hoveredItem = i, i && !r && ce(e.onHover, [
              t,
              i,
              this
            ], this);
          } else i && ce(e.onClick, [
            t,
            i,
            this
          ], this);
        }
      }
      function q1(n, t, e, i, s) {
        const r = $1(i, n, t, e), o = K1(s, i, t.lineHeight);
        return {
          itemWidth: r,
          itemHeight: o
        };
      }
      function $1(n, t, e, i) {
        let s = n.text;
        return s && typeof s != "string" && (s = s.reduce((r, o) => r.length > o.length ? r : o)), t + e.size / 2 + i.measureText(s).width;
      }
      function K1(n, t, e) {
        let i = n;
        return typeof t.text != "string" && (i = Wg(t, e)), i;
      }
      function Wg(n, t) {
        const e = n.text ? n.text.length : 0;
        return t * e;
      }
      function Z1(n, t) {
        return !!((n === "mousemove" || n === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (n === "click" || n === "mouseup"));
      }
      var Q1 = {
        id: "legend",
        _element: hp,
        start(n, t, e) {
          const i = n.legend = new hp({
            ctx: n.ctx,
            options: e,
            chart: n
          });
          qe.configure(n, i, e), qe.addBox(n, i);
        },
        stop(n) {
          qe.removeBox(n, n.legend), delete n.legend;
        },
        beforeUpdate(n, t, e) {
          const i = n.legend;
          qe.configure(n, i, e), i.options = e;
        },
        afterUpdate(n) {
          const t = n.legend;
          t.buildLabels(), t.adjustHitBoxes();
        },
        afterEvent(n, t) {
          t.replay || n.legend.handleEvent(t.event);
        },
        defaults: {
          display: true,
          position: "top",
          align: "center",
          fullSize: true,
          reverse: false,
          weight: 1e3,
          onClick(n, t, e) {
            const i = t.datasetIndex, s = e.chart;
            s.isDatasetVisible(i) ? (s.hide(i), t.hidden = true) : (s.show(i), t.hidden = false);
          },
          onHover: null,
          onLeave: null,
          labels: {
            color: (n) => n.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(n) {
              const t = n.data.datasets, { labels: { usePointStyle: e, pointStyle: i, textAlign: s, color: r, useBorderRadius: o, borderRadius: a } } = n.legend.options;
              return n._getSortedDatasetMetas().map((l) => {
                const c = l.controller.getStyle(e ? 0 : void 0), h = Fe(c.borderWidth);
                return {
                  text: t[l.index].label,
                  fillStyle: c.backgroundColor,
                  fontColor: r,
                  hidden: !l.visible,
                  lineCap: c.borderCapStyle,
                  lineDash: c.borderDash,
                  lineDashOffset: c.borderDashOffset,
                  lineJoin: c.borderJoinStyle,
                  lineWidth: (h.width + h.height) / 4,
                  strokeStyle: c.borderColor,
                  pointStyle: i || c.pointStyle,
                  rotation: c.rotation,
                  textAlign: s || c.textAlign,
                  borderRadius: o && (a || c.borderRadius),
                  datasetIndex: l.index
                };
              }, this);
            }
          },
          title: {
            color: (n) => n.chart.options.color,
            display: false,
            position: "center",
            text: ""
          }
        },
        descriptors: {
          _scriptable: (n) => !n.startsWith("on"),
          labels: {
            _scriptable: (n) => ![
              "generateLabels",
              "filter",
              "sort"
            ].includes(n)
          }
        }
      };
      class mu extends Ke {
        constructor(t) {
          super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
        }
        update(t, e) {
          const i = this.options;
          if (this.left = 0, this.top = 0, !i.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
          }
          this.width = this.right = t, this.height = this.bottom = e;
          const s = oe(i.text) ? i.text.length : 1;
          this._padding = Fe(i.padding);
          const r = s * Te(i.font).lineHeight + this._padding.height;
          this.isHorizontal() ? this.height = r : this.width = r;
        }
        isHorizontal() {
          const t = this.options.position;
          return t === "top" || t === "bottom";
        }
        _drawArgs(t) {
          const { top: e, left: i, bottom: s, right: r, options: o } = this, a = o.align;
          let l = 0, c, h, u;
          return this.isHorizontal() ? (h = je(a, i, r), u = e + t, c = r - i) : (o.position === "left" ? (h = i + t, u = je(a, s, e), l = Zt * -0.5) : (h = r - t, u = je(a, e, s), l = Zt * 0.5), c = s - e), {
            titleX: h,
            titleY: u,
            maxWidth: c,
            rotation: l
          };
        }
        draw() {
          const t = this.ctx, e = this.options;
          if (!e.display) return;
          const i = Te(e.font), r = i.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(r);
          us(t, e.text, 0, 0, i, {
            color: e.color,
            maxWidth: l,
            rotation: c,
            textAlign: su(e.align),
            textBaseline: "middle",
            translation: [
              o,
              a
            ]
          });
        }
      }
      function J1(n, t) {
        const e = new mu({
          ctx: n.ctx,
          options: t,
          chart: n
        });
        qe.configure(n, e, t), qe.addBox(n, e), n.titleBlock = e;
      }
      var tC = {
        id: "title",
        _element: mu,
        start(n, t, e) {
          J1(n, e);
        },
        stop(n) {
          const t = n.titleBlock;
          qe.removeBox(n, t), delete n.titleBlock;
        },
        beforeUpdate(n, t, e) {
          const i = n.titleBlock;
          qe.configure(n, i, e), i.options = e;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "bold"
          },
          fullSize: true,
          padding: 10,
          position: "top",
          text: "",
          weight: 2e3
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      const ua = /* @__PURE__ */ new WeakMap();
      var eC = {
        id: "subtitle",
        start(n, t, e) {
          const i = new mu({
            ctx: n.ctx,
            options: e,
            chart: n
          });
          qe.configure(n, i, e), qe.addBox(n, i), ua.set(n, i);
        },
        stop(n) {
          qe.removeBox(n, ua.get(n)), ua.delete(n);
        },
        beforeUpdate(n, t, e) {
          const i = ua.get(n);
          qe.configure(n, i, e), i.options = e;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "normal"
          },
          fullSize: true,
          padding: 0,
          position: "top",
          text: "",
          weight: 1500
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      const Br = {
        average(n) {
          if (!n.length) return false;
          let t, e, i = /* @__PURE__ */ new Set(), s = 0, r = 0;
          for (t = 0, e = n.length; t < e; ++t) {
            const a = n[t].element;
            if (a && a.hasValue()) {
              const l = a.tooltipPosition();
              i.add(l.x), s += l.y, ++r;
            }
          }
          return r === 0 || i.size === 0 ? false : {
            x: [
              ...i
            ].reduce((a, l) => a + l) / i.size,
            y: s / r
          };
        },
        nearest(n, t) {
          if (!n.length) return false;
          let e = t.x, i = t.y, s = Number.POSITIVE_INFINITY, r, o, a;
          for (r = 0, o = n.length; r < o; ++r) {
            const l = n[r].element;
            if (l && l.hasValue()) {
              const c = l.getCenterPoint(), h = ir(t, c);
              h < s && (s = h, a = l);
            }
          }
          if (a) {
            const l = a.tooltipPosition();
            e = l.x, i = l.y;
          }
          return {
            x: e,
            y: i
          };
        }
      };
      function On(n, t) {
        return t && (oe(t) ? Array.prototype.push.apply(n, t) : n.push(t)), n;
      }
      function ei(n) {
        return (typeof n == "string" || n instanceof String) && n.indexOf(`
`) > -1 ? n.split(`
`) : n;
      }
      function nC(n, t) {
        const { element: e, datasetIndex: i, index: s } = t, r = n.getDatasetMeta(i).controller, { label: o, value: a } = r.getLabelAndValue(s);
        return {
          chart: n,
          label: o,
          parsed: r.getParsed(s),
          raw: n.data.datasets[i].data[s],
          formattedValue: a,
          dataset: r.getDataset(),
          dataIndex: s,
          datasetIndex: i,
          element: e
        };
      }
      function up(n, t) {
        const e = n.chart.ctx, { body: i, footer: s, title: r } = n, { boxWidth: o, boxHeight: a } = t, l = Te(t.bodyFont), c = Te(t.titleFont), h = Te(t.footerFont), u = r.length, d = s.length, f = i.length, g = Fe(t.padding);
        let _ = g.height, m = 0, p = i.reduce((M, C) => M + C.before.length + C.lines.length + C.after.length, 0);
        if (p += n.beforeBody.length + n.afterBody.length, u && (_ += u * c.lineHeight + (u - 1) * t.titleSpacing + t.titleMarginBottom), p) {
          const M = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
          _ += f * M + (p - f) * l.lineHeight + (p - 1) * t.bodySpacing;
        }
        d && (_ += t.footerMarginTop + d * h.lineHeight + (d - 1) * t.footerSpacing);
        let y = 0;
        const w = function(M) {
          m = Math.max(m, e.measureText(M).width + y);
        };
        return e.save(), e.font = c.string, he(n.title, w), e.font = l.string, he(n.beforeBody.concat(n.afterBody), w), y = t.displayColors ? o + 2 + t.boxPadding : 0, he(i, (M) => {
          he(M.before, w), he(M.lines, w), he(M.after, w);
        }), y = 0, e.font = h.string, he(n.footer, w), e.restore(), m += g.width, {
          width: m,
          height: _
        };
      }
      function iC(n, t) {
        const { y: e, height: i } = t;
        return e < i / 2 ? "top" : e > n.height - i / 2 ? "bottom" : "center";
      }
      function sC(n, t, e, i) {
        const { x: s, width: r } = i, o = e.caretSize + e.caretPadding;
        if (n === "left" && s + r + o > t.width || n === "right" && s - r - o < 0) return true;
      }
      function rC(n, t, e, i) {
        const { x: s, width: r } = e, { width: o, chartArea: { left: a, right: l } } = n;
        let c = "center";
        return i === "center" ? c = s <= (a + l) / 2 ? "left" : "right" : s <= r / 2 ? c = "left" : s >= o - r / 2 && (c = "right"), sC(c, n, t, e) && (c = "center"), c;
      }
      function dp(n, t, e) {
        const i = e.yAlign || t.yAlign || iC(n, e);
        return {
          xAlign: e.xAlign || t.xAlign || rC(n, t, e, i),
          yAlign: i
        };
      }
      function oC(n, t) {
        let { x: e, width: i } = n;
        return t === "right" ? e -= i : t === "center" && (e -= i / 2), e;
      }
      function aC(n, t, e) {
        let { y: i, height: s } = n;
        return t === "top" ? i += e : t === "bottom" ? i -= s + e : i -= s / 2, i;
      }
      function fp(n, t, e, i) {
        const { caretSize: s, caretPadding: r, cornerRadius: o } = n, { xAlign: a, yAlign: l } = e, c = s + r, { topLeft: h, topRight: u, bottomLeft: d, bottomRight: f } = Ci(o);
        let g = oC(t, a);
        const _ = aC(t, l, c);
        return l === "center" ? a === "left" ? g += c : a === "right" && (g -= c) : a === "left" ? g -= Math.max(h, d) + s : a === "right" && (g += Math.max(u, f) + s), {
          x: Ve(g, 0, i.width - t.width),
          y: Ve(_, 0, i.height - t.height)
        };
      }
      function da(n, t, e) {
        const i = Fe(e.padding);
        return t === "center" ? n.x + n.width / 2 : t === "right" ? n.x + n.width - i.right : n.x + i.left;
      }
      function pp(n) {
        return On([], ei(n));
      }
      function lC(n, t, e) {
        return Fi(n, {
          tooltip: t,
          tooltipItems: e,
          type: "tooltip"
        });
      }
      function mp(n, t) {
        const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
        return e ? n.override(e) : n;
      }
      const Gg = {
        beforeTitle: Qn,
        title(n) {
          if (n.length > 0) {
            const t = n[0], e = t.chart.data.labels, i = e ? e.length : 0;
            if (this && this.options && this.options.mode === "dataset") return t.dataset.label || "";
            if (t.label) return t.label;
            if (i > 0 && t.dataIndex < i) return e[t.dataIndex];
          }
          return "";
        },
        afterTitle: Qn,
        beforeBody: Qn,
        beforeLabel: Qn,
        label(n) {
          if (this && this.options && this.options.mode === "dataset") return n.label + ": " + n.formattedValue || n.formattedValue;
          let t = n.dataset.label || "";
          t && (t += ": ");
          const e = n.formattedValue;
          return Kt(e) || (t += e), t;
        },
        labelColor(n) {
          const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
          return {
            borderColor: e.borderColor,
            backgroundColor: e.backgroundColor,
            borderWidth: e.borderWidth,
            borderDash: e.borderDash,
            borderDashOffset: e.borderDashOffset,
            borderRadius: 0
          };
        },
        labelTextColor() {
          return this.options.bodyColor;
        },
        labelPointStyle(n) {
          const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
          return {
            pointStyle: e.pointStyle,
            rotation: e.rotation
          };
        },
        afterLabel: Qn,
        afterBody: Qn,
        beforeFooter: Qn,
        footer: Qn,
        afterFooter: Qn
      };
      function rn(n, t, e, i) {
        const s = n[t].call(e, i);
        return typeof s > "u" ? Gg[t].call(e, i) : s;
      }
      class gp extends Ke {
        constructor(t) {
          super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
        }
        initialize(t) {
          this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
        }
        _resolveAnimations() {
          const t = this._cachedAnimations;
          if (t) return t;
          const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, r = new du(this.chart, s);
          return s._cacheable && (this._cachedAnimations = Object.freeze(r)), r;
        }
        getContext() {
          return this.$context || (this.$context = lC(this.chart.getContext(), this, this._tooltipItems));
        }
        getTitle(t, e) {
          const { callbacks: i } = e, s = rn(i, "beforeTitle", this, t), r = rn(i, "title", this, t), o = rn(i, "afterTitle", this, t);
          let a = [];
          return a = On(a, ei(s)), a = On(a, ei(r)), a = On(a, ei(o)), a;
        }
        getBeforeBody(t, e) {
          return pp(rn(e.callbacks, "beforeBody", this, t));
        }
        getBody(t, e) {
          const { callbacks: i } = e, s = [];
          return he(t, (r) => {
            const o = {
              before: [],
              lines: [],
              after: []
            }, a = mp(i, r);
            On(o.before, ei(rn(a, "beforeLabel", this, r))), On(o.lines, rn(a, "label", this, r)), On(o.after, ei(rn(a, "afterLabel", this, r))), s.push(o);
          }), s;
        }
        getAfterBody(t, e) {
          return pp(rn(e.callbacks, "afterBody", this, t));
        }
        getFooter(t, e) {
          const { callbacks: i } = e, s = rn(i, "beforeFooter", this, t), r = rn(i, "footer", this, t), o = rn(i, "afterFooter", this, t);
          let a = [];
          return a = On(a, ei(s)), a = On(a, ei(r)), a = On(a, ei(o)), a;
        }
        _createItems(t) {
          const e = this._active, i = this.chart.data, s = [], r = [], o = [];
          let a = [], l, c;
          for (l = 0, c = e.length; l < c; ++l) a.push(nC(this.chart, e[l]));
          return t.filter && (a = a.filter((h, u, d) => t.filter(h, u, d, i))), t.itemSort && (a = a.sort((h, u) => t.itemSort(h, u, i))), he(a, (h) => {
            const u = mp(t.callbacks, h);
            s.push(rn(u, "labelColor", this, h)), r.push(rn(u, "labelPointStyle", this, h)), o.push(rn(u, "labelTextColor", this, h));
          }), this.labelColors = s, this.labelPointStyles = r, this.labelTextColors = o, this.dataPoints = a, a;
        }
        update(t, e) {
          const i = this.options.setContext(this.getContext()), s = this._active;
          let r, o = [];
          if (!s.length) this.opacity !== 0 && (r = {
            opacity: 0
          });
          else {
            const a = Br[i.position].call(this, s, this._eventPosition);
            o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);
            const l = this._size = up(this, i), c = Object.assign({}, a, l), h = dp(this.chart, i, c), u = fp(i, c, h, this.chart);
            this.xAlign = h.xAlign, this.yAlign = h.yAlign, r = {
              opacity: 1,
              x: u.x,
              y: u.y,
              width: l.width,
              height: l.height,
              caretX: a.x,
              caretY: a.y
            };
          }
          this._tooltipItems = o, this.$context = void 0, r && this._resolveAnimations().update(this, r), t && i.external && i.external.call(this, {
            chart: this.chart,
            tooltip: this,
            replay: e
          });
        }
        drawCaret(t, e, i, s) {
          const r = this.getCaretPosition(t, i, s);
          e.lineTo(r.x1, r.y1), e.lineTo(r.x2, r.y2), e.lineTo(r.x3, r.y3);
        }
        getCaretPosition(t, e, i) {
          const { xAlign: s, yAlign: r } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: l, topRight: c, bottomLeft: h, bottomRight: u } = Ci(a), { x: d, y: f } = t, { width: g, height: _ } = e;
          let m, p, y, w, M, C;
          return r === "center" ? (M = f + _ / 2, s === "left" ? (m = d, p = m - o, w = M + o, C = M - o) : (m = d + g, p = m + o, w = M - o, C = M + o), y = m) : (s === "left" ? p = d + Math.max(l, h) + o : s === "right" ? p = d + g - Math.max(c, u) - o : p = this.caretX, r === "top" ? (w = f, M = w - o, m = p - o, y = p + o) : (w = f + _, M = w + o, m = p + o, y = p - o), C = w), {
            x1: m,
            x2: p,
            x3: y,
            y1: w,
            y2: M,
            y3: C
          };
        }
        drawTitle(t, e, i) {
          const s = this.title, r = s.length;
          let o, a, l;
          if (r) {
            const c = $s(i.rtl, this.x, this.width);
            for (t.x = da(this, i.titleAlign, i), e.textAlign = c.textAlign(i.titleAlign), e.textBaseline = "middle", o = Te(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, l = 0; l < r; ++l) e.fillText(s[l], c.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, l + 1 === r && (t.y += i.titleMarginBottom - a);
          }
        }
        _drawColorBox(t, e, i, s, r) {
          const o = this.labelColors[i], a = this.labelPointStyles[i], { boxHeight: l, boxWidth: c } = r, h = Te(r.bodyFont), u = da(this, "left", r), d = s.x(u), f = l < h.lineHeight ? (h.lineHeight - l) / 2 : 0, g = e.y + f;
          if (r.usePointStyle) {
            const _ = {
              radius: Math.min(c, l) / 2,
              pointStyle: a.pointStyle,
              rotation: a.rotation,
              borderWidth: 1
            }, m = s.leftForLtr(d, c) + c / 2, p = g + l / 2;
            t.strokeStyle = r.multiKeyBackground, t.fillStyle = r.multiKeyBackground, ph(t, _, m, p), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, ph(t, _, m, p);
          } else {
            t.lineWidth = Wt(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, t.strokeStyle = o.borderColor, t.setLineDash(o.borderDash || []), t.lineDashOffset = o.borderDashOffset || 0;
            const _ = s.leftForLtr(d, c), m = s.leftForLtr(s.xPlus(d, 1), c - 2), p = Ci(o.borderRadius);
            Object.values(p).some((y) => y !== 0) ? (t.beginPath(), t.fillStyle = r.multiKeyBackground, sr(t, {
              x: _,
              y: g,
              w: c,
              h: l,
              radius: p
            }), t.fill(), t.stroke(), t.fillStyle = o.backgroundColor, t.beginPath(), sr(t, {
              x: m,
              y: g + 1,
              w: c - 2,
              h: l - 2,
              radius: p
            }), t.fill()) : (t.fillStyle = r.multiKeyBackground, t.fillRect(_, g, c, l), t.strokeRect(_, g, c, l), t.fillStyle = o.backgroundColor, t.fillRect(m, g + 1, c - 2, l - 2));
          }
          t.fillStyle = this.labelTextColors[i];
        }
        drawBody(t, e, i) {
          const { body: s } = this, { bodySpacing: r, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: h } = i, u = Te(i.bodyFont);
          let d = u.lineHeight, f = 0;
          const g = $s(i.rtl, this.x, this.width), _ = function(v) {
            e.fillText(v, g.x(t.x + f), t.y + d / 2), t.y += d + r;
          }, m = g.textAlign(o);
          let p, y, w, M, C, R, T;
          for (e.textAlign = o, e.textBaseline = "middle", e.font = u.string, t.x = da(this, m, i), e.fillStyle = i.bodyColor, he(this.beforeBody, _), f = a && m !== "right" ? o === "center" ? c / 2 + h : c + 2 + h : 0, M = 0, R = s.length; M < R; ++M) {
            for (p = s[M], y = this.labelTextColors[M], e.fillStyle = y, he(p.before, _), w = p.lines, a && w.length && (this._drawColorBox(e, t, M, g, i), d = Math.max(u.lineHeight, l)), C = 0, T = w.length; C < T; ++C) _(w[C]), d = u.lineHeight;
            he(p.after, _);
          }
          f = 0, d = u.lineHeight, he(this.afterBody, _), t.y -= r;
        }
        drawFooter(t, e, i) {
          const s = this.footer, r = s.length;
          let o, a;
          if (r) {
            const l = $s(i.rtl, this.x, this.width);
            for (t.x = da(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = l.textAlign(i.footerAlign), e.textBaseline = "middle", o = Te(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < r; ++a) e.fillText(s[a], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing;
          }
        }
        drawBackground(t, e, i, s) {
          const { xAlign: r, yAlign: o } = this, { x: a, y: l } = t, { width: c, height: h } = i, { topLeft: u, topRight: d, bottomLeft: f, bottomRight: g } = Ci(s.cornerRadius);
          e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + u, l), o === "top" && this.drawCaret(t, e, i, s), e.lineTo(a + c - d, l), e.quadraticCurveTo(a + c, l, a + c, l + d), o === "center" && r === "right" && this.drawCaret(t, e, i, s), e.lineTo(a + c, l + h - g), e.quadraticCurveTo(a + c, l + h, a + c - g, l + h), o === "bottom" && this.drawCaret(t, e, i, s), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), o === "center" && r === "left" && this.drawCaret(t, e, i, s), e.lineTo(a, l + u), e.quadraticCurveTo(a, l, a + u, l), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();
        }
        _updateAnimationTarget(t) {
          const e = this.chart, i = this.$animations, s = i && i.x, r = i && i.y;
          if (s || r) {
            const o = Br[t.position].call(this, this._active, this._eventPosition);
            if (!o) return;
            const a = this._size = up(this, t), l = Object.assign({}, o, this._size), c = dp(e, t, l), h = fp(t, l, c, e);
            (s._to !== h.x || r._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, h));
          }
        }
        _willRender() {
          return !!this.opacity;
        }
        draw(t) {
          const e = this.options.setContext(this.getContext());
          let i = this.opacity;
          if (!i) return;
          this._updateAnimationTarget(e);
          const s = {
            width: this.width,
            height: this.height
          }, r = {
            x: this.x,
            y: this.y
          };
          i = Math.abs(i) < 1e-3 ? 0 : i;
          const o = Fe(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
          e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(r, t, s, e), gg(t, e.textDirection), r.y += o.top, this.drawTitle(r, t, e), this.drawBody(r, t, e), this.drawFooter(r, t, e), _g(t, e.textDirection), t.restore());
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(t, e) {
          const i = this._active, s = t.map(({ datasetIndex: a, index: l }) => {
            const c = this.chart.getDatasetMeta(a);
            if (!c) throw new Error("Cannot find a dataset at index " + a);
            return {
              datasetIndex: a,
              element: c.data[l],
              index: l
            };
          }), r = !Ba(i, s), o = this._positionChanged(s, e);
          (r || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = true, this.update(true));
        }
        handleEvent(t, e, i = true) {
          if (e && this._ignoreReplayEvents) return false;
          this._ignoreReplayEvents = false;
          const s = this.options, r = this._active || [], o = this._getActiveElements(t, r, e, i), a = this._positionChanged(o, t), l = e || !Ba(o, r) || a;
          return l && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {
            x: t.x,
            y: t.y
          }, this.update(true, e))), l;
        }
        _getActiveElements(t, e, i, s) {
          const r = this.options;
          if (t.type === "mouseout") return [];
          if (!s) return e.filter((a) => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
          const o = this.chart.getElementsAtEventForMode(t, r.mode, r, i);
          return r.reverse && o.reverse(), o;
        }
        _positionChanged(t, e) {
          const { caretX: i, caretY: s, options: r } = this, o = Br[r.position].call(this, t, e);
          return o !== false && (i !== o.x || s !== o.y);
        }
      }
      __publicField(gp, "positioners", Br);
      var cC = {
        id: "tooltip",
        _element: gp,
        positioners: Br,
        afterInit(n, t, e) {
          e && (n.tooltip = new gp({
            chart: n,
            options: e
          }));
        },
        beforeUpdate(n, t, e) {
          n.tooltip && n.tooltip.initialize(e);
        },
        reset(n, t, e) {
          n.tooltip && n.tooltip.initialize(e);
        },
        afterDraw(n) {
          const t = n.tooltip;
          if (t && t._willRender()) {
            const e = {
              tooltip: t
            };
            if (n.notifyPlugins("beforeTooltipDraw", {
              ...e,
              cancelable: true
            }) === false) return;
            t.draw(n.ctx), n.notifyPlugins("afterTooltipDraw", e);
          }
        },
        afterEvent(n, t) {
          if (n.tooltip) {
            const e = t.replay;
            n.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = true);
          }
        },
        defaults: {
          enabled: true,
          external: null,
          position: "average",
          backgroundColor: "rgba(0,0,0,0.8)",
          titleColor: "#fff",
          titleFont: {
            weight: "bold"
          },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: "left",
          bodyColor: "#fff",
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: "left",
          footerColor: "#fff",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: {
            weight: "bold"
          },
          footerAlign: "left",
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (n, t) => t.bodyFont.size,
          boxWidth: (n, t) => t.bodyFont.size,
          multiKeyBackground: "#fff",
          displayColors: true,
          boxPadding: 0,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          animation: {
            duration: 400,
            easing: "easeOutQuart"
          },
          animations: {
            numbers: {
              type: "number",
              properties: [
                "x",
                "y",
                "width",
                "height",
                "caretX",
                "caretY"
              ]
            },
            opacity: {
              easing: "linear",
              duration: 200
            }
          },
          callbacks: Gg
        },
        defaultRoutes: {
          bodyFont: "font",
          footerFont: "font",
          titleFont: "font"
        },
        descriptors: {
          _scriptable: (n) => n !== "filter" && n !== "itemSort" && n !== "external",
          _indexable: false,
          callbacks: {
            _scriptable: false,
            _indexable: false
          },
          animation: {
            _fallback: false
          },
          animations: {
            _fallback: "animation"
          }
        },
        additionalOptionScopes: [
          "interaction"
        ]
      }, hC = Object.freeze({
        __proto__: null,
        Colors: M1,
        Decimation: T1,
        Filler: Y1,
        Legend: Q1,
        SubTitle: eC,
        Title: tC,
        Tooltip: cC
      });
      const uC = (n, t, e, i) => (typeof t == "string" ? (e = n.push(t) - 1, i.unshift({
        index: e,
        label: t
      })) : isNaN(t) && (e = null), e);
      function dC(n, t, e, i) {
        const s = n.indexOf(t);
        if (s === -1) return uC(n, t, e, i);
        const r = n.lastIndexOf(t);
        return s !== r ? e : s;
      }
      const fC = (n, t) => n === null ? null : Ve(Math.round(n), 0, t);
      function _p(n) {
        const t = this.getLabels();
        return n >= 0 && n < t.length ? t[n] : n;
      }
      class pC extends ms {
        constructor(t) {
          super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
        }
        init(t) {
          const e = this._addedLabels;
          if (e.length) {
            const i = this.getLabels();
            for (const { index: s, label: r } of e) i[s] === r && i.splice(s, 1);
            this._addedLabels = [];
          }
          super.init(t);
        }
        parse(t, e) {
          if (Kt(t)) return null;
          const i = this.getLabels();
          return e = isFinite(e) && i[e] === t ? e : dC(i, t, Ut(e, t), this._addedLabels), fC(e, i.length - 1);
        }
        determineDataLimits() {
          const { minDefined: t, maxDefined: e } = this.getUserBounds();
          let { min: i, max: s } = this.getMinMax(true);
          this.options.bounds === "ticks" && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s;
        }
        buildTicks() {
          const t = this.min, e = this.max, i = this.options.offset, s = [];
          let r = this.getLabels();
          r = t === 0 && e === r.length - 1 ? r : r.slice(t, e + 1), this._valueRange = Math.max(r.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? 0.5 : 0);
          for (let o = t; o <= e; o++) s.push({
            value: o
          });
          return s;
        }
        getLabelForValue(t) {
          return _p.call(this, t);
        }
        configure() {
          super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
        }
        getPixelForValue(t) {
          return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
        }
        getPixelForTick(t) {
          const e = this.ticks;
          return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
        }
        getValueForPixel(t) {
          return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
        }
        getBasePixel() {
          return this.bottom;
        }
      }
      __publicField(pC, "id", "category");
      __publicField(pC, "defaults", {
        ticks: {
          callback: _p
        }
      });
      function mC(n, t) {
        const e = [], { bounds: s, step: r, min: o, max: a, precision: l, count: c, maxTicks: h, maxDigits: u, includeBounds: d } = n, f = r || 1, g = h - 1, { min: _, max: m } = t, p = !Kt(o), y = !Kt(a), w = !Kt(c), M = (m - _) / (u + 1);
        let C = uf((m - _) / g / f) * f, R, T, v, x;
        if (C < 1e-14 && !p && !y) return [
          {
            value: _
          },
          {
            value: m
          }
        ];
        x = Math.ceil(m / C) - Math.floor(_ / C), x > g && (C = uf(x * C / g / f) * f), Kt(l) || (R = Math.pow(10, l), C = Math.ceil(C * R) / R), s === "ticks" ? (T = Math.floor(_ / C) * C, v = Math.ceil(m / C) * C) : (T = _, v = m), p && y && r && Jw((a - o) / r, C / 1e3) ? (x = Math.round(Math.min((a - o) / C, h)), C = (a - o) / x, T = o, v = a) : w ? (T = p ? o : T, v = y ? a : v, x = c - 1, C = (v - T) / x) : (x = (v - T) / C, Wr(x, Math.round(x), C / 1e3) ? x = Math.round(x) : x = Math.ceil(x));
        const b = Math.max(df(C), df(T));
        R = Math.pow(10, Kt(l) ? b : l), T = Math.round(T * R) / R, v = Math.round(v * R) / R;
        let A = 0;
        for (p && (d && T !== o ? (e.push({
          value: o
        }), T < o && A++, Wr(Math.round((T + A * C) * R) / R, o, xp(o, M, n)) && A++) : T < o && A++); A < x; ++A) {
          const L = Math.round((T + A * C) * R) / R;
          if (y && L > a) break;
          e.push({
            value: L
          });
        }
        return y && d && v !== a ? e.length && Wr(e[e.length - 1].value, a, xp(a, M, n)) ? e[e.length - 1].value = a : e.push({
          value: a
        }) : (!y || v === a) && e.push({
          value: v
        }), e;
      }
      function xp(n, t, { horizontal: e, minRotation: i }) {
        const s = ke(i), r = (e ? Math.sin(s) : Math.cos(s)) || 1e-3, o = 0.75 * t * ("" + n).length;
        return Math.min(t / r, o);
      }
      class qa extends ms {
        constructor(t) {
          super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
        }
        parse(t, e) {
          return Kt(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
        }
        handleTickRangeOptions() {
          const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds();
          let { min: s, max: r } = this;
          const o = (l) => s = e ? s : l, a = (l) => r = i ? r : l;
          if (t) {
            const l = Hn(s), c = Hn(r);
            l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0);
          }
          if (s === r) {
            let l = r === 0 ? 1 : Math.abs(r * 0.05);
            a(r + l), t || o(s - l);
          }
          this.min = s, this.max = r;
        }
        getTickLimit() {
          const t = this.options.ticks;
          let { maxTicksLimit: e, stepSize: i } = t, s;
          return i ? (s = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${s} ticks. Limiting to 1000.`), s = 1e3)) : (s = this.computeTickLimit(), e = e || 11), e && (s = Math.min(e, s)), s;
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const t = this.options, e = t.ticks;
          let i = this.getTickLimit();
          i = Math.max(2, i);
          const s = {
            maxTicks: i,
            bounds: t.bounds,
            min: t.min,
            max: t.max,
            precision: e.precision,
            step: e.stepSize,
            count: e.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: e.minRotation || 0,
            includeBounds: e.includeBounds !== false
          }, r = this._range || this, o = mC(s, r);
          return t.bounds === "ticks" && tg(o, this, "value"), t.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
        }
        configure() {
          const t = this.ticks;
          let e = this.min, i = this.max;
          if (super.configure(), this.options.offset && t.length) {
            const s = (i - e) / Math.max(t.length - 1, 1) / 2;
            e -= s, i += s;
          }
          this._startValue = e, this._endValue = i, this._valueRange = i - e;
        }
        getLabelForValue(t) {
          return ho(t, this.chart.options.locale, this.options.ticks.format);
        }
      }
      class gC extends qa {
        determineDataLimits() {
          const { min: t, max: e } = this.getMinMax(true);
          this.min = Me(t) ? t : 0, this.max = Me(e) ? e : 1, this.handleTickRangeOptions();
        }
        computeTickLimit() {
          const t = this.isHorizontal(), e = t ? this.width : this.height, i = ke(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || 1e-3, r = this._resolveTickFontOptions(0);
          return Math.ceil(e / Math.min(40, r.lineHeight / s));
        }
        getPixelForValue(t) {
          return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
        }
        getValueForPixel(t) {
          return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
        }
      }
      __publicField(gC, "id", "linear");
      __publicField(gC, "defaults", {
        ticks: {
          callback: sl.formatters.numeric
        }
      });
      const so = (n) => Math.floor(Mi(n)), qi = (n, t) => Math.pow(10, so(n) + t);
      function bp(n) {
        return n / Math.pow(10, so(n)) === 1;
      }
      function yp(n, t, e) {
        const i = Math.pow(10, e), s = Math.floor(n / i);
        return Math.ceil(t / i) - s;
      }
      function _C(n, t) {
        const e = t - n;
        let i = so(e);
        for (; yp(n, t, i) > 10; ) i++;
        for (; yp(n, t, i) < 10; ) i--;
        return Math.min(i, so(n));
      }
      function xC(n, { min: t, max: e }) {
        t = fn(n.min, t);
        const i = [], s = so(t);
        let r = _C(t, e), o = r < 0 ? Math.pow(10, Math.abs(r)) : 1;
        const a = Math.pow(10, r), l = s > r ? Math.pow(10, s) : 0, c = Math.round((t - l) * o) / o, h = Math.floor((t - l) / a / 10) * a * 10;
        let u = Math.floor((c - h) / Math.pow(10, r)), d = fn(n.min, Math.round((l + h + u * Math.pow(10, r)) * o) / o);
        for (; d < e; ) i.push({
          value: d,
          major: bp(d),
          significand: u
        }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (r++, u = 2, o = r >= 0 ? 1 : o), d = Math.round((l + h + u * Math.pow(10, r)) * o) / o;
        const f = fn(n.max, d);
        return i.push({
          value: f,
          major: bp(f),
          significand: u
        }), i;
      }
      class bC extends ms {
        constructor(t) {
          super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
        }
        parse(t, e) {
          const i = qa.prototype.parse.apply(this, [
            t,
            e
          ]);
          if (i === 0) {
            this._zero = true;
            return;
          }
          return Me(i) && i > 0 ? i : null;
        }
        determineDataLimits() {
          const { min: t, max: e } = this.getMinMax(true);
          this.min = Me(t) ? Math.max(0, t) : null, this.max = Me(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = true), this._zero && this.min !== this._suggestedMin && !Me(this._userMin) && (this.min = t === qi(this.min, 0) ? qi(this.min, -1) : qi(this.min, 0)), this.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const { minDefined: t, maxDefined: e } = this.getUserBounds();
          let i = this.min, s = this.max;
          const r = (a) => i = t ? i : a, o = (a) => s = e ? s : a;
          i === s && (i <= 0 ? (r(1), o(10)) : (r(qi(i, -1)), o(qi(s, 1)))), i <= 0 && r(qi(s, -1)), s <= 0 && o(qi(i, 1)), this.min = i, this.max = s;
        }
        buildTicks() {
          const t = this.options, e = {
            min: this._userMin,
            max: this._userMax
          }, i = xC(e, this);
          return t.bounds === "ticks" && tg(i, this, "value"), t.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i;
        }
        getLabelForValue(t) {
          return t === void 0 ? "0" : ho(t, this.chart.options.locale, this.options.ticks.format);
        }
        configure() {
          const t = this.min;
          super.configure(), this._startValue = Mi(t), this._valueRange = Mi(this.max) - Mi(t);
        }
        getPixelForValue(t) {
          return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Mi(t) - this._startValue) / this._valueRange);
        }
        getValueForPixel(t) {
          const e = this.getDecimalForPixel(t);
          return Math.pow(10, this._startValue + e * this._valueRange);
        }
      }
      __publicField(bC, "id", "logarithmic");
      __publicField(bC, "defaults", {
        ticks: {
          callback: sl.formatters.logarithmic,
          major: {
            enabled: true
          }
        }
      });
      function yh(n) {
        const t = n.ticks;
        if (t.display && n.display) {
          const e = Fe(t.backdropPadding);
          return Ut(t.font && t.font.size, be.font.size) + e.height;
        }
        return 0;
      }
      function yC(n, t, e) {
        return e = oe(e) ? e : [
          e
        ], {
          w: gE(n, t.string, e),
          h: e.length * t.lineHeight
        };
      }
      function vp(n, t, e, i, s) {
        return n === i || n === s ? {
          start: t - e / 2,
          end: t + e / 2
        } : n < i || n > s ? {
          start: t - e,
          end: t
        } : {
          start: t,
          end: t + e
        };
      }
      function vC(n) {
        const t = {
          l: n.left + n._padding.left,
          r: n.right - n._padding.right,
          t: n.top + n._padding.top,
          b: n.bottom - n._padding.bottom
        }, e = Object.assign({}, t), i = [], s = [], r = n._pointLabels.length, o = n.options.pointLabels, a = o.centerPointLabels ? Zt / r : 0;
        for (let l = 0; l < r; l++) {
          const c = o.setContext(n.getPointLabelContext(l));
          s[l] = c.padding;
          const h = n.getPointPosition(l, n.drawingArea + s[l], a), u = Te(c.font), d = yC(n.ctx, u, n._pointLabels[l]);
          i[l] = d;
          const f = pn(n.getIndexAngle(l) + a), g = Math.round(il(f)), _ = vp(g, h.x, d.w, 0, 180), m = vp(g, h.y, d.h, 90, 270);
          MC(e, t, f, _, m);
        }
        n.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), n._pointLabelItems = EC(n, i, s);
      }
      function MC(n, t, e, i, s) {
        const r = Math.abs(Math.sin(e)), o = Math.abs(Math.cos(e));
        let a = 0, l = 0;
        i.start < t.l ? (a = (t.l - i.start) / r, n.l = Math.min(n.l, t.l - a)) : i.end > t.r && (a = (i.end - t.r) / r, n.r = Math.max(n.r, t.r + a)), s.start < t.t ? (l = (t.t - s.start) / o, n.t = Math.min(n.t, t.t - l)) : s.end > t.b && (l = (s.end - t.b) / o, n.b = Math.max(n.b, t.b + l));
      }
      function SC(n, t, e) {
        const i = n.drawingArea, { extra: s, additionalAngle: r, padding: o, size: a } = e, l = n.getPointPosition(t, i + s + o, r), c = Math.round(il(pn(l.angle + xe))), h = CC(l.y, a.h, c), u = TC(c), d = AC(l.x, a.w, u);
        return {
          visible: true,
          x: l.x,
          y: h,
          textAlign: u,
          left: d,
          top: h,
          right: d + a.w,
          bottom: h + a.h
        };
      }
      function wC(n, t) {
        if (!t) return true;
        const { left: e, top: i, right: s, bottom: r } = n;
        return !(li({
          x: e,
          y: i
        }, t) || li({
          x: e,
          y: r
        }, t) || li({
          x: s,
          y: i
        }, t) || li({
          x: s,
          y: r
        }, t));
      }
      function EC(n, t, e) {
        const i = [], s = n._pointLabels.length, r = n.options, { centerPointLabels: o, display: a } = r.pointLabels, l = {
          extra: yh(r) / 2,
          additionalAngle: o ? Zt / s : 0
        };
        let c;
        for (let h = 0; h < s; h++) {
          l.padding = e[h], l.size = t[h];
          const u = SC(n, h, l);
          i.push(u), a === "auto" && (u.visible = wC(u, c), u.visible && (c = u));
        }
        return i;
      }
      function TC(n) {
        return n === 0 || n === 180 ? "center" : n < 180 ? "left" : "right";
      }
      function AC(n, t, e) {
        return e === "right" ? n -= t : e === "center" && (n -= t / 2), n;
      }
      function CC(n, t, e) {
        return e === 90 || e === 270 ? n -= t / 2 : (e > 270 || e < 90) && (n -= t), n;
      }
      function RC(n, t, e) {
        const { left: i, top: s, right: r, bottom: o } = e, { backdropColor: a } = t;
        if (!Kt(a)) {
          const l = Ci(t.borderRadius), c = Fe(t.backdropPadding);
          n.fillStyle = a;
          const h = i - c.left, u = s - c.top, d = r - i + c.width, f = o - s + c.height;
          Object.values(l).some((g) => g !== 0) ? (n.beginPath(), sr(n, {
            x: h,
            y: u,
            w: d,
            h: f,
            radius: l
          }), n.fill()) : n.fillRect(h, u, d, f);
        }
      }
      function PC(n, t) {
        const { ctx: e, options: { pointLabels: i } } = n;
        for (let s = t - 1; s >= 0; s--) {
          const r = n._pointLabelItems[s];
          if (!r.visible) continue;
          const o = i.setContext(n.getPointLabelContext(s));
          RC(e, o, r);
          const a = Te(o.font), { x: l, y: c, textAlign: h } = r;
          us(e, n._pointLabels[s], l, c + a.lineHeight / 2, a, {
            color: o.color,
            textAlign: h,
            textBaseline: "middle"
          });
        }
      }
      function Xg(n, t, e, i) {
        const { ctx: s } = n;
        if (e) s.arc(n.xCenter, n.yCenter, t, 0, ge);
        else {
          let r = n.getPointPosition(0, t);
          s.moveTo(r.x, r.y);
          for (let o = 1; o < i; o++) r = n.getPointPosition(o, t), s.lineTo(r.x, r.y);
        }
      }
      function DC(n, t, e, i, s) {
        const r = n.ctx, o = t.circular, { color: a, lineWidth: l } = t;
        !o && !i || !a || !l || e < 0 || (r.save(), r.strokeStyle = a, r.lineWidth = l, r.setLineDash(s.dash || []), r.lineDashOffset = s.dashOffset, r.beginPath(), Xg(n, e, o, i), r.closePath(), r.stroke(), r.restore());
      }
      function LC(n, t, e) {
        return Fi(n, {
          label: e,
          index: t,
          type: "pointLabel"
        });
      }
      class IC extends qa {
        constructor(t) {
          super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
        }
        setDimensions() {
          const t = this._padding = Fe(yh(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height;
          this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2);
        }
        determineDataLimits() {
          const { min: t, max: e } = this.getMinMax(false);
          this.min = Me(t) && !isNaN(t) ? t : 0, this.max = Me(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(this.drawingArea / yh(this.options));
        }
        generateTickLabels(t) {
          qa.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, i) => {
            const s = ce(this.options.pointLabels.callback, [
              e,
              i
            ], this);
            return s || s === 0 ? s : "";
          }).filter((e, i) => this.chart.getDataVisibility(i));
        }
        fit() {
          const t = this.options;
          t.display && t.pointLabels.display ? vC(this) : this.setCenterPoint(0, 0, 0, 0);
        }
        setCenterPoint(t, e, i, s) {
          this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s));
        }
        getIndexAngle(t) {
          const e = ge / (this._pointLabels.length || 1), i = this.options.startAngle || 0;
          return pn(t * e + ke(i));
        }
        getDistanceFromCenterForValue(t) {
          if (Kt(t)) return NaN;
          const e = this.drawingArea / (this.max - this.min);
          return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;
        }
        getValueForDistanceFromCenter(t) {
          if (Kt(t)) return NaN;
          const e = t / (this.drawingArea / (this.max - this.min));
          return this.options.reverse ? this.max - e : this.min + e;
        }
        getPointLabelContext(t) {
          const e = this._pointLabels || [];
          if (t >= 0 && t < e.length) {
            const i = e[t];
            return LC(this.getContext(), t, i);
          }
        }
        getPointPosition(t, e, i = 0) {
          const s = this.getIndexAngle(t) - xe + i;
          return {
            x: Math.cos(s) * e + this.xCenter,
            y: Math.sin(s) * e + this.yCenter,
            angle: s
          };
        }
        getPointPositionForValue(t, e) {
          return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
        }
        getBasePosition(t) {
          return this.getPointPositionForValue(t || 0, this.getBaseValue());
        }
        getPointLabelPosition(t) {
          const { left: e, top: i, right: s, bottom: r } = this._pointLabelItems[t];
          return {
            left: e,
            top: i,
            right: s,
            bottom: r
          };
        }
        drawBackground() {
          const { backgroundColor: t, grid: { circular: e } } = this.options;
          if (t) {
            const i = this.ctx;
            i.save(), i.beginPath(), Xg(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore();
          }
        }
        drawGrid() {
          const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: r } = e, o = this._pointLabels.length;
          let a, l, c;
          if (e.pointLabels.display && PC(this, o), s.display && this.ticks.forEach((h, u) => {
            if (u !== 0 || u === 0 && this.min < 0) {
              l = this.getDistanceFromCenterForValue(h.value);
              const d = this.getContext(u), f = s.setContext(d), g = r.setContext(d);
              DC(this, f, l, o, g);
            }
          }), i.display) {
            for (t.save(), a = o - 1; a >= 0; a--) {
              const h = i.setContext(this.getPointLabelContext(a)), { color: u, lineWidth: d } = h;
              !d || !u || (t.lineWidth = d, t.strokeStyle = u, t.setLineDash(h.borderDash), t.lineDashOffset = h.borderDashOffset, l = this.getDistanceFromCenterForValue(e.reverse ? this.min : this.max), c = this.getPointPosition(a, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(c.x, c.y), t.stroke());
            }
            t.restore();
          }
        }
        drawBorder() {
        }
        drawLabels() {
          const t = this.ctx, e = this.options, i = e.ticks;
          if (!i.display) return;
          const s = this.getIndexAngle(0);
          let r, o;
          t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((a, l) => {
            if (l === 0 && this.min >= 0 && !e.reverse) return;
            const c = i.setContext(this.getContext(l)), h = Te(c.font);
            if (r = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
              t.font = h.string, o = t.measureText(a.label).width, t.fillStyle = c.backdropColor;
              const u = Fe(c.backdropPadding);
              t.fillRect(-o / 2 - u.left, -r - h.size / 2 - u.top, o + u.width, h.size + u.height);
            }
            us(t, a.label, 0, -r, h, {
              color: c.color,
              strokeColor: c.textStrokeColor,
              strokeWidth: c.textStrokeWidth
            });
          }), t.restore();
        }
        drawTitle() {
        }
      }
      __publicField(IC, "id", "radialLinear");
      __publicField(IC, "defaults", {
        display: true,
        animate: true,
        position: "chartArea",
        angleLines: {
          display: true,
          lineWidth: 1,
          borderDash: [],
          borderDashOffset: 0
        },
        grid: {
          circular: false
        },
        startAngle: 0,
        ticks: {
          showLabelBackdrop: true,
          callback: sl.formatters.numeric
        },
        pointLabels: {
          backdropColor: void 0,
          backdropPadding: 2,
          display: true,
          font: {
            size: 10
          },
          callback(t) {
            return t;
          },
          padding: 5,
          centerPointLabels: false
        }
      });
      __publicField(IC, "defaultRoutes", {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
      });
      __publicField(IC, "descriptors", {
        angleLines: {
          _fallback: "grid"
        }
      });
      const cl = {
        millisecond: {
          common: true,
          size: 1,
          steps: 1e3
        },
        second: {
          common: true,
          size: 1e3,
          steps: 60
        },
        minute: {
          common: true,
          size: 6e4,
          steps: 60
        },
        hour: {
          common: true,
          size: 36e5,
          steps: 24
        },
        day: {
          common: true,
          size: 864e5,
          steps: 30
        },
        week: {
          common: false,
          size: 6048e5,
          steps: 4
        },
        month: {
          common: true,
          size: 2628e6,
          steps: 12
        },
        quarter: {
          common: false,
          size: 7884e6,
          steps: 4
        },
        year: {
          common: true,
          size: 3154e7
        }
      }, on = Object.keys(cl);
      function Mp(n, t) {
        return n - t;
      }
      function Sp(n, t) {
        if (Kt(t)) return null;
        const e = n._adapter, { parser: i, round: s, isoWeekday: r } = n._parseOpts;
        let o = t;
        return typeof i == "function" && (o = i(o)), Me(o) || (o = typeof i == "string" ? e.parse(o, i) : e.parse(o)), o === null ? null : (s && (o = s === "week" && (Oi(r) || r === true) ? e.startOf(o, "isoWeek", r) : e.startOf(o, s)), +o);
      }
      function wp(n, t, e, i) {
        const s = on.length;
        for (let r = on.indexOf(n); r < s - 1; ++r) {
          const o = cl[on[r]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
          if (o.common && Math.ceil((e - t) / (a * o.size)) <= i) return on[r];
        }
        return on[s - 1];
      }
      function OC(n, t, e, i, s) {
        for (let r = on.length - 1; r >= on.indexOf(e); r--) {
          const o = on[r];
          if (cl[o].common && n._adapter.diff(s, i, o) >= t - 1) return o;
        }
        return on[e ? on.indexOf(e) : 0];
      }
      function kC(n) {
        for (let t = on.indexOf(n) + 1, e = on.length; t < e; ++t) if (cl[on[t]].common) return on[t];
      }
      function Ep(n, t, e) {
        if (!e) n[t] = true;
        else if (e.length) {
          const { lo: i, hi: s } = iu(e, t), r = e[i] >= t ? e[i] : e[s];
          n[r] = true;
        }
      }
      function FC(n, t, e, i) {
        const s = n._adapter, r = +s.startOf(t[0].value, i), o = t[t.length - 1].value;
        let a, l;
        for (a = r; a <= o; a = +s.add(a, 1, i)) l = e[a], l >= 0 && (t[l].major = true);
        return t;
      }
      function Tp(n, t, e) {
        const i = [], s = {}, r = t.length;
        let o, a;
        for (o = 0; o < r; ++o) a = t[o], s[a] = o, i.push({
          value: a,
          major: false
        });
        return r === 0 || !e ? i : FC(n, i, s, e);
      }
      class vh extends ms {
        constructor(t) {
          super(t), this._cache = {
            data: [],
            labels: [],
            all: []
          }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = false, this._parseOpts = void 0;
        }
        init(t, e = {}) {
          const i = t.time || (t.time = {}), s = this._adapter = new Eg._date(t.adapters.date);
          s.init(e), Vr(i.displayFormats, s.formats()), this._parseOpts = {
            parser: i.parser,
            round: i.round,
            isoWeekday: i.isoWeekday
          }, super.init(t), this._normalized = e.normalized;
        }
        parse(t, e) {
          return t === void 0 ? null : Sp(this, t);
        }
        beforeLayout() {
          super.beforeLayout(), this._cache = {
            data: [],
            labels: [],
            all: []
          };
        }
        determineDataLimits() {
          const t = this.options, e = this._adapter, i = t.time.unit || "day";
          let { min: s, max: r, minDefined: o, maxDefined: a } = this.getUserBounds();
          function l(c) {
            !o && !isNaN(c.min) && (s = Math.min(s, c.min)), !a && !isNaN(c.max) && (r = Math.max(r, c.max));
          }
          (!o || !a) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(false))), s = Me(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), r = Me(r) && !isNaN(r) ? r : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, r - 1), this.max = Math.max(s + 1, r);
        }
        _getLabelBounds() {
          const t = this.getLabelTimestamps();
          let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
          return t.length && (e = t[0], i = t[t.length - 1]), {
            min: e,
            max: i
          };
        }
        buildTicks() {
          const t = this.options, e = t.time, i = t.ticks, s = i.source === "labels" ? this.getLabelTimestamps() : this._generate();
          t.bounds === "ticks" && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);
          const r = this.min, o = this.max, a = iE(s, r, o);
          return this._unit = e.unit || (i.autoSkip ? wp(e.minUnit, this.min, this.max, this._getLabelCapacity(r)) : OC(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : kC(this._unit), this.initOffsets(s), t.reverse && a.reverse(), Tp(this, a, this._majorUnit);
        }
        afterAutoSkip() {
          this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
        }
        initOffsets(t = []) {
          let e = 0, i = 0, s, r;
          this.options.offset && t.length && (s = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - s : e = (this.getDecimalForValue(t[1]) - s) / 2, r = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? i = r : i = (r - this.getDecimalForValue(t[t.length - 2])) / 2);
          const o = t.length < 3 ? 0.5 : 0.25;
          e = Ve(e, 0, o), i = Ve(i, 0, o), this._offsets = {
            start: e,
            end: i,
            factor: 1 / (e + 1 + i)
          };
        }
        _generate() {
          const t = this._adapter, e = this.min, i = this.max, s = this.options, r = s.time, o = r.unit || wp(r.minUnit, e, i, this._getLabelCapacity(e)), a = Ut(s.ticks.stepSize, 1), l = o === "week" ? r.isoWeekday : false, c = Oi(l) || l === true, h = {};
          let u = e, d, f;
          if (c && (u = +t.startOf(u, "isoWeek", l)), u = +t.startOf(u, c ? "day" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + " and " + i + " are too far apart with stepSize of " + a + " " + o);
          const g = s.ticks.source === "data" && this.getDataTimestamps();
          for (d = u, f = 0; d < i; d = +t.add(d, a, o), f++) Ep(h, d, g);
          return (d === i || s.bounds === "ticks" || f === 1) && Ep(h, d, g), Object.keys(h).sort(Mp).map((_) => +_);
        }
        getLabelForValue(t) {
          const e = this._adapter, i = this.options.time;
          return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime);
        }
        format(t, e) {
          const s = this.options.time.displayFormats, r = this._unit, o = e || s[r];
          return this._adapter.format(t, o);
        }
        _tickFormatFunction(t, e, i, s) {
          const r = this.options, o = r.ticks.callback;
          if (o) return ce(o, [
            t,
            e,
            i
          ], this);
          const a = r.time.displayFormats, l = this._unit, c = this._majorUnit, h = l && a[l], u = c && a[c], d = i[e], f = c && u && d && d.major;
          return this._adapter.format(t, s || (f ? u : h));
        }
        generateTickLabels(t) {
          let e, i, s;
          for (e = 0, i = t.length; e < i; ++e) s = t[e], s.label = this._tickFormatFunction(s.value, e, t);
        }
        getDecimalForValue(t) {
          return t === null ? NaN : (t - this.min) / (this.max - this.min);
        }
        getPixelForValue(t) {
          const e = this._offsets, i = this.getDecimalForValue(t);
          return this.getPixelForDecimal((e.start + i) * e.factor);
        }
        getValueForPixel(t) {
          const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;
          return this.min + i * (this.max - this.min);
        }
        _getLabelSize(t) {
          const e = this.options.ticks, i = this.ctx.measureText(t).width, s = ke(this.isHorizontal() ? e.maxRotation : e.minRotation), r = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;
          return {
            w: i * r + a * o,
            h: i * o + a * r
          };
        }
        _getLabelCapacity(t) {
          const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, r = this._tickFormatFunction(t, 0, Tp(this, [
            t
          ], this._majorUnit), s), o = this._getLabelSize(r), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
          return a > 0 ? a : 1;
        }
        getDataTimestamps() {
          let t = this._cache.data || [], e, i;
          if (t.length) return t;
          const s = this.getMatchingVisibleMetas();
          if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);
          for (e = 0, i = s.length; e < i; ++e) t = t.concat(s[e].controller.getAllParsedValues(this));
          return this._cache.data = this.normalize(t);
        }
        getLabelTimestamps() {
          const t = this._cache.labels || [];
          let e, i;
          if (t.length) return t;
          const s = this.getLabels();
          for (e = 0, i = s.length; e < i; ++e) t.push(Sp(this, s[e]));
          return this._cache.labels = this._normalized ? t : this.normalize(t);
        }
        normalize(t) {
          return ng(t.sort(Mp));
        }
      }
      __publicField(vh, "id", "time");
      __publicField(vh, "defaults", {
        bounds: "data",
        adapters: {},
        time: {
          parser: false,
          unit: false,
          round: false,
          isoWeekday: false,
          minUnit: "millisecond",
          displayFormats: {}
        },
        ticks: {
          source: "auto",
          callback: false,
          major: {
            enabled: false
          }
        }
      });
      function fa(n, t, e) {
        let i = 0, s = n.length - 1, r, o, a, l;
        e ? (t >= n[i].pos && t <= n[s].pos && ({ lo: i, hi: s } = ai(n, "pos", t)), { pos: r, time: a } = n[i], { pos: o, time: l } = n[s]) : (t >= n[i].time && t <= n[s].time && ({ lo: i, hi: s } = ai(n, "time", t)), { time: r, pos: a } = n[i], { time: o, pos: l } = n[s]);
        const c = o - r;
        return c ? a + (l - a) * (t - r) / c : a;
      }
      class NC extends vh {
        constructor(t) {
          super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
        }
        initOffsets() {
          const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);
          this._minPos = fa(e, this.min), this._tableRange = fa(e, this.max) - this._minPos, super.initOffsets(t);
        }
        buildLookupTable(t) {
          const { min: e, max: i } = this, s = [], r = [];
          let o, a, l, c, h;
          for (o = 0, a = t.length; o < a; ++o) c = t[o], c >= e && c <= i && s.push(c);
          if (s.length < 2) return [
            {
              time: e,
              pos: 0
            },
            {
              time: i,
              pos: 1
            }
          ];
          for (o = 0, a = s.length; o < a; ++o) h = s[o + 1], l = s[o - 1], c = s[o], Math.round((h + l) / 2) !== c && r.push({
            time: c,
            pos: o / (a - 1)
          });
          return r;
        }
        _generate() {
          const t = this.min, e = this.max;
          let i = super.getDataTimestamps();
          return (!i.includes(t) || !i.length) && i.splice(0, 0, t), (!i.includes(e) || i.length === 1) && i.push(e), i.sort((s, r) => s - r);
        }
        _getTimestampsForTable() {
          let t = this._cache.all || [];
          if (t.length) return t;
          const e = this.getDataTimestamps(), i = this.getLabelTimestamps();
          return e.length && i.length ? t = this.normalize(e.concat(i)) : t = e.length ? e : i, t = this._cache.all = t, t;
        }
        getDecimalForValue(t) {
          return (fa(this._table, t) - this._minPos) / this._tableRange;
        }
        getValueForPixel(t) {
          const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;
          return fa(this._table, i * this._tableRange + this._minPos, true);
        }
      }
      __publicField(NC, "id", "timeseries");
      __publicField(NC, "defaults", vh.defaults);
      var UC = Object.freeze({
        __proto__: null,
        CategoryScale: pC,
        LinearScale: gC,
        LogarithmicScale: bC,
        RadialLinearScale: IC,
        TimeScale: vh,
        TimeSeriesScale: NC
      });
      const BC = [
        UT,
        m1,
        hC,
        UC
      ];
      Ri.register(...BC);
      const Ap = ({ data: n, width: t = 500, height: e = 300, color: i = "#2196f3", title: s = "", xLabel: r = "", yLabel: o = "", isDarkMode: a = false, annotations: l }) => {
        const c = Zs(null), h = Zs(null);
        return Xs(() => {
          if (!n || n.length === 0) return;
          h.current && h.current.destroy();
          const u = c.current.getContext("2d"), d = {
            id: "customAnnotation",
            afterDraw: (f) => {
              const g = f.ctx, _ = f.scales.x, m = f.scales.y;
              (l == null ? void 0 : l.lines) && l.lines.forEach((p) => {
                if (g.beginPath(), g.strokeStyle = p.color, g.lineWidth = p.width, p.x !== void 0) {
                  const y = _.getPixelForValue(p.x);
                  g.moveTo(y, f.chartArea.top), g.lineTo(y, f.chartArea.bottom);
                } else if (p.y !== void 0) {
                  const y = m.getPixelForValue(p.y);
                  g.moveTo(f.chartArea.left, y), g.lineTo(f.chartArea.right, y);
                }
                g.stroke();
              }), (l == null ? void 0 : l.items) && (g.font = "12px Arial", g.fillStyle = "rgba(102, 102, 102, 0.8)", g.textAlign = "center", l.items.forEach((p) => {
                const y = _.getPixelForValue(p.x);
                let w = p.position === "top" ? f.chartArea.top + 20 : f.chartArea.bottom - 20;
                g.fillText(p.text, y, w);
              }));
            }
          };
          return h.current = new Ri(u, {
            type: "line",
            data: {
              datasets: [
                {
                  label: s,
                  data: n,
                  borderColor: i,
                  borderWidth: 2,
                  fill: false,
                  tension: 0.4,
                  pointRadius: 0
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              aspectRatio: t / e,
              plugins: {
                title: {
                  display: s !== "",
                  text: s,
                  color: "#F7FAFC"
                },
                legend: {
                  display: false
                }
              },
              scales: {
                x: {
                  type: "linear",
                  title: {
                    display: true,
                    text: r,
                    color: "#F7FAFC"
                  },
                  grid: {
                    color: "rgba(255, 255, 255, 0.1)"
                  },
                  ticks: {
                    maxTicksLimit: 10,
                    color: "#F7FAFC"
                  }
                },
                y: {
                  title: {
                    display: true,
                    text: o,
                    color: "#F7FAFC"
                  },
                  grid: {
                    color: "rgba(255, 255, 255, 0.1)"
                  },
                  ticks: {
                    maxTicksLimit: 8,
                    color: "#F7FAFC"
                  }
                }
              },
              animation: false
            },
            plugins: [
              d
            ]
          }), () => {
            h.current && h.current.destroy();
          };
        }, [
          n,
          i,
          s,
          r,
          o,
          a,
          l
        ]), $("div", {
          style: {
            width: `${t}px`,
            height: `${e}px`,
            margin: "0 auto"
          },
          children: $("canvas", {
            ref: c
          })
        });
      }, pa = {
        delta: {
          lines: [
            {
              y: 0,
              color: "rgba(128, 128, 128, 0.3)",
              width: 1
            },
            {
              y: 0.5,
              color: "rgba(33, 150, 243, 0.3)",
              width: 1
            },
            {
              y: -0.5,
              color: "rgba(233, 30, 99, 0.3)",
              width: 1
            }
          ],
          items: [
            {
              x: 100,
              text: "\xB10.5 delta point",
              position: "top"
            },
            {
              x: 150,
              text: "Delta approaches \xB11",
              position: "bottom"
            }
          ]
        },
        gamma: {
          lines: [
            {
              y: 0,
              color: "rgba(128, 128, 128, 0.3)",
              width: 1
            }
          ],
          items: [
            {
              x: 100,
              text: "Peak gamma (highest sensitivity)",
              position: "top"
            }
          ]
        },
        theta: {
          lines: [
            {
              y: 0,
              color: "rgba(128, 128, 128, 0.3)",
              width: 1
            }
          ],
          items: [
            {
              x: 100,
              text: "Maximum theta decay",
              position: "bottom"
            }
          ]
        },
        vega: {
          lines: [
            {
              y: 0,
              color: "rgba(128, 128, 128, 0.3)",
              width: 1
            }
          ],
          items: [
            {
              x: 100,
              text: "Peak vega sensitivity",
              position: "top"
            }
          ]
        }
      };
      const Cp = {
        modes: {
          point(n, t) {
            return Ca(n, t, {
              intersect: true
            });
          },
          nearest(n, t, e) {
            return VC(n, t, e);
          },
          x(n, t, e) {
            return Ca(n, t, {
              intersect: e.intersect,
              axis: "x"
            });
          },
          y(n, t, e) {
            return Ca(n, t, {
              intersect: e.intersect,
              axis: "y"
            });
          }
        }
      };
      function gu(n, t, e) {
        return (Cp.modes[e.mode] || Cp.modes.nearest)(n, t, e);
      }
      function zC(n, t, e) {
        return e !== "x" && e !== "y" ? n.inRange(t.x, t.y, "x", true) || n.inRange(t.x, t.y, "y", true) : n.inRange(t.x, t.y, e, true);
      }
      function HC(n, t, e) {
        return e === "x" ? {
          x: n.x,
          y: t.y
        } : e === "y" ? {
          x: t.x,
          y: n.y
        } : t;
      }
      function Ca(n, t, e) {
        return n.filter((i) => e.intersect ? i.inRange(t.x, t.y) : zC(i, t, e.axis));
      }
      function VC(n, t, e) {
        let i = Number.POSITIVE_INFINITY;
        return Ca(n, t, e).reduce((s, r) => {
          const o = r.getCenterPoint(), a = HC(t, o, e.axis), l = ir(t, a);
          return l < i ? (s = [
            r
          ], i = l) : l === i && s.push(r), s;
        }, []).sort((s, r) => s._index - r._index).slice(0, 1);
      }
      function gs(n, t, e) {
        const i = Math.cos(e), s = Math.sin(e), r = t.x, o = t.y;
        return {
          x: r + i * (n.x - r) - s * (n.y - o),
          y: o + s * (n.x - r) + i * (n.y - o)
        };
      }
      const WC = (n, t) => t > n || n.length > t.length && n.slice(0, t.length) === t, ss = 1e-3, hl = (n, t, e) => Math.min(e, Math.max(t, n)), Yg = (n, t) => n.value >= n.start - t && n.value <= n.end + t;
      function GC(n, t, e) {
        for (const i of Object.keys(n)) n[i] = hl(n[i], t, e);
        return n;
      }
      function XC(n, t, e, i) {
        return !n || !t || e <= 0 ? false : Math.pow(n.x - t.x, 2) + Math.pow(n.y - t.y, 2) <= Math.pow(e + i, 2);
      }
      function jg(n, { x: t, y: e, x2: i, y2: s }, r, { borderWidth: o, hitTolerance: a }) {
        const l = (o + a) / 2, c = n.x >= t - l - ss && n.x <= i + l + ss, h = n.y >= e - l - ss && n.y <= s + l + ss;
        return r === "x" ? c : (r === "y" || c) && h;
      }
      function qg(n, { rect: t, center: e }, i, { rotation: s, borderWidth: r, hitTolerance: o }) {
        const a = gs(n, e, ke(-s));
        return jg(a, t, i, {
          borderWidth: r,
          hitTolerance: o
        });
      }
      function _s(n, t) {
        const { centerX: e, centerY: i } = n.getProps([
          "centerX",
          "centerY"
        ], t);
        return {
          x: e,
          y: i
        };
      }
      function YC(n, t, e, i = true) {
        const s = e.split(".");
        let r = 0;
        for (const o of t.split(".")) {
          const a = s[r++];
          if (parseInt(o, 10) < parseInt(a, 10)) break;
          if (WC(a, o)) {
            if (i) throw new Error(`${n} v${e} is not supported. v${t} or newer is required.`);
            return false;
          }
        }
        return true;
      }
      const $g = (n) => typeof n == "string" && n.endsWith("%"), Kg = (n) => parseFloat(n) / 100, Zg = (n) => hl(Kg(n), 0, 1), Rr = (n, t) => ({
        x: n,
        y: t,
        x2: n,
        y2: t,
        width: 0,
        height: 0
      }), jC = {
        box: (n) => Rr(n.centerX, n.centerY),
        doughnutLabel: (n) => Rr(n.centerX, n.centerY),
        ellipse: (n) => ({
          centerX: n.centerX,
          centerY: n.centerX,
          radius: 0,
          width: 0,
          height: 0
        }),
        label: (n) => Rr(n.centerX, n.centerY),
        line: (n) => Rr(n.x, n.y),
        point: (n) => ({
          centerX: n.centerX,
          centerY: n.centerY,
          radius: 0,
          width: 0,
          height: 0
        }),
        polygon: (n) => Rr(n.centerX, n.centerY)
      };
      function _u(n, t) {
        return t === "start" ? 0 : t === "end" ? n : $g(t) ? Zg(t) * n : n / 2;
      }
      function ki(n, t, e = true) {
        return typeof t == "number" ? t : $g(t) ? (e ? Zg(t) : Kg(t)) * n : n;
      }
      function qC(n, t) {
        const { x: e, width: i } = n, s = t.textAlign;
        return s === "center" ? e + i / 2 : s === "end" || s === "right" ? e + i : e;
      }
      function Qg(n, t, { borderWidth: e, position: i, xAdjust: s, yAdjust: r }, o) {
        const a = Wt(o), l = t.width + (a ? o.width : 0) + e, c = t.height + (a ? o.height : 0) + e, h = xu(i), u = Rp(n.x, l, s, h.x), d = Rp(n.y, c, r, h.y);
        return {
          x: u,
          y: d,
          x2: u + l,
          y2: d + c,
          width: l,
          height: c,
          centerX: u + l / 2,
          centerY: d + c / 2
        };
      }
      function xu(n, t = "center") {
        return Wt(n) ? {
          x: Ut(n.x, t),
          y: Ut(n.y, t)
        } : (n = Ut(n, t), {
          x: n,
          y: n
        });
      }
      const Jg = (n, t) => n && n.autoFit && t < 1;
      function t_(n, t) {
        const e = n.font, i = oe(e) ? e : [
          e
        ];
        return Jg(n, t) ? i.map(function(s) {
          const r = Te(s);
          return r.size = Math.floor(s.size * t), r.lineHeight = s.lineHeight, Te(r);
        }) : i.map((s) => Te(s));
      }
      function e_(n) {
        return n && (cn(n.xValue) || cn(n.yValue));
      }
      function Rp(n, t, e = 0, i) {
        return n - _u(t, i) + e;
      }
      function hr(n, t, e) {
        const i = e.init;
        if (i) {
          if (i === true) return i_(t, e);
        } else return;
        return $C(n, t, e);
      }
      function n_(n, t, e) {
        let i = false;
        return t.forEach((s) => {
          ln(n[s]) ? (i = true, e[s] = n[s]) : cn(e[s]) && delete e[s];
        }), i;
      }
      function i_(n, t) {
        const e = t.type || "line";
        return jC[e](n);
      }
      function $C(n, t, e) {
        const i = ce(e.init, [
          {
            chart: n,
            properties: t,
            options: e
          }
        ]);
        if (i === true) return i_(t, e);
        if (Wt(i)) return i;
      }
      const gc = /* @__PURE__ */ new Map(), KC = (n) => isNaN(n) || n <= 0, ZC = (n) => n.reduce(function(t, e) {
        return t += e.string, t;
      }, "");
      function ul(n) {
        if (n && typeof n == "object") {
          const t = n.toString();
          return t === "[object HTMLImageElement]" || t === "[object HTMLCanvasElement]";
        }
      }
      function dl(n, { x: t, y: e }, i) {
        i && (n.translate(t, e), n.rotate(ke(i)), n.translate(-t, -e));
      }
      function hi(n, t) {
        if (t && t.borderWidth) return n.lineCap = t.borderCapStyle || "butt", n.setLineDash(t.borderDash), n.lineDashOffset = t.borderDashOffset, n.lineJoin = t.borderJoinStyle || "miter", n.lineWidth = t.borderWidth, n.strokeStyle = t.borderColor, true;
      }
      function ur(n, t) {
        n.shadowColor = t.backgroundShadowColor, n.shadowBlur = t.shadowBlur, n.shadowOffsetX = t.shadowOffsetX, n.shadowOffsetY = t.shadowOffsetY;
      }
      function fl(n, t) {
        const e = t.content;
        if (ul(e)) return {
          width: ki(e.width, t.width),
          height: ki(e.height, t.height)
        };
        const i = t_(t), s = t.textStrokeWidth, r = oe(e) ? e : [
          e
        ], o = r.join() + ZC(i) + s + (n._measureText ? "-spriting" : "");
        return gc.has(o) || gc.set(o, eR(n, r, i, s)), gc.get(o);
      }
      function s_(n, t, e) {
        const { x: i, y: s, width: r, height: o } = t;
        n.save(), ur(n, e);
        const a = hi(n, e);
        n.fillStyle = e.backgroundColor, n.beginPath(), sr(n, {
          x: i,
          y: s,
          w: r,
          h: o,
          radius: GC(Ci(e.borderRadius), 0, Math.min(r, o) / 2)
        }), n.closePath(), n.fill(), a && (n.shadowColor = e.borderShadowColor, n.stroke()), n.restore();
      }
      function r_(n, t, e, i) {
        const s = e.content;
        if (ul(s)) {
          n.save(), n.globalAlpha = sR(e.opacity, s.style.opacity), n.drawImage(s, t.x, t.y, t.width, t.height), n.restore();
          return;
        }
        const r = oe(s) ? s : [
          s
        ], o = t_(e, i), a = e.color, l = oe(a) ? a : [
          a
        ], c = qC(t, e), h = t.y + e.textStrokeWidth / 2;
        n.save(), n.textBaseline = "middle", n.textAlign = e.textAlign, QC(n, e) && nR(n, {
          x: c,
          y: h
        }, r, o), iR(n, {
          x: c,
          y: h
        }, r, {
          fonts: o,
          colors: l
        }), n.restore();
      }
      function QC(n, t) {
        if (t.textStrokeWidth > 0) return n.lineJoin = "round", n.miterLimit = 2, n.lineWidth = t.textStrokeWidth, n.strokeStyle = t.textStrokeColor, true;
      }
      function JC(n, t, e, i) {
        const { radius: s, options: r } = t, o = r.pointStyle, a = r.rotation;
        let l = (a || 0) * nu;
        if (ul(o)) {
          n.save(), n.translate(e, i), n.rotate(l), n.drawImage(o, -o.width / 2, -o.height / 2, o.width, o.height), n.restore();
          return;
        }
        KC(s) || tR(n, {
          x: e,
          y: i,
          radius: s,
          rotation: a,
          style: o,
          rad: l
        });
      }
      function tR(n, { x: t, y: e, radius: i, rotation: s, style: r, rad: o }) {
        let a, l, c, h;
        switch (n.beginPath(), r) {
          default:
            n.arc(t, e, i, 0, ge), n.closePath();
            break;
          case "triangle":
            n.moveTo(t + Math.sin(o) * i, e - Math.cos(o) * i), o += Va, n.lineTo(t + Math.sin(o) * i, e - Math.cos(o) * i), o += Va, n.lineTo(t + Math.sin(o) * i, e - Math.cos(o) * i), n.closePath();
            break;
          case "rectRounded":
            h = i * 0.516, c = i - h, a = Math.cos(o + wn) * c, l = Math.sin(o + wn) * c, n.arc(t - a, e - l, h, o - Zt, o - xe), n.arc(t + l, e - a, h, o - xe, o), n.arc(t + a, e + l, h, o, o + xe), n.arc(t - l, e + a, h, o + xe, o + Zt), n.closePath();
            break;
          case "rect":
            if (!s) {
              c = Math.SQRT1_2 * i, n.rect(t - c, e - c, 2 * c, 2 * c);
              break;
            }
            o += wn;
          case "rectRot":
            a = Math.cos(o) * i, l = Math.sin(o) * i, n.moveTo(t - a, e - l), n.lineTo(t + l, e - a), n.lineTo(t + a, e + l), n.lineTo(t - l, e + a), n.closePath();
            break;
          case "crossRot":
            o += wn;
          case "cross":
            a = Math.cos(o) * i, l = Math.sin(o) * i, n.moveTo(t - a, e - l), n.lineTo(t + a, e + l), n.moveTo(t + l, e - a), n.lineTo(t - l, e + a);
            break;
          case "star":
            a = Math.cos(o) * i, l = Math.sin(o) * i, n.moveTo(t - a, e - l), n.lineTo(t + a, e + l), n.moveTo(t + l, e - a), n.lineTo(t - l, e + a), o += wn, a = Math.cos(o) * i, l = Math.sin(o) * i, n.moveTo(t - a, e - l), n.lineTo(t + a, e + l), n.moveTo(t + l, e - a), n.lineTo(t - l, e + a);
            break;
          case "line":
            a = Math.cos(o) * i, l = Math.sin(o) * i, n.moveTo(t - a, e - l), n.lineTo(t + a, e + l);
            break;
          case "dash":
            n.moveTo(t, e), n.lineTo(t + Math.cos(o) * i, e + Math.sin(o) * i);
            break;
        }
        n.fill();
      }
      function eR(n, t, e, i) {
        n.save();
        const s = t.length;
        let r = 0, o = i;
        for (let a = 0; a < s; a++) {
          const l = e[Math.min(a, e.length - 1)];
          n.font = l.string;
          const c = t[a];
          r = Math.max(r, n.measureText(c).width + i), o += l.lineHeight;
        }
        return n.restore(), {
          width: r,
          height: o
        };
      }
      function nR(n, { x: t, y: e }, i, s) {
        n.beginPath();
        let r = 0;
        i.forEach(function(o, a) {
          const l = s[Math.min(a, s.length - 1)], c = l.lineHeight;
          n.font = l.string, n.strokeText(o, t, e + c / 2 + r), r += c;
        }), n.stroke();
      }
      function iR(n, { x: t, y: e }, i, { fonts: s, colors: r }) {
        let o = 0;
        i.forEach(function(a, l) {
          const c = r[Math.min(l, r.length - 1)], h = s[Math.min(l, s.length - 1)], u = h.lineHeight;
          n.beginPath(), n.font = h.string, n.fillStyle = c, n.fillText(a, t, e + u / 2 + o), o += u, n.fill();
        });
      }
      function sR(n, t) {
        const e = Oi(n) ? n : t;
        return Oi(e) ? hl(e, 0, 1) : 1;
      }
      const o_ = [
        "left",
        "bottom",
        "top",
        "right"
      ];
      function rR(n, t) {
        const { pointX: e, pointY: i, options: s } = t, r = s.callout, o = r && r.display && hR(t, r);
        if (!o || dR(t, r, o)) return;
        if (n.save(), n.beginPath(), !hi(n, r)) return n.restore();
        const { separatorStart: l, separatorEnd: c } = oR(t, o), { sideStart: h, sideEnd: u } = lR(t, o, l);
        (r.margin > 0 || s.borderWidth === 0) && (n.moveTo(l.x, l.y), n.lineTo(c.x, c.y)), n.moveTo(h.x, h.y), n.lineTo(u.x, u.y);
        const d = gs({
          x: e,
          y: i
        }, t.getCenterPoint(), ke(-t.rotation));
        n.lineTo(d.x, d.y), n.stroke(), n.restore();
      }
      function oR(n, t) {
        const { x: e, y: i, x2: s, y2: r } = n, o = aR(n, t);
        let a, l;
        return t === "left" || t === "right" ? (a = {
          x: e + o,
          y: i
        }, l = {
          x: a.x,
          y: r
        }) : (a = {
          x: e,
          y: i + o
        }, l = {
          x: s,
          y: a.y
        }), {
          separatorStart: a,
          separatorEnd: l
        };
      }
      function aR(n, t) {
        const { width: e, height: i, options: s } = n, r = s.callout.margin + s.borderWidth / 2;
        return t === "right" ? e + r : t === "bottom" ? i + r : -r;
      }
      function lR(n, t, e) {
        const { y: i, width: s, height: r, options: o } = n, a = o.callout.start, l = cR(t, o.callout);
        let c, h;
        return t === "left" || t === "right" ? (c = {
          x: e.x,
          y: i + ki(r, a)
        }, h = {
          x: c.x + l,
          y: c.y
        }) : (c = {
          x: e.x + ki(s, a),
          y: e.y
        }, h = {
          x: c.x,
          y: c.y + l
        }), {
          sideStart: c,
          sideEnd: h
        };
      }
      function cR(n, t) {
        const e = t.side;
        return n === "left" || n === "top" ? -e : e;
      }
      function hR(n, t) {
        const e = t.position;
        return o_.includes(e) ? e : uR(n, t);
      }
      function uR(n, t) {
        const { x: e, y: i, x2: s, y2: r, width: o, height: a, pointX: l, pointY: c, centerX: h, centerY: u, rotation: d } = n, f = {
          x: h,
          y: u
        }, g = t.start, _ = ki(o, g), m = ki(a, g), p = [
          e,
          e + _,
          e + _,
          s
        ], y = [
          i + m,
          r,
          i,
          r
        ], w = [];
        for (let M = 0; M < 4; M++) {
          const C = gs({
            x: p[M],
            y: y[M]
          }, f, ke(d));
          w.push({
            position: o_[M],
            distance: ir(C, {
              x: l,
              y: c
            })
          });
        }
        return w.sort((M, C) => M.distance - C.distance)[0].position;
      }
      function dR(n, t, e) {
        const { pointX: i, pointY: s } = n, r = t.margin;
        let o = i, a = s;
        return e === "left" ? o += r : e === "right" ? o -= r : e === "top" ? a += r : e === "bottom" && (a -= r), n.inRange(o, a);
      }
      const Pp = {
        xScaleID: {
          min: "xMin",
          max: "xMax",
          start: "left",
          end: "right",
          startProp: "x",
          endProp: "x2"
        },
        yScaleID: {
          min: "yMin",
          max: "yMax",
          start: "bottom",
          end: "top",
          startProp: "y",
          endProp: "y2"
        }
      };
      function ar(n, t, e) {
        return t = typeof t == "number" ? t : n.parse(t), Me(t) ? n.getPixelForValue(t) : e;
      }
      function ds(n, t, e) {
        const i = t[e];
        if (i || e === "scaleID") return i;
        const s = e.charAt(0), r = Object.values(n).filter((o) => o.axis && o.axis === s);
        return r.length ? r[0].id : s;
      }
      function a_(n, t) {
        if (n) {
          const e = n.options.reverse, i = ar(n, t.min, e ? t.end : t.start), s = ar(n, t.max, e ? t.start : t.end);
          return {
            start: i,
            end: s
          };
        }
      }
      function l_(n, t) {
        const { chartArea: e, scales: i } = n, s = i[ds(i, t, "xScaleID")], r = i[ds(i, t, "yScaleID")];
        let o = e.width / 2, a = e.height / 2;
        return s && (o = ar(s, t.xValue, s.left + s.width / 2)), r && (a = ar(r, t.yValue, r.top + r.height / 2)), {
          x: o,
          y: a
        };
      }
      function bu(n, t) {
        const e = n.scales, i = e[ds(e, t, "xScaleID")], s = e[ds(e, t, "yScaleID")];
        if (!i && !s) return {};
        let { left: r, right: o } = i || n.chartArea, { top: a, bottom: l } = s || n.chartArea;
        const c = Dp(i, {
          min: t.xMin,
          max: t.xMax,
          start: r,
          end: o
        });
        r = c.start, o = c.end;
        const h = Dp(s, {
          min: t.yMin,
          max: t.yMax,
          start: l,
          end: a
        });
        return a = h.start, l = h.end, {
          x: r,
          y: a,
          x2: o,
          y2: l,
          width: o - r,
          height: l - a,
          centerX: r + (o - r) / 2,
          centerY: a + (l - a) / 2
        };
      }
      function c_(n, t) {
        if (!e_(t)) {
          const e = bu(n, t);
          let i = t.radius;
          (!i || isNaN(i)) && (i = Math.min(e.width, e.height) / 2, t.radius = i);
          const s = i * 2, r = e.centerX + t.xAdjust, o = e.centerY + t.yAdjust;
          return {
            x: r - i,
            y: o - i,
            x2: r + i,
            y2: o + i,
            centerX: r,
            centerY: o,
            width: s,
            height: s,
            radius: i
          };
        }
        return pR(n, t);
      }
      function fR(n, t) {
        const { scales: e, chartArea: i } = n, s = e[t.scaleID], r = {
          x: i.left,
          y: i.top,
          x2: i.right,
          y2: i.bottom
        };
        return s ? mR(s, r, t) : gR(e, r, t), r;
      }
      function h_(n, t) {
        const e = bu(n, t);
        return e.initProperties = hr(n, e, t), e.elements = [
          {
            type: "label",
            optionScope: "label",
            properties: bR(n, e, t),
            initProperties: e.initProperties
          }
        ], e;
      }
      function pR(n, t) {
        const e = l_(n, t), i = t.radius * 2;
        return {
          x: e.x - t.radius + t.xAdjust,
          y: e.y - t.radius + t.yAdjust,
          x2: e.x + t.radius + t.xAdjust,
          y2: e.y + t.radius + t.yAdjust,
          centerX: e.x + t.xAdjust,
          centerY: e.y + t.yAdjust,
          radius: t.radius,
          width: i,
          height: i
        };
      }
      function Dp(n, t) {
        const e = a_(n, t) || t;
        return {
          start: Math.min(e.start, e.end),
          end: Math.max(e.start, e.end)
        };
      }
      function mR(n, t, e) {
        const i = ar(n, e.value, NaN), s = ar(n, e.endValue, i);
        n.isHorizontal() ? (t.x = i, t.x2 = s) : (t.y = i, t.y2 = s);
      }
      function gR(n, t, e) {
        for (const i of Object.keys(Pp)) {
          const s = n[ds(n, e, i)];
          if (s) {
            const { min: r, max: o, start: a, end: l, startProp: c, endProp: h } = Pp[i], u = a_(s, {
              min: e[r],
              max: e[o],
              start: s[a],
              end: s[l]
            });
            t[c] = u.start, t[h] = u.end;
          }
        }
      }
      function _R({ properties: n, options: t }, e, i, s) {
        const { x: r, x2: o, width: a } = n;
        return u_({
          start: r,
          end: o,
          borderWidth: t.borderWidth
        }, {
          position: i.x,
          padding: {
            start: s.left,
            end: s.right
          },
          adjust: t.label.xAdjust,
          size: e.width
        });
      }
      function xR({ properties: n, options: t }, e, i, s) {
        const { y: r, y2: o, height: a } = n;
        return u_({
          start: r,
          end: o,
          borderWidth: t.borderWidth
        }, {
          position: i.y,
          padding: {
            start: s.top,
            end: s.bottom
          },
          adjust: t.label.yAdjust,
          size: e.height
        });
      }
      function u_(n, t) {
        const { start: e, end: i, borderWidth: s } = n, { position: r, padding: { start: o, end: a }, adjust: l } = t, c = i - s - e - o - a - t.size;
        return e + s / 2 + l + _u(c, r);
      }
      function bR(n, t, e) {
        const i = e.label;
        i.backgroundColor = "transparent", i.callout.display = false;
        const s = xu(i.position), r = Fe(i.padding), o = fl(n.ctx, i), a = _R({
          properties: t,
          options: e
        }, o, s, r), l = xR({
          properties: t,
          options: e
        }, o, s, r), c = o.width + r.width, h = o.height + r.height;
        return {
          x: a,
          y: l,
          x2: a + c,
          y2: l + h,
          width: c,
          height: h,
          centerX: a + c / 2,
          centerY: l + h / 2,
          rotation: i.rotation
        };
      }
      const Mh = [
        "enter",
        "leave"
      ], yu = Mh.concat("click");
      function yR(n, t, e) {
        t.listened = n_(e, yu, t.listeners), t.moveListened = false, Mh.forEach((i) => {
          ln(e[i]) && (t.moveListened = true);
        }), (!t.listened || !t.moveListened) && t.annotations.forEach((i) => {
          !t.listened && ln(i.click) && (t.listened = true), t.moveListened || Mh.forEach((s) => {
            ln(i[s]) && (t.listened = true, t.moveListened = true);
          });
        });
      }
      function vR(n, t, e) {
        if (n.listened) switch (t.type) {
          case "mousemove":
          case "mouseout":
            return MR(n, t, e);
          case "click":
            return SR(n, t, e);
        }
      }
      function MR(n, t, e) {
        if (!n.moveListened) return;
        let i;
        t.type === "mousemove" ? i = gu(n.visibleElements, t, e.interaction) : i = [];
        const s = n.hovered;
        n.hovered = i;
        const r = {
          state: n,
          event: t
        };
        let o = Lp(r, "leave", s, i);
        return Lp(r, "enter", i, s) || o;
      }
      function Lp({ state: n, event: t }, e, i, s) {
        let r;
        for (const o of i) s.indexOf(o) < 0 && (r = d_(o.options[e] || n.listeners[e], o, t) || r);
        return r;
      }
      function SR(n, t, e) {
        const i = n.listeners, s = gu(n.visibleElements, t, e.interaction);
        let r;
        for (const o of s) r = d_(o.options.click || i.click, o, t) || r;
        return r;
      }
      function d_(n, t, e) {
        return ce(n, [
          t.$context,
          e
        ]) === true;
      }
      const $a = [
        "afterDraw",
        "beforeDraw"
      ];
      function wR(n, t, e) {
        const i = t.visibleElements;
        t.hooked = n_(e, $a, t.hooks), t.hooked || i.forEach((s) => {
          t.hooked || $a.forEach((r) => {
            ln(s.options[r]) && (t.hooked = true);
          });
        });
      }
      function Ip(n, t, e) {
        if (n.hooked) {
          const i = t.options[e] || n.hooks[e];
          return ce(i, [
            t.$context
          ]);
        }
      }
      function ER(n, t, e) {
        const i = PR(n.scales, t, e);
        let s = Op(t, i, "min", "suggestedMin");
        s = Op(t, i, "max", "suggestedMax") || s, s && ln(t.handleTickRangeOptions) && t.handleTickRangeOptions();
      }
      function TR(n, t) {
        for (const e of n) CR(e, t);
      }
      function Op(n, t, e, i) {
        if (Me(t[e]) && !AR(n.options, e, i)) {
          const s = n[e] !== t[e];
          return n[e] = t[e], s;
        }
      }
      function AR(n, t, e) {
        return cn(n[t]) || cn(n[e]);
      }
      function CR(n, t) {
        for (const e of [
          "scaleID",
          "xScaleID",
          "yScaleID"
        ]) {
          const i = ds(t, n, e);
          i && !t[i] && RR(n, e) && console.warn(`No scale found with id '${i}' for annotation '${n.id}'`);
        }
      }
      function RR(n, t) {
        if (t === "scaleID") return true;
        const e = t.charAt(0);
        for (const i of [
          "Min",
          "Max",
          "Value"
        ]) if (cn(n[e + i])) return true;
        return false;
      }
      function PR(n, t, e) {
        const i = t.axis, s = t.id, r = i + "ScaleID", o = {
          min: Ut(t.min, Number.NEGATIVE_INFINITY),
          max: Ut(t.max, Number.POSITIVE_INFINITY)
        };
        for (const a of e) a.scaleID === s ? kp(a, t, [
          "value",
          "endValue"
        ], o) : ds(n, a, r) === s && kp(a, t, [
          i + "Min",
          i + "Max",
          i + "Value"
        ], o);
        return o;
      }
      function kp(n, t, e, i) {
        for (const s of e) {
          const r = n[s];
          if (cn(r)) {
            const o = t.parse(r);
            i.min = Math.min(i.min, o), i.max = Math.max(i.max, o);
          }
        }
      }
      class dr extends Ke {
        inRange(t, e, i, s) {
          const { x: r, y: o } = gs({
            x: t,
            y: e
          }, this.getCenterPoint(s), ke(-this.options.rotation));
          return jg({
            x: r,
            y: o
          }, this.getProps([
            "x",
            "y",
            "x2",
            "y2"
          ], s), i, this.options);
        }
        getCenterPoint(t) {
          return _s(this, t);
        }
        draw(t) {
          t.save(), dl(t, this.getCenterPoint(), this.options.rotation), s_(t, this, this.options), t.restore();
        }
        get label() {
          return this.elements && this.elements[0];
        }
        resolveElementProperties(t, e) {
          return h_(t, e);
        }
      }
      dr.id = "boxAnnotation";
      dr.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderRadius: 0,
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        init: void 0,
        hitTolerance: 0,
        label: {
          backgroundColor: "transparent",
          borderWidth: 0,
          callout: {
            display: false
          },
          color: "black",
          content: null,
          display: false,
          drawTime: void 0,
          font: {
            family: void 0,
            lineHeight: void 0,
            size: void 0,
            style: void 0,
            weight: "bold"
          },
          height: void 0,
          hitTolerance: void 0,
          opacity: void 0,
          padding: 6,
          position: "center",
          rotation: void 0,
          textAlign: "start",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          width: void 0,
          xAdjust: 0,
          yAdjust: 0,
          z: void 0
        },
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0
      };
      dr.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      dr.descriptors = {
        label: {
          _fallback: true
        }
      };
      class pl extends Ke {
        inRange(t, e, i, s) {
          return qg({
            x: t,
            y: e
          }, {
            rect: this.getProps([
              "x",
              "y",
              "x2",
              "y2"
            ], s),
            center: this.getCenterPoint(s)
          }, i, {
            rotation: this.rotation,
            borderWidth: 0,
            hitTolerance: this.options.hitTolerance
          });
        }
        getCenterPoint(t) {
          return _s(this, t);
        }
        draw(t) {
          const e = this.options;
          !e.display || !e.content || (FR(t, this), t.save(), dl(t, this.getCenterPoint(), this.rotation), r_(t, this, e, this._fitRatio), t.restore());
        }
        resolveElementProperties(t, e) {
          const i = DR(t, e);
          if (!i) return {};
          const { controllerMeta: s, point: r, radius: o } = IR(t, e, i);
          let a = fl(t.ctx, e);
          const l = OR(a, o);
          Jg(e, l) && (a = {
            width: a.width * l,
            height: a.height * l
          });
          const { position: c, xAdjust: h, yAdjust: u } = e, d = Qg(r, a, {
            borderWidth: 0,
            position: c,
            xAdjust: h,
            yAdjust: u
          });
          return {
            initProperties: hr(t, d, e),
            ...d,
            ...s,
            rotation: e.rotation,
            _fitRatio: l
          };
        }
      }
      pl.id = "doughnutLabelAnnotation";
      pl.defaults = {
        autoFit: true,
        autoHide: true,
        backgroundColor: "transparent",
        backgroundShadowColor: "transparent",
        borderColor: "transparent",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderShadowColor: "transparent",
        borderWidth: 0,
        color: "black",
        content: null,
        display: true,
        font: {
          family: void 0,
          lineHeight: void 0,
          size: void 0,
          style: void 0,
          weight: void 0
        },
        height: void 0,
        hitTolerance: 0,
        init: void 0,
        opacity: void 0,
        position: "center",
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        spacing: 1,
        textAlign: "center",
        textStrokeColor: void 0,
        textStrokeWidth: 0,
        width: void 0,
        xAdjust: 0,
        yAdjust: 0
      };
      pl.defaultRoutes = {};
      function DR(n, t) {
        return n.getSortedVisibleDatasetMetas().reduce(function(e, i) {
          const s = i.controller;
          return s instanceof ol && LR(n, t, i.data) && (!e || s.innerRadius < e.controller.innerRadius) && s.options.circumference >= 90 ? i : e;
        }, void 0);
      }
      function LR(n, t, e) {
        if (!t.autoHide) return true;
        for (let i = 0; i < e.length; i++) if (!e[i].hidden && n.getDataVisibility(i)) return true;
      }
      function IR({ chartArea: n }, t, e) {
        const { left: i, top: s, right: r, bottom: o } = n, { innerRadius: a, offsetX: l, offsetY: c } = e.controller, h = (i + r) / 2 + l, u = (s + o) / 2 + c, d = {
          left: Math.max(h - a, i),
          right: Math.min(h + a, r),
          top: Math.max(u - a, s),
          bottom: Math.min(u + a, o)
        }, f = {
          x: (d.left + d.right) / 2,
          y: (d.top + d.bottom) / 2
        }, g = t.spacing + t.borderWidth / 2, _ = a - g, m = f.y > u, p = m ? s + g : o - g, y = kR(p, h, u, _);
        return {
          controllerMeta: {
            _centerX: h,
            _centerY: u,
            _radius: _,
            _counterclockwise: m,
            ...y
          },
          point: f,
          radius: Math.min(a, Math.min(d.right - d.left, d.bottom - d.top) / 2)
        };
      }
      function OR({ width: n, height: t }, e) {
        const i = Math.sqrt(Math.pow(n, 2) + Math.pow(t, 2));
        return e * 2 / i;
      }
      function kR(n, t, e, i) {
        const s = Math.pow(e - n, 2), r = Math.pow(i, 2), o = t * -2, a = Math.pow(t, 2) + s - r, l = Math.pow(o, 2) - 4 * a;
        if (l <= 0) return {
          _startAngle: 0,
          _endAngle: ge
        };
        const c = (-o - Math.sqrt(l)) / 2, h = (-o + Math.sqrt(l)) / 2;
        return {
          _startAngle: Wa({
            x: t,
            y: e
          }, {
            x: c,
            y: n
          }).angle,
          _endAngle: Wa({
            x: t,
            y: e
          }, {
            x: h,
            y: n
          }).angle
        };
      }
      function FR(n, t) {
        const { _centerX: e, _centerY: i, _radius: s, _startAngle: r, _endAngle: o, _counterclockwise: a, options: l } = t;
        n.save();
        const c = hi(n, l);
        n.fillStyle = l.backgroundColor, n.beginPath(), n.arc(e, i, s, r, o, a), n.closePath(), n.fill(), c && n.stroke(), n.restore();
      }
      class po extends Ke {
        inRange(t, e, i, s) {
          return qg({
            x: t,
            y: e
          }, {
            rect: this.getProps([
              "x",
              "y",
              "x2",
              "y2"
            ], s),
            center: this.getCenterPoint(s)
          }, i, {
            rotation: this.rotation,
            borderWidth: this.options.borderWidth,
            hitTolerance: this.options.hitTolerance
          });
        }
        getCenterPoint(t) {
          return _s(this, t);
        }
        draw(t) {
          const e = this.options, i = !cn(this._visible) || this._visible;
          !e.display || !e.content || !i || (t.save(), dl(t, this.getCenterPoint(), this.rotation), rR(t, this), s_(t, this, e), r_(t, NR(this), e), t.restore());
        }
        resolveElementProperties(t, e) {
          let i;
          if (e_(e)) i = l_(t, e);
          else {
            const { centerX: a, centerY: l } = bu(t, e);
            i = {
              x: a,
              y: l
            };
          }
          const s = Fe(e.padding), r = fl(t.ctx, e), o = Qg(i, r, e, s);
          return {
            initProperties: hr(t, o, e),
            pointX: i.x,
            pointY: i.y,
            ...o,
            rotation: e.rotation
          };
        }
      }
      po.id = "labelAnnotation";
      po.defaults = {
        adjustScaleRange: true,
        backgroundColor: "transparent",
        backgroundShadowColor: "transparent",
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderRadius: 0,
        borderShadowColor: "transparent",
        borderWidth: 0,
        callout: {
          borderCapStyle: "butt",
          borderColor: void 0,
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderWidth: 1,
          display: false,
          margin: 5,
          position: "auto",
          side: 5,
          start: "50%"
        },
        color: "black",
        content: null,
        display: true,
        font: {
          family: void 0,
          lineHeight: void 0,
          size: void 0,
          style: void 0,
          weight: void 0
        },
        height: void 0,
        hitTolerance: 0,
        init: void 0,
        opacity: void 0,
        padding: 6,
        position: "center",
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        textAlign: "center",
        textStrokeColor: void 0,
        textStrokeWidth: 0,
        width: void 0,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0
      };
      po.defaultRoutes = {
        borderColor: "color"
      };
      function NR({ x: n, y: t, width: e, height: i, options: s }) {
        const r = s.borderWidth / 2, o = Fe(s.padding);
        return {
          x: n + o.left + r,
          y: t + o.top + r,
          width: e - o.left - o.right - s.borderWidth,
          height: i - o.top - o.bottom - s.borderWidth
        };
      }
      const vu = (n, t, e) => ({
        x: n.x + e * (t.x - n.x),
        y: n.y + e * (t.y - n.y)
      }), Sh = (n, t, e) => vu(t, e, Math.abs((n - t.y) / (e.y - t.y))).x, Fp = (n, t, e) => vu(t, e, Math.abs((n - t.x) / (e.x - t.x))).y, zr = (n) => n * n, UR = (n, t, { x: e, y: i, x2: s, y2: r }, o) => o === "y" ? {
        start: Math.min(i, r),
        end: Math.max(i, r),
        value: t
      } : {
        start: Math.min(e, s),
        end: Math.max(e, s),
        value: n
      }, Np = (n, t, e, i) => (1 - i) * (1 - i) * n + 2 * (1 - i) * i * t + i * i * e, wh = (n, t, e, i) => ({
        x: Np(n.x, t.x, e.x, i),
        y: Np(n.y, t.y, e.y, i)
      }), Up = (n, t, e, i) => 2 * (1 - i) * (t - n) + 2 * i * (e - t), Bp = (n, t, e, i) => -Math.atan2(Up(n.x, t.x, e.x, i), Up(n.y, t.y, e.y, i)) + 0.5 * Zt;
      class mo extends Ke {
        inRange(t, e, i, s) {
          const r = (this.options.borderWidth + this.options.hitTolerance) / 2;
          if (i !== "x" && i !== "y") {
            const o = {
              mouseX: t,
              mouseY: e
            }, { path: a, ctx: l } = this;
            if (a) {
              hi(l, this.options), l.lineWidth += this.options.hitTolerance;
              const { chart: h } = this.$context, u = t * h.currentDevicePixelRatio, d = e * h.currentDevicePixelRatio, f = l.isPointInStroke(a, u, d) || Eh(this, o, s);
              return l.restore(), f;
            }
            const c = zr(r);
            return VR(this, o, c, s) || Eh(this, o, s);
          }
          return BR(this, {
            mouseX: t,
            mouseY: e
          }, i, {
            hitSize: r,
            useFinalPosition: s
          });
        }
        getCenterPoint(t) {
          return _s(this, t);
        }
        draw(t) {
          const { x: e, y: i, x2: s, y2: r, cp: o, options: a } = this;
          if (t.save(), !hi(t, a)) return t.restore();
          ur(t, a);
          const l = Math.sqrt(Math.pow(s - e, 2) + Math.pow(r - i, 2));
          if (a.curve && o) return KR(t, this, o, l), t.restore();
          const { startOpts: c, endOpts: h, startAdjust: u, endAdjust: d } = f_(this), f = Math.atan2(r - i, s - e);
          t.translate(e, i), t.rotate(f), t.beginPath(), t.moveTo(0 + u, 0), t.lineTo(l - d, 0), t.shadowColor = a.borderShadowColor, t.stroke(), Th(t, 0, u, c), Th(t, l, -d, h), t.restore();
        }
        get label() {
          return this.elements && this.elements[0];
        }
        resolveElementProperties(t, e) {
          const i = fR(t, e), { x: s, y: r, x2: o, y2: a } = i, l = zR(i, t.chartArea), c = l ? HR({
            x: s,
            y: r
          }, {
            x: o,
            y: a
          }, t.chartArea) : {
            x: s,
            y: r,
            x2: o,
            y2: a,
            width: Math.abs(o - s),
            height: Math.abs(a - r)
          };
          if (c.centerX = (o + s) / 2, c.centerY = (a + r) / 2, c.initProperties = hr(t, c, e), e.curve) {
            const u = {
              x: c.x,
              y: c.y
            }, d = {
              x: c.x2,
              y: c.y2
            };
            c.cp = $R(c, e, ir(u, d));
          }
          const h = WR(t, c, e.label);
          return h._visible = l, c.elements = [
            {
              type: "label",
              optionScope: "label",
              properties: h,
              initProperties: c.initProperties
            }
          ], c;
        }
      }
      mo.id = "lineAnnotation";
      const zp = {
        backgroundColor: void 0,
        backgroundShadowColor: void 0,
        borderColor: void 0,
        borderDash: void 0,
        borderDashOffset: void 0,
        borderShadowColor: void 0,
        borderWidth: void 0,
        display: void 0,
        fill: void 0,
        length: void 0,
        shadowBlur: void 0,
        shadowOffsetX: void 0,
        shadowOffsetY: void 0,
        width: void 0
      };
      mo.defaults = {
        adjustScaleRange: true,
        arrowHeads: {
          display: false,
          end: Object.assign({}, zp),
          fill: false,
          length: 12,
          start: Object.assign({}, zp),
          width: 6
        },
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: "transparent",
        borderWidth: 2,
        curve: false,
        controlPoint: {
          y: "-50%"
        },
        display: true,
        endValue: void 0,
        init: void 0,
        hitTolerance: 0,
        label: {
          backgroundColor: "rgba(0,0,0,0.8)",
          backgroundShadowColor: "transparent",
          borderCapStyle: "butt",
          borderColor: "black",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderRadius: 6,
          borderShadowColor: "transparent",
          borderWidth: 0,
          callout: Object.assign({}, po.defaults.callout),
          color: "#fff",
          content: null,
          display: false,
          drawTime: void 0,
          font: {
            family: void 0,
            lineHeight: void 0,
            size: void 0,
            style: void 0,
            weight: "bold"
          },
          height: void 0,
          hitTolerance: void 0,
          opacity: void 0,
          padding: 6,
          position: "center",
          rotation: 0,
          shadowBlur: 0,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          textAlign: "center",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          width: void 0,
          xAdjust: 0,
          yAdjust: 0,
          z: void 0
        },
        scaleID: void 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        value: void 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0
      };
      mo.descriptors = {
        arrowHeads: {
          start: {
            _fallback: true
          },
          end: {
            _fallback: true
          },
          _fallback: true
        }
      };
      mo.defaultRoutes = {
        borderColor: "color"
      };
      function BR(n, { mouseX: t, mouseY: e }, i, { hitSize: s, useFinalPosition: r }) {
        const o = UR(t, e, n.getProps([
          "x",
          "y",
          "x2",
          "y2"
        ], r), i);
        return Yg(o, s) || Eh(n, {
          mouseX: t,
          mouseY: e
        }, r, i);
      }
      function zR({ x: n, y: t, x2: e, y2: i }, { top: s, right: r, bottom: o, left: a }) {
        return !(n < a && e < a || n > r && e > r || t < s && i < s || t > o && i > o);
      }
      function Hp({ x: n, y: t }, e, { top: i, right: s, bottom: r, left: o }) {
        return n < o && (t = Fp(o, {
          x: n,
          y: t
        }, e), n = o), n > s && (t = Fp(s, {
          x: n,
          y: t
        }, e), n = s), t < i && (n = Sh(i, {
          x: n,
          y: t
        }, e), t = i), t > r && (n = Sh(r, {
          x: n,
          y: t
        }, e), t = r), {
          x: n,
          y: t
        };
      }
      function HR(n, t, e) {
        const { x: i, y: s } = Hp(n, t, e), { x: r, y: o } = Hp(t, n, e);
        return {
          x: i,
          y: s,
          x2: r,
          y2: o,
          width: Math.abs(r - i),
          height: Math.abs(o - s)
        };
      }
      function VR(n, { mouseX: t, mouseY: e }, i = ss, s) {
        const { x: r, y: o, x2: a, y2: l } = n.getProps([
          "x",
          "y",
          "x2",
          "y2"
        ], s), c = a - r, h = l - o, u = zr(c) + zr(h), d = u === 0 ? -1 : ((t - r) * c + (e - o) * h) / u;
        let f, g;
        return d < 0 ? (f = r, g = o) : d > 1 ? (f = a, g = l) : (f = r + d * c, g = o + d * h), zr(t - f) + zr(e - g) <= i;
      }
      function Eh(n, { mouseX: t, mouseY: e }, i, s) {
        const r = n.label;
        return r.options.display && r.inRange(t, e, s, i);
      }
      function WR(n, t, e) {
        const i = e.borderWidth, s = Fe(e.padding), r = fl(n.ctx, e), o = r.width + s.width + i, a = r.height + s.height + i;
        return XR(t, e, {
          width: o,
          height: a,
          padding: s
        }, n.chartArea);
      }
      function GR(n) {
        const { x: t, y: e, x2: i, y2: s } = n, r = Math.atan2(s - e, i - t);
        return r > Zt / 2 ? r - Zt : r < Zt / -2 ? r + Zt : r;
      }
      function XR(n, t, e, i) {
        const { width: s, height: r, padding: o } = e, { xAdjust: a, yAdjust: l } = t, c = {
          x: n.x,
          y: n.y
        }, h = {
          x: n.x2,
          y: n.y2
        }, u = t.rotation === "auto" ? GR(n) : ke(t.rotation), d = YR(s, r, u), f = jR(n, t, {
          labelSize: d,
          padding: o
        }, i), g = n.cp ? wh(c, n.cp, h, f) : vu(c, h, f), _ = {
          size: d.w,
          min: i.left,
          max: i.right,
          padding: o.left
        }, m = {
          size: d.h,
          min: i.top,
          max: i.bottom,
          padding: o.top
        }, p = Wp(g.x, _) + a, y = Wp(g.y, m) + l;
        return {
          x: p - s / 2,
          y: y - r / 2,
          x2: p + s / 2,
          y2: y + r / 2,
          centerX: p,
          centerY: y,
          pointX: g.x,
          pointY: g.y,
          width: s,
          height: r,
          rotation: il(u)
        };
      }
      function YR(n, t, e) {
        const i = Math.cos(e), s = Math.sin(e);
        return {
          w: Math.abs(n * i) + Math.abs(t * s),
          h: Math.abs(n * s) + Math.abs(t * i)
        };
      }
      function jR(n, t, e, i) {
        let s;
        const r = qR(n, i);
        return t.position === "start" ? s = Vp({
          w: n.x2 - n.x,
          h: n.y2 - n.y
        }, e, t, r) : t.position === "end" ? s = 1 - Vp({
          w: n.x - n.x2,
          h: n.y - n.y2
        }, e, t, r) : s = _u(1, t.position), s;
      }
      function Vp(n, t, e, i) {
        const { labelSize: s, padding: r } = t, o = n.w * i.dx, a = n.h * i.dy, l = o > 0 && (s.w / 2 + r.left - i.x) / o, c = a > 0 && (s.h / 2 + r.top - i.y) / a;
        return hl(Math.max(l, c), 0, 0.25);
      }
      function qR(n, t) {
        const { x: e, x2: i, y: s, y2: r } = n, o = Math.min(s, r) - t.top, a = Math.min(e, i) - t.left, l = t.bottom - Math.max(s, r), c = t.right - Math.max(e, i);
        return {
          x: Math.min(a, c),
          y: Math.min(o, l),
          dx: a <= c ? 1 : -1,
          dy: o <= l ? 1 : -1
        };
      }
      function Wp(n, t) {
        const { size: e, min: i, max: s, padding: r } = t, o = e / 2;
        return e > s - i ? (s + i) / 2 : (i >= n - r - o && (n = i + r + o), s <= n + r + o && (n = s - r - o), n);
      }
      function f_(n) {
        const t = n.options, e = t.arrowHeads && t.arrowHeads.start, i = t.arrowHeads && t.arrowHeads.end;
        return {
          startOpts: e,
          endOpts: i,
          startAdjust: Gp(n, e),
          endAdjust: Gp(n, i)
        };
      }
      function Gp(n, t) {
        if (!t || !t.display) return 0;
        const { length: e, width: i } = t, s = n.options.borderWidth / 2, r = {
          x: e,
          y: i + s
        };
        return Math.abs(Sh(0, r, {
          x: 0,
          y: s
        }));
      }
      function Th(n, t, e, i) {
        if (!i || !i.display) return;
        const { length: s, width: r, fill: o, backgroundColor: a, borderColor: l } = i, c = Math.abs(t - s) + e;
        n.beginPath(), ur(n, i), hi(n, i), n.moveTo(c, -r), n.lineTo(t + e, 0), n.lineTo(c, r), o === true ? (n.fillStyle = a || l, n.closePath(), n.fill(), n.shadowColor = "transparent") : n.shadowColor = i.borderShadowColor, n.stroke();
      }
      function $R(n, t, e) {
        const { x: i, y: s, x2: r, y2: o, centerX: a, centerY: l } = n, c = Math.atan2(o - s, r - i), h = xu(t.controlPoint, 0), u = {
          x: a + ki(e, h.x, false),
          y: l + ki(e, h.y, false)
        };
        return gs(u, {
          x: a,
          y: l
        }, c);
      }
      function Xp(n, { x: t, y: e }, { angle: i, adjust: s }, r) {
        !r || !r.display || (n.save(), n.translate(t, e), n.rotate(i), Th(n, 0, -s, r), n.restore());
      }
      function KR(n, t, e, i) {
        const { x: s, y: r, x2: o, y2: a, options: l } = t, { startOpts: c, endOpts: h, startAdjust: u, endAdjust: d } = f_(t), f = {
          x: s,
          y: r
        }, g = {
          x: o,
          y: a
        }, _ = Bp(f, e, g, 0), m = Bp(f, e, g, 1) - Zt, p = wh(f, e, g, u / i), y = wh(f, e, g, 1 - d / i), w = new Path2D();
        n.beginPath(), w.moveTo(p.x, p.y), w.quadraticCurveTo(e.x, e.y, y.x, y.y), n.shadowColor = l.borderShadowColor, n.stroke(w), t.path = w, t.ctx = n, Xp(n, p, {
          angle: _,
          adjust: u
        }, c), Xp(n, y, {
          angle: m,
          adjust: d
        }, h);
      }
      class go extends Ke {
        inRange(t, e, i, s) {
          const r = this.options.rotation, o = (this.options.borderWidth + this.options.hitTolerance) / 2;
          if (i !== "x" && i !== "y") return ZR({
            x: t,
            y: e
          }, this.getProps([
            "width",
            "height",
            "centerX",
            "centerY"
          ], s), r, o);
          const { x: a, y: l, x2: c, y2: h } = this.getProps([
            "x",
            "y",
            "x2",
            "y2"
          ], s), u = i === "y" ? {
            start: l,
            end: h
          } : {
            start: a,
            end: c
          }, d = gs({
            x: t,
            y: e
          }, this.getCenterPoint(s), ke(-r));
          return d[i] >= u.start - o - ss && d[i] <= u.end + o + ss;
        }
        getCenterPoint(t) {
          return _s(this, t);
        }
        draw(t) {
          const { width: e, height: i, centerX: s, centerY: r, options: o } = this;
          t.save(), dl(t, this.getCenterPoint(), o.rotation), ur(t, this.options), t.beginPath(), t.fillStyle = o.backgroundColor;
          const a = hi(t, o);
          t.ellipse(s, r, i / 2, e / 2, Zt / 2, 0, 2 * Zt), t.fill(), a && (t.shadowColor = o.borderShadowColor, t.stroke()), t.restore();
        }
        get label() {
          return this.elements && this.elements[0];
        }
        resolveElementProperties(t, e) {
          return h_(t, e);
        }
      }
      go.id = "ellipseAnnotation";
      go.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        hitTolerance: 0,
        init: void 0,
        label: Object.assign({}, dr.defaults.label),
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0
      };
      go.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      go.descriptors = {
        label: {
          _fallback: true
        }
      };
      function ZR(n, t, e, i) {
        const { width: s, height: r, centerX: o, centerY: a } = t, l = s / 2, c = r / 2;
        if (l <= 0 || c <= 0) return false;
        const h = ke(e || 0), u = Math.cos(h), d = Math.sin(h), f = Math.pow(u * (n.x - o) + d * (n.y - a), 2), g = Math.pow(d * (n.x - o) - u * (n.y - a), 2);
        return f / Math.pow(l + i, 2) + g / Math.pow(c + i, 2) <= 1.0001;
      }
      class ml extends Ke {
        inRange(t, e, i, s) {
          const { x: r, y: o, x2: a, y2: l, width: c } = this.getProps([
            "x",
            "y",
            "x2",
            "y2",
            "width"
          ], s), h = (this.options.borderWidth + this.options.hitTolerance) / 2;
          return i !== "x" && i !== "y" ? XC({
            x: t,
            y: e
          }, this.getCenterPoint(s), c / 2, h) : Yg(i === "y" ? {
            start: o,
            end: l,
            value: e
          } : {
            start: r,
            end: a,
            value: t
          }, h);
        }
        getCenterPoint(t) {
          return _s(this, t);
        }
        draw(t) {
          const e = this.options, i = e.borderWidth;
          if (e.radius < 0.1) return;
          t.save(), t.fillStyle = e.backgroundColor, ur(t, e);
          const s = hi(t, e);
          JC(t, this, this.centerX, this.centerY), s && !ul(e.pointStyle) && (t.shadowColor = e.borderShadowColor, t.stroke()), t.restore(), e.borderWidth = i;
        }
        resolveElementProperties(t, e) {
          const i = c_(t, e);
          return i.initProperties = hr(t, i, e), i;
        }
      }
      ml.id = "pointAnnotation";
      ml.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        hitTolerance: 0,
        init: void 0,
        pointStyle: "circle",
        radius: 10,
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0
      };
      ml.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      class gl extends Ke {
        inRange(t, e, i, s) {
          if (i !== "x" && i !== "y") return this.options.radius >= 0.1 && this.elements.length > 1 && JR(this.elements, t, e, s);
          const r = gs({
            x: t,
            y: e
          }, this.getCenterPoint(s), ke(-this.options.rotation)), o = this.elements.map((c) => i === "y" ? c.bY : c.bX), a = Math.min(...o), l = Math.max(...o);
          return r[i] >= a && r[i] <= l;
        }
        getCenterPoint(t) {
          return _s(this, t);
        }
        draw(t) {
          const { elements: e, options: i } = this;
          t.save(), t.beginPath(), t.fillStyle = i.backgroundColor, ur(t, i);
          const s = hi(t, i);
          let r = true;
          for (const o of e) r ? (t.moveTo(o.x, o.y), r = false) : t.lineTo(o.x, o.y);
          t.closePath(), t.fill(), s && (t.shadowColor = i.borderShadowColor, t.stroke()), t.restore();
        }
        resolveElementProperties(t, e) {
          const i = c_(t, e), { sides: s, rotation: r } = e, o = [], a = 2 * Zt / s;
          let l = r * nu;
          for (let c = 0; c < s; c++, l += a) {
            const h = QR(i, e, l);
            h.initProperties = hr(t, i, e), o.push(h);
          }
          return i.elements = o, i;
        }
      }
      gl.id = "polygonAnnotation";
      gl.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: "transparent",
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderShadowColor: "transparent",
        borderWidth: 1,
        display: true,
        hitTolerance: 0,
        init: void 0,
        point: {
          radius: 0
        },
        radius: 10,
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        sides: 3,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0
      };
      gl.defaultRoutes = {
        borderColor: "color",
        backgroundColor: "color"
      };
      function QR({ centerX: n, centerY: t }, { radius: e, borderWidth: i, hitTolerance: s }, r) {
        const o = (i + s) / 2, a = Math.sin(r), l = Math.cos(r), c = {
          x: n + a * e,
          y: t - l * e
        };
        return {
          type: "point",
          optionScope: "point",
          properties: {
            x: c.x,
            y: c.y,
            centerX: c.x,
            centerY: c.y,
            bX: n + a * (e + o),
            bY: t - l * (e + o)
          }
        };
      }
      function JR(n, t, e, i) {
        let s = false, r = n[n.length - 1].getProps([
          "bX",
          "bY"
        ], i);
        for (const o of n) {
          const a = o.getProps([
            "bX",
            "bY"
          ], i);
          a.bY > e != r.bY > e && t < (r.bX - a.bX) * (e - a.bY) / (r.bY - a.bY) + a.bX && (s = !s), r = a;
        }
        return s;
      }
      const Pi = {
        box: dr,
        doughnutLabel: pl,
        ellipse: go,
        label: po,
        line: mo,
        point: ml,
        polygon: gl
      };
      Object.keys(Pi).forEach((n) => {
        be.describe(`elements.${Pi[n].id}`, {
          _fallback: "plugins.annotation.common"
        });
      });
      const tP = {
        update: Object.assign
      }, eP = yu.concat($a), Yp = (n, t) => Wt(t) ? Ch(n, t) : n, Ah = (n) => n === "color" || n === "font";
      function Mu(n = "line") {
        return Pi[n] ? n : (console.warn(`Unknown annotation type: '${n}', defaulting to 'line'`), "line");
      }
      function nP(n, t, e, i) {
        const s = sP(n, e.animations, i), r = t.annotations, o = aP(t.elements, r);
        for (let a = 0; a < r.length; a++) {
          const l = r[a], c = p_(o, a, l.type), h = l.setContext(oP(n, c, o, l)), u = c.resolveElementProperties(n, h);
          u.skip = iP(u), "elements" in u && (rP(c, u.elements, h, s), delete u.elements), cn(c.x) || Object.assign(c, u), Object.assign(c, u.initProperties), u.options = m_(h), s.update(c, u);
        }
      }
      function iP(n) {
        return isNaN(n.x) || isNaN(n.y);
      }
      function sP(n, t, e) {
        return e === "reset" || e === "none" || e === "resize" ? tP : new du(n, t);
      }
      function rP(n, t, e, i) {
        const s = n.elements || (n.elements = []);
        s.length = t.length;
        for (let r = 0; r < t.length; r++) {
          const o = t[r], a = o.properties, l = p_(s, r, o.type, o.initProperties), c = e[o.optionScope].override(o);
          a.options = m_(c), i.update(l, a);
        }
      }
      function p_(n, t, e, i) {
        const s = Pi[Mu(e)];
        let r = n[t];
        return (!r || !(r instanceof s)) && (r = n[t] = new s(), Object.assign(r, i)), r;
      }
      function m_(n) {
        const t = Pi[Mu(n.type)], e = {};
        e.id = n.id, e.type = n.type, e.drawTime = n.drawTime, Object.assign(e, Ch(n, t.defaults), Ch(n, t.defaultRoutes));
        for (const i of eP) e[i] = n[i];
        return e;
      }
      function Ch(n, t) {
        const e = {};
        for (const i of Object.keys(t)) {
          const s = t[i], r = n[i];
          Ah(i) && oe(r) ? e[i] = r.map((o) => Yp(o, s)) : e[i] = Yp(r, s);
        }
        return e;
      }
      function oP(n, t, e, i) {
        return t.$context || (t.$context = Object.assign(Object.create(n.getContext()), {
          element: t,
          get elements() {
            return e.filter((s) => s && s.options);
          },
          id: i.id,
          type: "annotation"
        }));
      }
      function aP(n, t) {
        const e = t.length, i = n.length;
        if (i < e) {
          const s = e - i;
          n.splice(i, 0, ...new Array(s));
        } else i > e && n.splice(e, i - e);
        return n;
      }
      var lP = "3.1.0";
      const xi = /* @__PURE__ */ new Map(), jp = (n) => n.type !== "doughnutLabel", cP = yu.concat($a);
      var hP = {
        id: "annotation",
        version: lP,
        beforeRegister() {
          YC("chart.js", "4.0", Ri.version);
        },
        afterRegister() {
          Ri.register(Pi);
        },
        afterUnregister() {
          Ri.unregister(Pi);
        },
        beforeInit(n) {
          xi.set(n, {
            annotations: [],
            elements: [],
            visibleElements: [],
            listeners: {},
            listened: false,
            moveListened: false,
            hooks: {},
            hooked: false,
            hovered: []
          });
        },
        beforeUpdate(n, t, e) {
          const i = xi.get(n), s = i.annotations = [];
          let r = e.annotations;
          Wt(r) ? Object.keys(r).forEach((o) => {
            const a = r[o];
            Wt(a) && (a.id = o, s.push(a));
          }) : oe(r) && s.push(...r), TR(s.filter(jp), n.scales);
        },
        afterDataLimits(n, t) {
          const e = xi.get(n);
          ER(n, t.scale, e.annotations.filter(jp).filter((i) => i.display && i.adjustScaleRange));
        },
        afterUpdate(n, t, e) {
          const i = xi.get(n);
          yR(n, i, e), nP(n, i, e, t.mode), i.visibleElements = i.elements.filter((s) => !s.skip && s.options.display), wR(n, i, e);
        },
        beforeDatasetsDraw(n, t, e) {
          Pr(n, "beforeDatasetsDraw", e.clip);
        },
        afterDatasetsDraw(n, t, e) {
          Pr(n, "afterDatasetsDraw", e.clip);
        },
        beforeDatasetDraw(n, t, e) {
          Pr(n, t.index, e.clip);
        },
        beforeDraw(n, t, e) {
          Pr(n, "beforeDraw", e.clip);
        },
        afterDraw(n, t, e) {
          Pr(n, "afterDraw", e.clip);
        },
        beforeEvent(n, t, e) {
          const i = xi.get(n);
          vR(i, t.event, e) && (t.changed = true);
        },
        afterDestroy(n) {
          xi.delete(n);
        },
        getAnnotations(n) {
          const t = xi.get(n);
          return t ? t.elements : [];
        },
        _getAnnotationElementsAtEventForMode(n, t, e) {
          return gu(n, t, e);
        },
        defaults: {
          animations: {
            numbers: {
              properties: [
                "x",
                "y",
                "x2",
                "y2",
                "width",
                "height",
                "centerX",
                "centerY",
                "pointX",
                "pointY",
                "radius"
              ],
              type: "number"
            },
            colors: {
              properties: [
                "backgroundColor",
                "borderColor"
              ],
              type: "color"
            }
          },
          clip: true,
          interaction: {
            mode: void 0,
            axis: void 0,
            intersect: void 0
          },
          common: {
            drawTime: "afterDatasetsDraw",
            init: false,
            label: {}
          }
        },
        descriptors: {
          _indexable: false,
          _scriptable: (n) => !cP.includes(n) && n !== "init",
          annotations: {
            _allKeys: false,
            _fallback: (n, t) => `elements.${Pi[Mu(t.type)].id}`
          },
          interaction: {
            _fallback: true
          },
          common: {
            label: {
              _indexable: Ah,
              _fallback: true
            },
            _indexable: Ah
          }
        },
        additionalOptionScopes: [
          ""
        ]
      };
      function Pr(n, t, e) {
        const { ctx: i, chartArea: s } = n, r = xi.get(n);
        e && uo(i, s);
        const o = uP(r.visibleElements, t).sort((a, l) => a.element.options.z - l.element.options.z);
        for (const a of o) dP(i, s, r, a);
        e && fo(i);
      }
      function uP(n, t) {
        const e = [];
        for (const i of n) if (i.options.drawTime === t && e.push({
          element: i,
          main: true
        }), i.elements && i.elements.length) for (const s of i.elements) s.options.display && s.options.drawTime === t && e.push({
          element: s
        });
        return e;
      }
      function dP(n, t, e, i) {
        const s = i.element;
        i.main ? (Ip(e, s, "beforeDraw"), s.draw(n, t), Ip(e, s, "afterDraw")) : s.draw(n, t);
      }
      const g_ = 6048e5, fP = 864e5, _o = 6e4, xo = 36e5, pP = 1e3, qp = Symbol.for("constructDateFrom");
      function Ae(n, t) {
        return typeof n == "function" ? n(t) : n && typeof n == "object" && qp in n ? n[qp](t) : n instanceof Date ? new n.constructor(t) : new Date(t);
      }
      function Vt(n, t) {
        return Ae(t || n, n);
      }
      function _l(n, t, e) {
        const i = Vt(n, e == null ? void 0 : e.in);
        return isNaN(t) ? Ae((e == null ? void 0 : e.in) || n, NaN) : (t && i.setDate(i.getDate() + t), i);
      }
      function Su(n, t, e) {
        const i = Vt(n, e == null ? void 0 : e.in);
        if (isNaN(t)) return Ae(n, NaN);
        if (!t) return i;
        const s = i.getDate(), r = Ae(n, i.getTime());
        r.setMonth(i.getMonth() + t + 1, 0);
        const o = r.getDate();
        return s >= o ? r : (i.setFullYear(r.getFullYear(), r.getMonth(), s), i);
      }
      function wu(n, t, e) {
        return Ae(n, +Vt(n) + t);
      }
      function mP(n, t, e) {
        return wu(n, t * xo);
      }
      let gP = {};
      function xs() {
        return gP;
      }
      function Gn(n, t) {
        var _a2, _b2, _c2, _d2;
        const e = xs(), i = (t == null ? void 0 : t.weekStartsOn) ?? ((_b2 = (_a2 = t == null ? void 0 : t.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.weekStartsOn) ?? e.weekStartsOn ?? ((_d2 = (_c2 = e.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.weekStartsOn) ?? 0, s = Vt(n, t == null ? void 0 : t.in), r = s.getDay(), o = (r < i ? 7 : 0) + r - i;
        return s.setDate(s.getDate() - o), s.setHours(0, 0, 0, 0), s;
      }
      function lr(n, t) {
        return Gn(n, {
          ...t,
          weekStartsOn: 1
        });
      }
      function __(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in), i = e.getFullYear(), s = Ae(e, 0);
        s.setFullYear(i + 1, 0, 4), s.setHours(0, 0, 0, 0);
        const r = lr(s), o = Ae(e, 0);
        o.setFullYear(i, 0, 4), o.setHours(0, 0, 0, 0);
        const a = lr(o);
        return e.getTime() >= r.getTime() ? i + 1 : e.getTime() >= a.getTime() ? i : i - 1;
      }
      function Ka(n) {
        const t = Vt(n), e = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
        return e.setUTCFullYear(t.getFullYear()), +n - +e;
      }
      function bs(n, ...t) {
        const e = Ae.bind(null, t.find((i) => typeof i == "object"));
        return t.map(e);
      }
      function Rh(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setHours(0, 0, 0, 0), e;
      }
      function x_(n, t, e) {
        const [i, s] = bs(e == null ? void 0 : e.in, n, t), r = Rh(i), o = Rh(s), a = +r - Ka(r), l = +o - Ka(o);
        return Math.round((a - l) / fP);
      }
      function _P(n, t) {
        const e = __(n, t), i = Ae(n, 0);
        return i.setFullYear(e, 0, 4), i.setHours(0, 0, 0, 0), lr(i);
      }
      function xP(n, t, e) {
        const i = Vt(n, e == null ? void 0 : e.in);
        return i.setTime(i.getTime() + t * _o), i;
      }
      function bP(n, t, e) {
        return Su(n, t * 3, e);
      }
      function yP(n, t, e) {
        return wu(n, t * 1e3);
      }
      function vP(n, t, e) {
        return _l(n, t * 7, e);
      }
      function MP(n, t, e) {
        return Su(n, t * 12, e);
      }
      function Yr(n, t) {
        const e = +Vt(n) - +Vt(t);
        return e < 0 ? -1 : e > 0 ? 1 : e;
      }
      function SP(n) {
        return n instanceof Date || typeof n == "object" && Object.prototype.toString.call(n) === "[object Date]";
      }
      function b_(n) {
        return !(!SP(n) && typeof n != "number" || isNaN(+Vt(n)));
      }
      function wP(n, t, e) {
        const [i, s] = bs(e == null ? void 0 : e.in, n, t), r = i.getFullYear() - s.getFullYear(), o = i.getMonth() - s.getMonth();
        return r * 12 + o;
      }
      function EP(n, t, e) {
        const [i, s] = bs(e == null ? void 0 : e.in, n, t);
        return i.getFullYear() - s.getFullYear();
      }
      function y_(n, t, e) {
        const [i, s] = bs(e == null ? void 0 : e.in, n, t), r = $p(i, s), o = Math.abs(x_(i, s));
        i.setDate(i.getDate() - r * o);
        const a = +($p(i, s) === -r), l = r * (o - a);
        return l === 0 ? 0 : l;
      }
      function $p(n, t) {
        const e = n.getFullYear() - t.getFullYear() || n.getMonth() - t.getMonth() || n.getDate() - t.getDate() || n.getHours() - t.getHours() || n.getMinutes() - t.getMinutes() || n.getSeconds() - t.getSeconds() || n.getMilliseconds() - t.getMilliseconds();
        return e < 0 ? -1 : e > 0 ? 1 : e;
      }
      function bo(n) {
        return (t) => {
          const i = (n ? Math[n] : Math.trunc)(t);
          return i === 0 ? 0 : i;
        };
      }
      function TP(n, t, e) {
        const [i, s] = bs(e == null ? void 0 : e.in, n, t), r = (+i - +s) / xo;
        return bo(e == null ? void 0 : e.roundingMethod)(r);
      }
      function Eu(n, t) {
        return +Vt(n) - +Vt(t);
      }
      function AP(n, t, e) {
        const i = Eu(n, t) / _o;
        return bo(e == null ? void 0 : e.roundingMethod)(i);
      }
      function v_(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setHours(23, 59, 59, 999), e;
      }
      function M_(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in), i = e.getMonth();
        return e.setFullYear(e.getFullYear(), i + 1, 0), e.setHours(23, 59, 59, 999), e;
      }
      function CP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return +v_(e, t) == +M_(e, t);
      }
      function S_(n, t, e) {
        const [i, s, r] = bs(e == null ? void 0 : e.in, n, n, t), o = Yr(s, r), a = Math.abs(wP(s, r));
        if (a < 1) return 0;
        s.getMonth() === 1 && s.getDate() > 27 && s.setDate(30), s.setMonth(s.getMonth() - o * a);
        let l = Yr(s, r) === -o;
        CP(i) && a === 1 && Yr(i, r) === 1 && (l = false);
        const c = o * (a - +l);
        return c === 0 ? 0 : c;
      }
      function RP(n, t, e) {
        const i = S_(n, t, e) / 3;
        return bo(e == null ? void 0 : e.roundingMethod)(i);
      }
      function PP(n, t, e) {
        const i = Eu(n, t) / 1e3;
        return bo(e == null ? void 0 : e.roundingMethod)(i);
      }
      function DP(n, t, e) {
        const i = y_(n, t, e) / 7;
        return bo(e == null ? void 0 : e.roundingMethod)(i);
      }
      function LP(n, t, e) {
        const [i, s] = bs(e == null ? void 0 : e.in, n, t), r = Yr(i, s), o = Math.abs(EP(i, s));
        i.setFullYear(1584), s.setFullYear(1584);
        const a = Yr(i, s) === -r, l = r * (o - +a);
        return l === 0 ? 0 : l;
      }
      function IP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in), i = e.getMonth(), s = i - i % 3;
        return e.setMonth(s, 1), e.setHours(0, 0, 0, 0), e;
      }
      function OP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setDate(1), e.setHours(0, 0, 0, 0), e;
      }
      function kP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in), i = e.getFullYear();
        return e.setFullYear(i + 1, 0, 0), e.setHours(23, 59, 59, 999), e;
      }
      function w_(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setFullYear(e.getFullYear(), 0, 1), e.setHours(0, 0, 0, 0), e;
      }
      function FP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setMinutes(59, 59, 999), e;
      }
      function NP(n, t) {
        var _a2, _b2;
        const e = xs(), i = e.weekStartsOn ?? ((_b2 = (_a2 = e.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.weekStartsOn) ?? 0, s = Vt(n, t == null ? void 0 : t.in), r = s.getDay(), o = (r < i ? -7 : 0) + 6 - (r - i);
        return s.setDate(s.getDate() + o), s.setHours(23, 59, 59, 999), s;
      }
      function UP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setSeconds(59, 999), e;
      }
      function BP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in), i = e.getMonth(), s = i - i % 3 + 3;
        return e.setMonth(s, 0), e.setHours(23, 59, 59, 999), e;
      }
      function zP(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setMilliseconds(999), e;
      }
      const HP = {
        lessThanXSeconds: {
          one: "less than a second",
          other: "less than {{count}} seconds"
        },
        xSeconds: {
          one: "1 second",
          other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
          one: "less than a minute",
          other: "less than {{count}} minutes"
        },
        xMinutes: {
          one: "1 minute",
          other: "{{count}} minutes"
        },
        aboutXHours: {
          one: "about 1 hour",
          other: "about {{count}} hours"
        },
        xHours: {
          one: "1 hour",
          other: "{{count}} hours"
        },
        xDays: {
          one: "1 day",
          other: "{{count}} days"
        },
        aboutXWeeks: {
          one: "about 1 week",
          other: "about {{count}} weeks"
        },
        xWeeks: {
          one: "1 week",
          other: "{{count}} weeks"
        },
        aboutXMonths: {
          one: "about 1 month",
          other: "about {{count}} months"
        },
        xMonths: {
          one: "1 month",
          other: "{{count}} months"
        },
        aboutXYears: {
          one: "about 1 year",
          other: "about {{count}} years"
        },
        xYears: {
          one: "1 year",
          other: "{{count}} years"
        },
        overXYears: {
          one: "over 1 year",
          other: "over {{count}} years"
        },
        almostXYears: {
          one: "almost 1 year",
          other: "almost {{count}} years"
        }
      }, VP = (n, t, e) => {
        let i;
        const s = HP[n];
        return typeof s == "string" ? i = s : t === 1 ? i = s.one : i = s.other.replace("{{count}}", t.toString()), (e == null ? void 0 : e.addSuffix) ? e.comparison && e.comparison > 0 ? "in " + i : i + " ago" : i;
      };
      function _c(n) {
        return (t = {}) => {
          const e = t.width ? String(t.width) : n.defaultWidth;
          return n.formats[e] || n.formats[n.defaultWidth];
        };
      }
      const WP = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
      }, GP = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      }, XP = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
      }, YP = {
        date: _c({
          formats: WP,
          defaultWidth: "full"
        }),
        time: _c({
          formats: GP,
          defaultWidth: "full"
        }),
        dateTime: _c({
          formats: XP,
          defaultWidth: "full"
        })
      }, jP = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
      }, qP = (n, t, e, i) => jP[n];
      function Dr(n) {
        return (t, e) => {
          const i = (e == null ? void 0 : e.context) ? String(e.context) : "standalone";
          let s;
          if (i === "formatting" && n.formattingValues) {
            const o = n.defaultFormattingWidth || n.defaultWidth, a = (e == null ? void 0 : e.width) ? String(e.width) : o;
            s = n.formattingValues[a] || n.formattingValues[o];
          } else {
            const o = n.defaultWidth, a = (e == null ? void 0 : e.width) ? String(e.width) : n.defaultWidth;
            s = n.values[a] || n.values[o];
          }
          const r = n.argumentCallback ? n.argumentCallback(t) : t;
          return s[r];
        };
      }
      const $P = {
        narrow: [
          "B",
          "A"
        ],
        abbreviated: [
          "BC",
          "AD"
        ],
        wide: [
          "Before Christ",
          "Anno Domini"
        ]
      }, KP = {
        narrow: [
          "1",
          "2",
          "3",
          "4"
        ],
        abbreviated: [
          "Q1",
          "Q2",
          "Q3",
          "Q4"
        ],
        wide: [
          "1st quarter",
          "2nd quarter",
          "3rd quarter",
          "4th quarter"
        ]
      }, ZP = {
        narrow: [
          "J",
          "F",
          "M",
          "A",
          "M",
          "J",
          "J",
          "A",
          "S",
          "O",
          "N",
          "D"
        ],
        abbreviated: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        wide: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ]
      }, QP = {
        narrow: [
          "S",
          "M",
          "T",
          "W",
          "T",
          "F",
          "S"
        ],
        short: [
          "Su",
          "Mo",
          "Tu",
          "We",
          "Th",
          "Fr",
          "Sa"
        ],
        abbreviated: [
          "Sun",
          "Mon",
          "Tue",
          "Wed",
          "Thu",
          "Fri",
          "Sat"
        ],
        wide: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ]
      }, JP = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        }
      }, tD = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        }
      }, eD = (n, t) => {
        const e = Number(n), i = e % 100;
        if (i > 20 || i < 10) switch (i % 10) {
          case 1:
            return e + "st";
          case 2:
            return e + "nd";
          case 3:
            return e + "rd";
        }
        return e + "th";
      }, nD = {
        ordinalNumber: eD,
        era: Dr({
          values: $P,
          defaultWidth: "wide"
        }),
        quarter: Dr({
          values: KP,
          defaultWidth: "wide",
          argumentCallback: (n) => n - 1
        }),
        month: Dr({
          values: ZP,
          defaultWidth: "wide"
        }),
        day: Dr({
          values: QP,
          defaultWidth: "wide"
        }),
        dayPeriod: Dr({
          values: JP,
          defaultWidth: "wide",
          formattingValues: tD,
          defaultFormattingWidth: "wide"
        })
      };
      function Lr(n) {
        return (t, e = {}) => {
          const i = e.width, s = i && n.matchPatterns[i] || n.matchPatterns[n.defaultMatchWidth], r = t.match(s);
          if (!r) return null;
          const o = r[0], a = i && n.parsePatterns[i] || n.parsePatterns[n.defaultParseWidth], l = Array.isArray(a) ? sD(a, (u) => u.test(o)) : iD(a, (u) => u.test(o));
          let c;
          c = n.valueCallback ? n.valueCallback(l) : l, c = e.valueCallback ? e.valueCallback(c) : c;
          const h = t.slice(o.length);
          return {
            value: c,
            rest: h
          };
        };
      }
      function iD(n, t) {
        for (const e in n) if (Object.prototype.hasOwnProperty.call(n, e) && t(n[e])) return e;
      }
      function sD(n, t) {
        for (let e = 0; e < n.length; e++) if (t(n[e])) return e;
      }
      function rD(n) {
        return (t, e = {}) => {
          const i = t.match(n.matchPattern);
          if (!i) return null;
          const s = i[0], r = t.match(n.parsePattern);
          if (!r) return null;
          let o = n.valueCallback ? n.valueCallback(r[0]) : r[0];
          o = e.valueCallback ? e.valueCallback(o) : o;
          const a = t.slice(s.length);
          return {
            value: o,
            rest: a
          };
        };
      }
      const oD = /^(\d+)(th|st|nd|rd)?/i, aD = /\d+/i, lD = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
      }, cD = {
        any: [
          /^b/i,
          /^(a|c)/i
        ]
      }, hD = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
      }, uD = {
        any: [
          /1/i,
          /2/i,
          /3/i,
          /4/i
        ]
      }, dD = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
      }, fD = {
        narrow: [
          /^j/i,
          /^f/i,
          /^m/i,
          /^a/i,
          /^m/i,
          /^j/i,
          /^j/i,
          /^a/i,
          /^s/i,
          /^o/i,
          /^n/i,
          /^d/i
        ],
        any: [
          /^ja/i,
          /^f/i,
          /^mar/i,
          /^ap/i,
          /^may/i,
          /^jun/i,
          /^jul/i,
          /^au/i,
          /^s/i,
          /^o/i,
          /^n/i,
          /^d/i
        ]
      }, pD = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
      }, mD = {
        narrow: [
          /^s/i,
          /^m/i,
          /^t/i,
          /^w/i,
          /^t/i,
          /^f/i,
          /^s/i
        ],
        any: [
          /^su/i,
          /^m/i,
          /^tu/i,
          /^w/i,
          /^th/i,
          /^f/i,
          /^sa/i
        ]
      }, gD = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
      }, _D = {
        any: {
          am: /^a/i,
          pm: /^p/i,
          midnight: /^mi/i,
          noon: /^no/i,
          morning: /morning/i,
          afternoon: /afternoon/i,
          evening: /evening/i,
          night: /night/i
        }
      }, xD = {
        ordinalNumber: rD({
          matchPattern: oD,
          parsePattern: aD,
          valueCallback: (n) => parseInt(n, 10)
        }),
        era: Lr({
          matchPatterns: lD,
          defaultMatchWidth: "wide",
          parsePatterns: cD,
          defaultParseWidth: "any"
        }),
        quarter: Lr({
          matchPatterns: hD,
          defaultMatchWidth: "wide",
          parsePatterns: uD,
          defaultParseWidth: "any",
          valueCallback: (n) => n + 1
        }),
        month: Lr({
          matchPatterns: dD,
          defaultMatchWidth: "wide",
          parsePatterns: fD,
          defaultParseWidth: "any"
        }),
        day: Lr({
          matchPatterns: pD,
          defaultMatchWidth: "wide",
          parsePatterns: mD,
          defaultParseWidth: "any"
        }),
        dayPeriod: Lr({
          matchPatterns: gD,
          defaultMatchWidth: "any",
          parsePatterns: _D,
          defaultParseWidth: "any"
        })
      }, E_ = {
        code: "en-US",
        formatDistance: VP,
        formatLong: YP,
        formatRelative: qP,
        localize: nD,
        match: xD,
        options: {
          weekStartsOn: 0,
          firstWeekContainsDate: 1
        }
      };
      function bD(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return x_(e, w_(e)) + 1;
      }
      function T_(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in), i = +lr(e) - +_P(e);
        return Math.round(i / g_) + 1;
      }
      function Tu(n, t) {
        var _a2, _b2, _c2, _d2;
        const e = Vt(n, t == null ? void 0 : t.in), i = e.getFullYear(), s = xs(), r = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((_b2 = (_a2 = t == null ? void 0 : t.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.firstWeekContainsDate) ?? s.firstWeekContainsDate ?? ((_d2 = (_c2 = s.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.firstWeekContainsDate) ?? 1, o = Ae((t == null ? void 0 : t.in) || n, 0);
        o.setFullYear(i + 1, 0, r), o.setHours(0, 0, 0, 0);
        const a = Gn(o, t), l = Ae((t == null ? void 0 : t.in) || n, 0);
        l.setFullYear(i, 0, r), l.setHours(0, 0, 0, 0);
        const c = Gn(l, t);
        return +e >= +a ? i + 1 : +e >= +c ? i : i - 1;
      }
      function yD(n, t) {
        var _a2, _b2, _c2, _d2;
        const e = xs(), i = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((_b2 = (_a2 = t == null ? void 0 : t.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.firstWeekContainsDate) ?? e.firstWeekContainsDate ?? ((_d2 = (_c2 = e.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.firstWeekContainsDate) ?? 1, s = Tu(n, t), r = Ae((t == null ? void 0 : t.in) || n, 0);
        return r.setFullYear(s, 0, i), r.setHours(0, 0, 0, 0), Gn(r, t);
      }
      function A_(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in), i = +Gn(e, t) - +yD(e, t);
        return Math.round(i / g_) + 1;
      }
      function le(n, t) {
        const e = n < 0 ? "-" : "", i = Math.abs(n).toString().padStart(t, "0");
        return e + i;
      }
      const _i = {
        y(n, t) {
          const e = n.getFullYear(), i = e > 0 ? e : 1 - e;
          return le(t === "yy" ? i % 100 : i, t.length);
        },
        M(n, t) {
          const e = n.getMonth();
          return t === "M" ? String(e + 1) : le(e + 1, 2);
        },
        d(n, t) {
          return le(n.getDate(), t.length);
        },
        a(n, t) {
          const e = n.getHours() / 12 >= 1 ? "pm" : "am";
          switch (t) {
            case "a":
            case "aa":
              return e.toUpperCase();
            case "aaa":
              return e;
            case "aaaaa":
              return e[0];
            case "aaaa":
            default:
              return e === "am" ? "a.m." : "p.m.";
          }
        },
        h(n, t) {
          return le(n.getHours() % 12 || 12, t.length);
        },
        H(n, t) {
          return le(n.getHours(), t.length);
        },
        m(n, t) {
          return le(n.getMinutes(), t.length);
        },
        s(n, t) {
          return le(n.getSeconds(), t.length);
        },
        S(n, t) {
          const e = t.length, i = n.getMilliseconds(), s = Math.trunc(i * Math.pow(10, e - 3));
          return le(s, t.length);
        }
      }, Hs = {
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }, Kp = {
        G: function(n, t, e) {
          const i = n.getFullYear() > 0 ? 1 : 0;
          switch (t) {
            case "G":
            case "GG":
            case "GGG":
              return e.era(i, {
                width: "abbreviated"
              });
            case "GGGGG":
              return e.era(i, {
                width: "narrow"
              });
            case "GGGG":
            default:
              return e.era(i, {
                width: "wide"
              });
          }
        },
        y: function(n, t, e) {
          if (t === "yo") {
            const i = n.getFullYear(), s = i > 0 ? i : 1 - i;
            return e.ordinalNumber(s, {
              unit: "year"
            });
          }
          return _i.y(n, t);
        },
        Y: function(n, t, e, i) {
          const s = Tu(n, i), r = s > 0 ? s : 1 - s;
          if (t === "YY") {
            const o = r % 100;
            return le(o, 2);
          }
          return t === "Yo" ? e.ordinalNumber(r, {
            unit: "year"
          }) : le(r, t.length);
        },
        R: function(n, t) {
          const e = __(n);
          return le(e, t.length);
        },
        u: function(n, t) {
          const e = n.getFullYear();
          return le(e, t.length);
        },
        Q: function(n, t, e) {
          const i = Math.ceil((n.getMonth() + 1) / 3);
          switch (t) {
            case "Q":
              return String(i);
            case "QQ":
              return le(i, 2);
            case "Qo":
              return e.ordinalNumber(i, {
                unit: "quarter"
              });
            case "QQQ":
              return e.quarter(i, {
                width: "abbreviated",
                context: "formatting"
              });
            case "QQQQQ":
              return e.quarter(i, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQ":
            default:
              return e.quarter(i, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        q: function(n, t, e) {
          const i = Math.ceil((n.getMonth() + 1) / 3);
          switch (t) {
            case "q":
              return String(i);
            case "qq":
              return le(i, 2);
            case "qo":
              return e.ordinalNumber(i, {
                unit: "quarter"
              });
            case "qqq":
              return e.quarter(i, {
                width: "abbreviated",
                context: "standalone"
              });
            case "qqqqq":
              return e.quarter(i, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqq":
            default:
              return e.quarter(i, {
                width: "wide",
                context: "standalone"
              });
          }
        },
        M: function(n, t, e) {
          const i = n.getMonth();
          switch (t) {
            case "M":
            case "MM":
              return _i.M(n, t);
            case "Mo":
              return e.ordinalNumber(i + 1, {
                unit: "month"
              });
            case "MMM":
              return e.month(i, {
                width: "abbreviated",
                context: "formatting"
              });
            case "MMMMM":
              return e.month(i, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMM":
            default:
              return e.month(i, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        L: function(n, t, e) {
          const i = n.getMonth();
          switch (t) {
            case "L":
              return String(i + 1);
            case "LL":
              return le(i + 1, 2);
            case "Lo":
              return e.ordinalNumber(i + 1, {
                unit: "month"
              });
            case "LLL":
              return e.month(i, {
                width: "abbreviated",
                context: "standalone"
              });
            case "LLLLL":
              return e.month(i, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLL":
            default:
              return e.month(i, {
                width: "wide",
                context: "standalone"
              });
          }
        },
        w: function(n, t, e, i) {
          const s = A_(n, i);
          return t === "wo" ? e.ordinalNumber(s, {
            unit: "week"
          }) : le(s, t.length);
        },
        I: function(n, t, e) {
          const i = T_(n);
          return t === "Io" ? e.ordinalNumber(i, {
            unit: "week"
          }) : le(i, t.length);
        },
        d: function(n, t, e) {
          return t === "do" ? e.ordinalNumber(n.getDate(), {
            unit: "date"
          }) : _i.d(n, t);
        },
        D: function(n, t, e) {
          const i = bD(n);
          return t === "Do" ? e.ordinalNumber(i, {
            unit: "dayOfYear"
          }) : le(i, t.length);
        },
        E: function(n, t, e) {
          const i = n.getDay();
          switch (t) {
            case "E":
            case "EE":
            case "EEE":
              return e.day(i, {
                width: "abbreviated",
                context: "formatting"
              });
            case "EEEEE":
              return e.day(i, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEEE":
              return e.day(i, {
                width: "short",
                context: "formatting"
              });
            case "EEEE":
            default:
              return e.day(i, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        e: function(n, t, e, i) {
          const s = n.getDay(), r = (s - i.weekStartsOn + 8) % 7 || 7;
          switch (t) {
            case "e":
              return String(r);
            case "ee":
              return le(r, 2);
            case "eo":
              return e.ordinalNumber(r, {
                unit: "day"
              });
            case "eee":
              return e.day(s, {
                width: "abbreviated",
                context: "formatting"
              });
            case "eeeee":
              return e.day(s, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeeee":
              return e.day(s, {
                width: "short",
                context: "formatting"
              });
            case "eeee":
            default:
              return e.day(s, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        c: function(n, t, e, i) {
          const s = n.getDay(), r = (s - i.weekStartsOn + 8) % 7 || 7;
          switch (t) {
            case "c":
              return String(r);
            case "cc":
              return le(r, t.length);
            case "co":
              return e.ordinalNumber(r, {
                unit: "day"
              });
            case "ccc":
              return e.day(s, {
                width: "abbreviated",
                context: "standalone"
              });
            case "ccccc":
              return e.day(s, {
                width: "narrow",
                context: "standalone"
              });
            case "cccccc":
              return e.day(s, {
                width: "short",
                context: "standalone"
              });
            case "cccc":
            default:
              return e.day(s, {
                width: "wide",
                context: "standalone"
              });
          }
        },
        i: function(n, t, e) {
          const i = n.getDay(), s = i === 0 ? 7 : i;
          switch (t) {
            case "i":
              return String(s);
            case "ii":
              return le(s, t.length);
            case "io":
              return e.ordinalNumber(s, {
                unit: "day"
              });
            case "iii":
              return e.day(i, {
                width: "abbreviated",
                context: "formatting"
              });
            case "iiiii":
              return e.day(i, {
                width: "narrow",
                context: "formatting"
              });
            case "iiiiii":
              return e.day(i, {
                width: "short",
                context: "formatting"
              });
            case "iiii":
            default:
              return e.day(i, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        a: function(n, t, e) {
          const s = n.getHours() / 12 >= 1 ? "pm" : "am";
          switch (t) {
            case "a":
            case "aa":
              return e.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
              });
            case "aaa":
              return e.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
              }).toLowerCase();
            case "aaaaa":
              return e.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaa":
            default:
              return e.dayPeriod(s, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        b: function(n, t, e) {
          const i = n.getHours();
          let s;
          switch (i === 12 ? s = Hs.noon : i === 0 ? s = Hs.midnight : s = i / 12 >= 1 ? "pm" : "am", t) {
            case "b":
            case "bb":
              return e.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
              });
            case "bbb":
              return e.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
              }).toLowerCase();
            case "bbbbb":
              return e.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbb":
            default:
              return e.dayPeriod(s, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        B: function(n, t, e) {
          const i = n.getHours();
          let s;
          switch (i >= 17 ? s = Hs.evening : i >= 12 ? s = Hs.afternoon : i >= 4 ? s = Hs.morning : s = Hs.night, t) {
            case "B":
            case "BB":
            case "BBB":
              return e.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
              });
            case "BBBBB":
              return e.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBB":
            default:
              return e.dayPeriod(s, {
                width: "wide",
                context: "formatting"
              });
          }
        },
        h: function(n, t, e) {
          if (t === "ho") {
            let i = n.getHours() % 12;
            return i === 0 && (i = 12), e.ordinalNumber(i, {
              unit: "hour"
            });
          }
          return _i.h(n, t);
        },
        H: function(n, t, e) {
          return t === "Ho" ? e.ordinalNumber(n.getHours(), {
            unit: "hour"
          }) : _i.H(n, t);
        },
        K: function(n, t, e) {
          const i = n.getHours() % 12;
          return t === "Ko" ? e.ordinalNumber(i, {
            unit: "hour"
          }) : le(i, t.length);
        },
        k: function(n, t, e) {
          let i = n.getHours();
          return i === 0 && (i = 24), t === "ko" ? e.ordinalNumber(i, {
            unit: "hour"
          }) : le(i, t.length);
        },
        m: function(n, t, e) {
          return t === "mo" ? e.ordinalNumber(n.getMinutes(), {
            unit: "minute"
          }) : _i.m(n, t);
        },
        s: function(n, t, e) {
          return t === "so" ? e.ordinalNumber(n.getSeconds(), {
            unit: "second"
          }) : _i.s(n, t);
        },
        S: function(n, t) {
          return _i.S(n, t);
        },
        X: function(n, t, e) {
          const i = n.getTimezoneOffset();
          if (i === 0) return "Z";
          switch (t) {
            case "X":
              return Qp(i);
            case "XXXX":
            case "XX":
              return Qi(i);
            case "XXXXX":
            case "XXX":
            default:
              return Qi(i, ":");
          }
        },
        x: function(n, t, e) {
          const i = n.getTimezoneOffset();
          switch (t) {
            case "x":
              return Qp(i);
            case "xxxx":
            case "xx":
              return Qi(i);
            case "xxxxx":
            case "xxx":
            default:
              return Qi(i, ":");
          }
        },
        O: function(n, t, e) {
          const i = n.getTimezoneOffset();
          switch (t) {
            case "O":
            case "OO":
            case "OOO":
              return "GMT" + Zp(i, ":");
            case "OOOO":
            default:
              return "GMT" + Qi(i, ":");
          }
        },
        z: function(n, t, e) {
          const i = n.getTimezoneOffset();
          switch (t) {
            case "z":
            case "zz":
            case "zzz":
              return "GMT" + Zp(i, ":");
            case "zzzz":
            default:
              return "GMT" + Qi(i, ":");
          }
        },
        t: function(n, t, e) {
          const i = Math.trunc(+n / 1e3);
          return le(i, t.length);
        },
        T: function(n, t, e) {
          return le(+n, t.length);
        }
      };
      function Zp(n, t = "") {
        const e = n > 0 ? "-" : "+", i = Math.abs(n), s = Math.trunc(i / 60), r = i % 60;
        return r === 0 ? e + String(s) : e + String(s) + t + le(r, 2);
      }
      function Qp(n, t) {
        return n % 60 === 0 ? (n > 0 ? "-" : "+") + le(Math.abs(n) / 60, 2) : Qi(n, t);
      }
      function Qi(n, t = "") {
        const e = n > 0 ? "-" : "+", i = Math.abs(n), s = le(Math.trunc(i / 60), 2), r = le(i % 60, 2);
        return e + s + t + r;
      }
      const Jp = (n, t) => {
        switch (n) {
          case "P":
            return t.date({
              width: "short"
            });
          case "PP":
            return t.date({
              width: "medium"
            });
          case "PPP":
            return t.date({
              width: "long"
            });
          case "PPPP":
          default:
            return t.date({
              width: "full"
            });
        }
      }, C_ = (n, t) => {
        switch (n) {
          case "p":
            return t.time({
              width: "short"
            });
          case "pp":
            return t.time({
              width: "medium"
            });
          case "ppp":
            return t.time({
              width: "long"
            });
          case "pppp":
          default:
            return t.time({
              width: "full"
            });
        }
      }, vD = (n, t) => {
        const e = n.match(/(P+)(p+)?/) || [], i = e[1], s = e[2];
        if (!s) return Jp(n, t);
        let r;
        switch (i) {
          case "P":
            r = t.dateTime({
              width: "short"
            });
            break;
          case "PP":
            r = t.dateTime({
              width: "medium"
            });
            break;
          case "PPP":
            r = t.dateTime({
              width: "long"
            });
            break;
          case "PPPP":
          default:
            r = t.dateTime({
              width: "full"
            });
            break;
        }
        return r.replace("{{date}}", Jp(i, t)).replace("{{time}}", C_(s, t));
      }, Ph = {
        p: C_,
        P: vD
      }, MD = /^D+$/, SD = /^Y+$/, wD = [
        "D",
        "DD",
        "YY",
        "YYYY"
      ];
      function R_(n) {
        return MD.test(n);
      }
      function P_(n) {
        return SD.test(n);
      }
      function Dh(n, t, e) {
        const i = ED(n, t, e);
        if (console.warn(i), wD.includes(n)) throw new RangeError(i);
      }
      function ED(n, t, e) {
        const i = n[0] === "Y" ? "years" : "days of the month";
        return `Use \`${n.toLowerCase()}\` instead of \`${n}\` (in \`${t}\`) for formatting ${i} to the input \`${e}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
      }
      const TD = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, AD = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, CD = /^'([^]*?)'?$/, RD = /''/g, PD = /[a-zA-Z]/;
      function D_(n, t, e) {
        var _a2, _b2, _c2, _d2, _e, _f2, _g2, _h2;
        const i = xs(), s = (e == null ? void 0 : e.locale) ?? i.locale ?? E_, r = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((_b2 = (_a2 = e == null ? void 0 : e.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((_d2 = (_c2 = i.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.firstWeekContainsDate) ?? 1, o = (e == null ? void 0 : e.weekStartsOn) ?? ((_f2 = (_e = e == null ? void 0 : e.locale) == null ? void 0 : _e.options) == null ? void 0 : _f2.weekStartsOn) ?? i.weekStartsOn ?? ((_h2 = (_g2 = i.locale) == null ? void 0 : _g2.options) == null ? void 0 : _h2.weekStartsOn) ?? 0, a = Vt(n, e == null ? void 0 : e.in);
        if (!b_(a)) throw new RangeError("Invalid time value");
        let l = t.match(AD).map((h) => {
          const u = h[0];
          if (u === "p" || u === "P") {
            const d = Ph[u];
            return d(h, s.formatLong);
          }
          return h;
        }).join("").match(TD).map((h) => {
          if (h === "''") return {
            isToken: false,
            value: "'"
          };
          const u = h[0];
          if (u === "'") return {
            isToken: false,
            value: DD(h)
          };
          if (Kp[u]) return {
            isToken: true,
            value: h
          };
          if (u.match(PD)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + u + "`");
          return {
            isToken: false,
            value: h
          };
        });
        s.localize.preprocessor && (l = s.localize.preprocessor(a, l));
        const c = {
          firstWeekContainsDate: r,
          weekStartsOn: o,
          locale: s
        };
        return l.map((h) => {
          if (!h.isToken) return h.value;
          const u = h.value;
          (!(e == null ? void 0 : e.useAdditionalWeekYearTokens) && P_(u) || !(e == null ? void 0 : e.useAdditionalDayOfYearTokens) && R_(u)) && Dh(u, t, String(n));
          const d = Kp[u[0]];
          return d(a, u, s.localize, c);
        }).join("");
      }
      function DD(n) {
        const t = n.match(CD);
        return t ? t[1].replace(RD, "'") : n;
      }
      function LD() {
        return Object.assign({}, xs());
      }
      function ID(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in).getDay();
        return e === 0 ? 7 : e;
      }
      function OD(n, t) {
        const e = kD(t) ? new t(0) : Ae(t, 0);
        return e.setFullYear(n.getFullYear(), n.getMonth(), n.getDate()), e.setHours(n.getHours(), n.getMinutes(), n.getSeconds(), n.getMilliseconds()), e;
      }
      function kD(n) {
        var _a2;
        return typeof n == "function" && ((_a2 = n.prototype) == null ? void 0 : _a2.constructor) === n;
      }
      const FD = 10;
      class L_ {
        constructor() {
          __publicField(this, "subPriority", 0);
        }
        validate(t, e) {
          return true;
        }
      }
      class ND extends L_ {
        constructor(t, e, i, s, r) {
          super(), this.value = t, this.validateValue = e, this.setValue = i, this.priority = s, r && (this.subPriority = r);
        }
        validate(t, e) {
          return this.validateValue(t, this.value, e);
        }
        set(t, e, i) {
          return this.setValue(t, e, this.value, i);
        }
      }
      class UD extends L_ {
        constructor(t, e) {
          super();
          __publicField(this, "priority", FD);
          __publicField(this, "subPriority", -1);
          this.context = t || ((i) => Ae(e, i));
        }
        set(t, e) {
          return e.timestampIsSet ? t : Ae(t, OD(t, this.context));
        }
      }
      class ie {
        run(t, e, i, s) {
          const r = this.parse(t, e, i, s);
          return r ? {
            setter: new ND(r.value, this.validate, this.set, this.priority, this.subPriority),
            rest: r.rest
          } : null;
        }
        validate(t, e, i) {
          return true;
        }
      }
      class BD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 140);
          __publicField(this, "incompatibleTokens", [
            "R",
            "u",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "G":
            case "GG":
            case "GGG":
              return i.era(t, {
                width: "abbreviated"
              }) || i.era(t, {
                width: "narrow"
              });
            case "GGGGG":
              return i.era(t, {
                width: "narrow"
              });
            case "GGGG":
            default:
              return i.era(t, {
                width: "wide"
              }) || i.era(t, {
                width: "abbreviated"
              }) || i.era(t, {
                width: "narrow"
              });
          }
        }
        set(t, e, i) {
          return e.era = i, t.setFullYear(i, 0, 1), t.setHours(0, 0, 0, 0), t;
        }
      }
      const Pe = {
        month: /^(1[0-2]|0?\d)/,
        date: /^(3[0-1]|[0-2]?\d)/,
        dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
        week: /^(5[0-3]|[0-4]?\d)/,
        hour23h: /^(2[0-3]|[0-1]?\d)/,
        hour24h: /^(2[0-4]|[0-1]?\d)/,
        hour11h: /^(1[0-1]|0?\d)/,
        hour12h: /^(1[0-2]|0?\d)/,
        minute: /^[0-5]?\d/,
        second: /^[0-5]?\d/,
        singleDigit: /^\d/,
        twoDigits: /^\d{1,2}/,
        threeDigits: /^\d{1,3}/,
        fourDigits: /^\d{1,4}/,
        anyDigitsSigned: /^-?\d+/,
        singleDigitSigned: /^-?\d/,
        twoDigitsSigned: /^-?\d{1,2}/,
        threeDigitsSigned: /^-?\d{1,3}/,
        fourDigitsSigned: /^-?\d{1,4}/
      }, Bn = {
        basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
        basic: /^([+-])(\d{2})(\d{2})|Z/,
        basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
        extended: /^([+-])(\d{2}):(\d{2})|Z/,
        extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
      };
      function De(n, t) {
        return n && {
          value: t(n.value),
          rest: n.rest
        };
      }
      function Se(n, t) {
        const e = t.match(n);
        return e ? {
          value: parseInt(e[0], 10),
          rest: t.slice(e[0].length)
        } : null;
      }
      function zn(n, t) {
        const e = t.match(n);
        if (!e) return null;
        if (e[0] === "Z") return {
          value: 0,
          rest: t.slice(1)
        };
        const i = e[1] === "+" ? 1 : -1, s = e[2] ? parseInt(e[2], 10) : 0, r = e[3] ? parseInt(e[3], 10) : 0, o = e[5] ? parseInt(e[5], 10) : 0;
        return {
          value: i * (s * xo + r * _o + o * pP),
          rest: t.slice(e[0].length)
        };
      }
      function I_(n) {
        return Se(Pe.anyDigitsSigned, n);
      }
      function Ce(n, t) {
        switch (n) {
          case 1:
            return Se(Pe.singleDigit, t);
          case 2:
            return Se(Pe.twoDigits, t);
          case 3:
            return Se(Pe.threeDigits, t);
          case 4:
            return Se(Pe.fourDigits, t);
          default:
            return Se(new RegExp("^\\d{1," + n + "}"), t);
        }
      }
      function Za(n, t) {
        switch (n) {
          case 1:
            return Se(Pe.singleDigitSigned, t);
          case 2:
            return Se(Pe.twoDigitsSigned, t);
          case 3:
            return Se(Pe.threeDigitsSigned, t);
          case 4:
            return Se(Pe.fourDigitsSigned, t);
          default:
            return Se(new RegExp("^-?\\d{1," + n + "}"), t);
        }
      }
      function Au(n) {
        switch (n) {
          case "morning":
            return 4;
          case "evening":
            return 17;
          case "pm":
          case "noon":
          case "afternoon":
            return 12;
          case "am":
          case "midnight":
          case "night":
          default:
            return 0;
        }
      }
      function O_(n, t) {
        const e = t > 0, i = e ? t : 1 - t;
        let s;
        if (i <= 50) s = n || 100;
        else {
          const r = i + 50, o = Math.trunc(r / 100) * 100, a = n >= r % 100;
          s = n + o - (a ? 100 : 0);
        }
        return e ? s : 1 - s;
      }
      function k_(n) {
        return n % 400 === 0 || n % 4 === 0 && n % 100 !== 0;
      }
      class zD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 130);
          __publicField(this, "incompatibleTokens", [
            "Y",
            "R",
            "u",
            "w",
            "I",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          const s = (r) => ({
            year: r,
            isTwoDigitYear: e === "yy"
          });
          switch (e) {
            case "y":
              return De(Ce(4, t), s);
            case "yo":
              return De(i.ordinalNumber(t, {
                unit: "year"
              }), s);
            default:
              return De(Ce(e.length, t), s);
          }
        }
        validate(t, e) {
          return e.isTwoDigitYear || e.year > 0;
        }
        set(t, e, i) {
          const s = t.getFullYear();
          if (i.isTwoDigitYear) {
            const o = O_(i.year, s);
            return t.setFullYear(o, 0, 1), t.setHours(0, 0, 0, 0), t;
          }
          const r = !("era" in e) || e.era === 1 ? i.year : 1 - i.year;
          return t.setFullYear(r, 0, 1), t.setHours(0, 0, 0, 0), t;
        }
      }
      class HD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 130);
          __publicField(this, "incompatibleTokens", [
            "y",
            "R",
            "u",
            "Q",
            "q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "i",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          const s = (r) => ({
            year: r,
            isTwoDigitYear: e === "YY"
          });
          switch (e) {
            case "Y":
              return De(Ce(4, t), s);
            case "Yo":
              return De(i.ordinalNumber(t, {
                unit: "year"
              }), s);
            default:
              return De(Ce(e.length, t), s);
          }
        }
        validate(t, e) {
          return e.isTwoDigitYear || e.year > 0;
        }
        set(t, e, i, s) {
          const r = Tu(t, s);
          if (i.isTwoDigitYear) {
            const a = O_(i.year, r);
            return t.setFullYear(a, 0, s.firstWeekContainsDate), t.setHours(0, 0, 0, 0), Gn(t, s);
          }
          const o = !("era" in e) || e.era === 1 ? i.year : 1 - i.year;
          return t.setFullYear(o, 0, s.firstWeekContainsDate), t.setHours(0, 0, 0, 0), Gn(t, s);
        }
      }
      class VD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 130);
          __publicField(this, "incompatibleTokens", [
            "G",
            "y",
            "Y",
            "u",
            "Q",
            "q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e) {
          return Za(e === "R" ? 4 : e.length, t);
        }
        set(t, e, i) {
          const s = Ae(t, 0);
          return s.setFullYear(i, 0, 4), s.setHours(0, 0, 0, 0), lr(s);
        }
      }
      class WD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 130);
          __publicField(this, "incompatibleTokens", [
            "G",
            "y",
            "Y",
            "R",
            "w",
            "I",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e) {
          return Za(e === "u" ? 4 : e.length, t);
        }
        set(t, e, i) {
          return t.setFullYear(i, 0, 1), t.setHours(0, 0, 0, 0), t;
        }
      }
      class GD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 120);
          __publicField(this, "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "Q":
            case "QQ":
              return Ce(e.length, t);
            case "Qo":
              return i.ordinalNumber(t, {
                unit: "quarter"
              });
            case "QQQ":
              return i.quarter(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.quarter(t, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQQ":
              return i.quarter(t, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQ":
            default:
              return i.quarter(t, {
                width: "wide",
                context: "formatting"
              }) || i.quarter(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.quarter(t, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
        validate(t, e) {
          return e >= 1 && e <= 4;
        }
        set(t, e, i) {
          return t.setMonth((i - 1) * 3, 1), t.setHours(0, 0, 0, 0), t;
        }
      }
      class XD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 120);
          __publicField(this, "incompatibleTokens", [
            "Y",
            "R",
            "Q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "q":
            case "qq":
              return Ce(e.length, t);
            case "qo":
              return i.ordinalNumber(t, {
                unit: "quarter"
              });
            case "qqq":
              return i.quarter(t, {
                width: "abbreviated",
                context: "standalone"
              }) || i.quarter(t, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqqq":
              return i.quarter(t, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqq":
            default:
              return i.quarter(t, {
                width: "wide",
                context: "standalone"
              }) || i.quarter(t, {
                width: "abbreviated",
                context: "standalone"
              }) || i.quarter(t, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
        validate(t, e) {
          return e >= 1 && e <= 4;
        }
        set(t, e, i) {
          return t.setMonth((i - 1) * 3, 1), t.setHours(0, 0, 0, 0), t;
        }
      }
      class YD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "L",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
          __publicField(this, "priority", 110);
        }
        parse(t, e, i) {
          const s = (r) => r - 1;
          switch (e) {
            case "M":
              return De(Se(Pe.month, t), s);
            case "MM":
              return De(Ce(2, t), s);
            case "Mo":
              return De(i.ordinalNumber(t, {
                unit: "month"
              }), s);
            case "MMM":
              return i.month(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.month(t, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMMM":
              return i.month(t, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMM":
            default:
              return i.month(t, {
                width: "wide",
                context: "formatting"
              }) || i.month(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.month(t, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 11;
        }
        set(t, e, i) {
          return t.setMonth(i, 1), t.setHours(0, 0, 0, 0), t;
        }
      }
      class jD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 110);
          __publicField(this, "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "M",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          const s = (r) => r - 1;
          switch (e) {
            case "L":
              return De(Se(Pe.month, t), s);
            case "LL":
              return De(Ce(2, t), s);
            case "Lo":
              return De(i.ordinalNumber(t, {
                unit: "month"
              }), s);
            case "LLL":
              return i.month(t, {
                width: "abbreviated",
                context: "standalone"
              }) || i.month(t, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLLL":
              return i.month(t, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLL":
            default:
              return i.month(t, {
                width: "wide",
                context: "standalone"
              }) || i.month(t, {
                width: "abbreviated",
                context: "standalone"
              }) || i.month(t, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 11;
        }
        set(t, e, i) {
          return t.setMonth(i, 1), t.setHours(0, 0, 0, 0), t;
        }
      }
      function qD(n, t, e) {
        const i = Vt(n, e == null ? void 0 : e.in), s = A_(i, e) - t;
        return i.setDate(i.getDate() - s * 7), Vt(i, e == null ? void 0 : e.in);
      }
      class $D extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 100);
          __publicField(this, "incompatibleTokens", [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "i",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "w":
              return Se(Pe.week, t);
            case "wo":
              return i.ordinalNumber(t, {
                unit: "week"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 1 && e <= 53;
        }
        set(t, e, i, s) {
          return Gn(qD(t, i, s), s);
        }
      }
      function KD(n, t, e) {
        const i = Vt(n, e == null ? void 0 : e.in), s = T_(i, e) - t;
        return i.setDate(i.getDate() - s * 7), i;
      }
      class ZD extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 100);
          __publicField(this, "incompatibleTokens", [
            "y",
            "Y",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "I":
              return Se(Pe.week, t);
            case "Io":
              return i.ordinalNumber(t, {
                unit: "week"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 1 && e <= 53;
        }
        set(t, e, i) {
          return lr(KD(t, i));
        }
      }
      const QD = [
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
      ], JD = [
        31,
        29,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
      ];
      class t2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 90);
          __publicField(this, "subPriority", 1);
          __publicField(this, "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "w",
            "I",
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "d":
              return Se(Pe.date, t);
            case "do":
              return i.ordinalNumber(t, {
                unit: "date"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          const i = t.getFullYear(), s = k_(i), r = t.getMonth();
          return s ? e >= 1 && e <= JD[r] : e >= 1 && e <= QD[r];
        }
        set(t, e, i) {
          return t.setDate(i), t.setHours(0, 0, 0, 0), t;
        }
      }
      class e2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 90);
          __publicField(this, "subpriority", 1);
          __publicField(this, "incompatibleTokens", [
            "Y",
            "R",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "I",
            "d",
            "E",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "D":
            case "DD":
              return Se(Pe.dayOfYear, t);
            case "Do":
              return i.ordinalNumber(t, {
                unit: "date"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          const i = t.getFullYear();
          return k_(i) ? e >= 1 && e <= 366 : e >= 1 && e <= 365;
        }
        set(t, e, i) {
          return t.setMonth(0, i), t.setHours(0, 0, 0, 0), t;
        }
      }
      function Cu(n, t, e) {
        var _a2, _b2, _c2, _d2;
        const i = xs(), s = (e == null ? void 0 : e.weekStartsOn) ?? ((_b2 = (_a2 = e == null ? void 0 : e.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.weekStartsOn) ?? i.weekStartsOn ?? ((_d2 = (_c2 = i.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.weekStartsOn) ?? 0, r = Vt(n, e == null ? void 0 : e.in), o = r.getDay(), l = (t % 7 + 7) % 7, c = 7 - s, h = t < 0 || t > 6 ? t - (o + c) % 7 : (l + c) % 7 - (o + c) % 7;
        return _l(r, h, e);
      }
      class n2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 90);
          __publicField(this, "incompatibleTokens", [
            "D",
            "i",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "E":
            case "EE":
            case "EEE":
              return i.day(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEE":
              return i.day(t, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEEE":
              return i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEE":
            default:
              return i.day(t, {
                width: "wide",
                context: "formatting"
              }) || i.day(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 6;
        }
        set(t, e, i, s) {
          return t = Cu(t, i, s), t.setHours(0, 0, 0, 0), t;
        }
      }
      class i2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 90);
          __publicField(this, "incompatibleTokens", [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "E",
            "i",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i, s) {
          const r = (o) => {
            const a = Math.floor((o - 1) / 7) * 7;
            return (o + s.weekStartsOn + 6) % 7 + a;
          };
          switch (e) {
            case "e":
            case "ee":
              return De(Ce(e.length, t), r);
            case "eo":
              return De(i.ordinalNumber(t, {
                unit: "day"
              }), r);
            case "eee":
              return i.day(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeee":
              return i.day(t, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeeee":
              return i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              });
            case "eeee":
            default:
              return i.day(t, {
                width: "wide",
                context: "formatting"
              }) || i.day(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 6;
        }
        set(t, e, i, s) {
          return t = Cu(t, i, s), t.setHours(0, 0, 0, 0), t;
        }
      }
      class s2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 90);
          __publicField(this, "incompatibleTokens", [
            "y",
            "R",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "I",
            "d",
            "D",
            "E",
            "i",
            "e",
            "t",
            "T"
          ]);
        }
        parse(t, e, i, s) {
          const r = (o) => {
            const a = Math.floor((o - 1) / 7) * 7;
            return (o + s.weekStartsOn + 6) % 7 + a;
          };
          switch (e) {
            case "c":
            case "cc":
              return De(Ce(e.length, t), r);
            case "co":
              return De(i.ordinalNumber(t, {
                unit: "day"
              }), r);
            case "ccc":
              return i.day(t, {
                width: "abbreviated",
                context: "standalone"
              }) || i.day(t, {
                width: "short",
                context: "standalone"
              }) || i.day(t, {
                width: "narrow",
                context: "standalone"
              });
            case "ccccc":
              return i.day(t, {
                width: "narrow",
                context: "standalone"
              });
            case "cccccc":
              return i.day(t, {
                width: "short",
                context: "standalone"
              }) || i.day(t, {
                width: "narrow",
                context: "standalone"
              });
            case "cccc":
            default:
              return i.day(t, {
                width: "wide",
                context: "standalone"
              }) || i.day(t, {
                width: "abbreviated",
                context: "standalone"
              }) || i.day(t, {
                width: "short",
                context: "standalone"
              }) || i.day(t, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 6;
        }
        set(t, e, i, s) {
          return t = Cu(t, i, s), t.setHours(0, 0, 0, 0), t;
        }
      }
      function r2(n, t, e) {
        const i = Vt(n, e == null ? void 0 : e.in), s = ID(i, e), r = t - s;
        return _l(i, r, e);
      }
      class o2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 90);
          __publicField(this, "incompatibleTokens", [
            "y",
            "Y",
            "u",
            "q",
            "Q",
            "M",
            "L",
            "w",
            "d",
            "D",
            "E",
            "e",
            "c",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          const s = (r) => r === 0 ? 7 : r;
          switch (e) {
            case "i":
            case "ii":
              return Ce(e.length, t);
            case "io":
              return i.ordinalNumber(t, {
                unit: "day"
              });
            case "iii":
              return De(i.day(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              }), s);
            case "iiiii":
              return De(i.day(t, {
                width: "narrow",
                context: "formatting"
              }), s);
            case "iiiiii":
              return De(i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              }), s);
            case "iiii":
            default:
              return De(i.day(t, {
                width: "wide",
                context: "formatting"
              }) || i.day(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.day(t, {
                width: "short",
                context: "formatting"
              }) || i.day(t, {
                width: "narrow",
                context: "formatting"
              }), s);
          }
        }
        validate(t, e) {
          return e >= 1 && e <= 7;
        }
        set(t, e, i) {
          return t = r2(t, i), t.setHours(0, 0, 0, 0), t;
        }
      }
      class a2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 80);
          __publicField(this, "incompatibleTokens", [
            "b",
            "B",
            "H",
            "k",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "a":
            case "aa":
            case "aaa":
              return i.dayPeriod(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaaa":
              return i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaa":
            default:
              return i.dayPeriod(t, {
                width: "wide",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
        set(t, e, i) {
          return t.setHours(Au(i), 0, 0, 0), t;
        }
      }
      class l2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 80);
          __publicField(this, "incompatibleTokens", [
            "a",
            "B",
            "H",
            "k",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "b":
            case "bb":
            case "bbb":
              return i.dayPeriod(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbbb":
              return i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbb":
            default:
              return i.dayPeriod(t, {
                width: "wide",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
        set(t, e, i) {
          return t.setHours(Au(i), 0, 0, 0), t;
        }
      }
      class c2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 80);
          __publicField(this, "incompatibleTokens", [
            "a",
            "b",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "B":
            case "BB":
            case "BBB":
              return i.dayPeriod(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBBB":
              return i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBB":
            default:
              return i.dayPeriod(t, {
                width: "wide",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "abbreviated",
                context: "formatting"
              }) || i.dayPeriod(t, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
        set(t, e, i) {
          return t.setHours(Au(i), 0, 0, 0), t;
        }
      }
      class h2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 70);
          __publicField(this, "incompatibleTokens", [
            "H",
            "K",
            "k",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "h":
              return Se(Pe.hour12h, t);
            case "ho":
              return i.ordinalNumber(t, {
                unit: "hour"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 1 && e <= 12;
        }
        set(t, e, i) {
          const s = t.getHours() >= 12;
          return s && i < 12 ? t.setHours(i + 12, 0, 0, 0) : !s && i === 12 ? t.setHours(0, 0, 0, 0) : t.setHours(i, 0, 0, 0), t;
        }
      }
      class u2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 70);
          __publicField(this, "incompatibleTokens", [
            "a",
            "b",
            "h",
            "K",
            "k",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "H":
              return Se(Pe.hour23h, t);
            case "Ho":
              return i.ordinalNumber(t, {
                unit: "hour"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 23;
        }
        set(t, e, i) {
          return t.setHours(i, 0, 0, 0), t;
        }
      }
      class d2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 70);
          __publicField(this, "incompatibleTokens", [
            "h",
            "H",
            "k",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "K":
              return Se(Pe.hour11h, t);
            case "Ko":
              return i.ordinalNumber(t, {
                unit: "hour"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 11;
        }
        set(t, e, i) {
          return t.getHours() >= 12 && i < 12 ? t.setHours(i + 12, 0, 0, 0) : t.setHours(i, 0, 0, 0), t;
        }
      }
      class f2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 70);
          __publicField(this, "incompatibleTokens", [
            "a",
            "b",
            "h",
            "H",
            "K",
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "k":
              return Se(Pe.hour24h, t);
            case "ko":
              return i.ordinalNumber(t, {
                unit: "hour"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 1 && e <= 24;
        }
        set(t, e, i) {
          const s = i <= 24 ? i % 24 : i;
          return t.setHours(s, 0, 0, 0), t;
        }
      }
      class p2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 60);
          __publicField(this, "incompatibleTokens", [
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "m":
              return Se(Pe.minute, t);
            case "mo":
              return i.ordinalNumber(t, {
                unit: "minute"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 59;
        }
        set(t, e, i) {
          return t.setMinutes(i, 0, 0), t;
        }
      }
      class m2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 50);
          __publicField(this, "incompatibleTokens", [
            "t",
            "T"
          ]);
        }
        parse(t, e, i) {
          switch (e) {
            case "s":
              return Se(Pe.second, t);
            case "so":
              return i.ordinalNumber(t, {
                unit: "second"
              });
            default:
              return Ce(e.length, t);
          }
        }
        validate(t, e) {
          return e >= 0 && e <= 59;
        }
        set(t, e, i) {
          return t.setSeconds(i, 0), t;
        }
      }
      class g2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 30);
          __publicField(this, "incompatibleTokens", [
            "t",
            "T"
          ]);
        }
        parse(t, e) {
          const i = (s) => Math.trunc(s * Math.pow(10, -e.length + 3));
          return De(Ce(e.length, t), i);
        }
        set(t, e, i) {
          return t.setMilliseconds(i), t;
        }
      }
      class _2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 10);
          __publicField(this, "incompatibleTokens", [
            "t",
            "T",
            "x"
          ]);
        }
        parse(t, e) {
          switch (e) {
            case "X":
              return zn(Bn.basicOptionalMinutes, t);
            case "XX":
              return zn(Bn.basic, t);
            case "XXXX":
              return zn(Bn.basicOptionalSeconds, t);
            case "XXXXX":
              return zn(Bn.extendedOptionalSeconds, t);
            case "XXX":
            default:
              return zn(Bn.extended, t);
          }
        }
        set(t, e, i) {
          return e.timestampIsSet ? t : Ae(t, t.getTime() - Ka(t) - i);
        }
      }
      class x2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 10);
          __publicField(this, "incompatibleTokens", [
            "t",
            "T",
            "X"
          ]);
        }
        parse(t, e) {
          switch (e) {
            case "x":
              return zn(Bn.basicOptionalMinutes, t);
            case "xx":
              return zn(Bn.basic, t);
            case "xxxx":
              return zn(Bn.basicOptionalSeconds, t);
            case "xxxxx":
              return zn(Bn.extendedOptionalSeconds, t);
            case "xxx":
            default:
              return zn(Bn.extended, t);
          }
        }
        set(t, e, i) {
          return e.timestampIsSet ? t : Ae(t, t.getTime() - Ka(t) - i);
        }
      }
      class b2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 40);
          __publicField(this, "incompatibleTokens", "*");
        }
        parse(t) {
          return I_(t);
        }
        set(t, e, i) {
          return [
            Ae(t, i * 1e3),
            {
              timestampIsSet: true
            }
          ];
        }
      }
      class y2 extends ie {
        constructor() {
          super(...arguments);
          __publicField(this, "priority", 20);
          __publicField(this, "incompatibleTokens", "*");
        }
        parse(t) {
          return I_(t);
        }
        set(t, e, i) {
          return [
            Ae(t, i),
            {
              timestampIsSet: true
            }
          ];
        }
      }
      const v2 = {
        G: new BD(),
        y: new zD(),
        Y: new HD(),
        R: new VD(),
        u: new WD(),
        Q: new GD(),
        q: new XD(),
        M: new YD(),
        L: new jD(),
        w: new $D(),
        I: new ZD(),
        d: new t2(),
        D: new e2(),
        E: new n2(),
        e: new i2(),
        c: new s2(),
        i: new o2(),
        a: new a2(),
        b: new l2(),
        B: new c2(),
        h: new h2(),
        H: new u2(),
        K: new d2(),
        k: new f2(),
        m: new p2(),
        s: new m2(),
        S: new g2(),
        X: new _2(),
        x: new x2(),
        t: new b2(),
        T: new y2()
      }, M2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, S2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, w2 = /^'([^]*?)'?$/, E2 = /''/g, T2 = /\S/, A2 = /[a-zA-Z]/;
      function C2(n, t, e, i) {
        var _a2, _b2, _c2, _d2, _e, _f2, _g2, _h2;
        const s = () => Ae((i == null ? void 0 : i.in) || e, NaN), r = LD(), o = (i == null ? void 0 : i.locale) ?? r.locale ?? E_, a = (i == null ? void 0 : i.firstWeekContainsDate) ?? ((_b2 = (_a2 = i == null ? void 0 : i.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((_d2 = (_c2 = r.locale) == null ? void 0 : _c2.options) == null ? void 0 : _d2.firstWeekContainsDate) ?? 1, l = (i == null ? void 0 : i.weekStartsOn) ?? ((_f2 = (_e = i == null ? void 0 : i.locale) == null ? void 0 : _e.options) == null ? void 0 : _f2.weekStartsOn) ?? r.weekStartsOn ?? ((_h2 = (_g2 = r.locale) == null ? void 0 : _g2.options) == null ? void 0 : _h2.weekStartsOn) ?? 0;
        if (!t) return n ? s() : Vt(e, i == null ? void 0 : i.in);
        const c = {
          firstWeekContainsDate: a,
          weekStartsOn: l,
          locale: o
        }, h = [
          new UD(i == null ? void 0 : i.in, e)
        ], u = t.match(S2).map((m) => {
          const p = m[0];
          if (p in Ph) {
            const y = Ph[p];
            return y(m, o.formatLong);
          }
          return m;
        }).join("").match(M2), d = [];
        for (let m of u) {
          !(i == null ? void 0 : i.useAdditionalWeekYearTokens) && P_(m) && Dh(m, t, n), !(i == null ? void 0 : i.useAdditionalDayOfYearTokens) && R_(m) && Dh(m, t, n);
          const p = m[0], y = v2[p];
          if (y) {
            const { incompatibleTokens: w } = y;
            if (Array.isArray(w)) {
              const C = d.find((R) => w.includes(R.token) || R.token === p);
              if (C) throw new RangeError(`The format string mustn't contain \`${C.fullToken}\` and \`${m}\` at the same time`);
            } else if (y.incompatibleTokens === "*" && d.length > 0) throw new RangeError(`The format string mustn't contain \`${m}\` and any other token at the same time`);
            d.push({
              token: p,
              fullToken: m
            });
            const M = y.run(n, m, o.match, c);
            if (!M) return s();
            h.push(M.setter), n = M.rest;
          } else {
            if (p.match(A2)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + p + "`");
            if (m === "''" ? m = "'" : p === "'" && (m = R2(m)), n.indexOf(m) === 0) n = n.slice(m.length);
            else return s();
          }
        }
        if (n.length > 0 && T2.test(n)) return s();
        const f = h.map((m) => m.priority).sort((m, p) => p - m).filter((m, p, y) => y.indexOf(m) === p).map((m) => h.filter((p) => p.priority === m).sort((p, y) => y.subPriority - p.subPriority)).map((m) => m[0]);
        let g = Vt(e, i == null ? void 0 : i.in);
        if (isNaN(+g)) return s();
        const _ = {};
        for (const m of f) {
          if (!m.validate(g, c)) return s();
          const p = m.set(g, _, c);
          Array.isArray(p) ? (g = p[0], Object.assign(_, p[1])) : g = p;
        }
        return g;
      }
      function R2(n) {
        return n.match(w2)[1].replace(E2, "'");
      }
      function P2(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setMinutes(0, 0, 0), e;
      }
      function D2(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setSeconds(0, 0), e;
      }
      function L2(n, t) {
        const e = Vt(n, t == null ? void 0 : t.in);
        return e.setMilliseconds(0), e;
      }
      function I2(n, t) {
        const e = () => Ae(t == null ? void 0 : t.in, NaN), i = (t == null ? void 0 : t.additionalDigits) ?? 2, s = N2(n);
        let r;
        if (s.date) {
          const c = U2(s.date, i);
          r = B2(c.restDateString, c.year);
        }
        if (!r || isNaN(+r)) return e();
        const o = +r;
        let a = 0, l;
        if (s.time && (a = z2(s.time), isNaN(a))) return e();
        if (s.timezone) {
          if (l = H2(s.timezone), isNaN(l)) return e();
        } else {
          const c = new Date(o + a), h = Vt(0, t == null ? void 0 : t.in);
          return h.setFullYear(c.getUTCFullYear(), c.getUTCMonth(), c.getUTCDate()), h.setHours(c.getUTCHours(), c.getUTCMinutes(), c.getUTCSeconds(), c.getUTCMilliseconds()), h;
        }
        return Vt(o + a + l, t == null ? void 0 : t.in);
      }
      const ma = {
        dateTimeDelimiter: /[T ]/,
        timeZoneDelimiter: /[Z ]/i,
        timezone: /([Z+-].*)$/
      }, O2 = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, k2 = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, F2 = /^([+-])(\d{2})(?::?(\d{2}))?$/;
      function N2(n) {
        const t = {}, e = n.split(ma.dateTimeDelimiter);
        let i;
        if (e.length > 2) return t;
        if (/:/.test(e[0]) ? i = e[0] : (t.date = e[0], i = e[1], ma.timeZoneDelimiter.test(t.date) && (t.date = n.split(ma.timeZoneDelimiter)[0], i = n.substr(t.date.length, n.length))), i) {
          const s = ma.timezone.exec(i);
          s ? (t.time = i.replace(s[1], ""), t.timezone = s[1]) : t.time = i;
        }
        return t;
      }
      function U2(n, t) {
        const e = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)"), i = n.match(e);
        if (!i) return {
          year: NaN,
          restDateString: ""
        };
        const s = i[1] ? parseInt(i[1]) : null, r = i[2] ? parseInt(i[2]) : null;
        return {
          year: r === null ? s : r * 100,
          restDateString: n.slice((i[1] || i[2]).length)
        };
      }
      function B2(n, t) {
        if (t === null) return /* @__PURE__ */ new Date(NaN);
        const e = n.match(O2);
        if (!e) return /* @__PURE__ */ new Date(NaN);
        const i = !!e[4], s = Ir(e[1]), r = Ir(e[2]) - 1, o = Ir(e[3]), a = Ir(e[4]), l = Ir(e[5]) - 1;
        if (i) return Y2(t, a, l) ? V2(t, a, l) : /* @__PURE__ */ new Date(NaN);
        {
          const c = /* @__PURE__ */ new Date(0);
          return !G2(t, r, o) || !X2(t, s) ? /* @__PURE__ */ new Date(NaN) : (c.setUTCFullYear(t, r, Math.max(s, o)), c);
        }
      }
      function Ir(n) {
        return n ? parseInt(n) : 1;
      }
      function z2(n) {
        const t = n.match(k2);
        if (!t) return NaN;
        const e = xc(t[1]), i = xc(t[2]), s = xc(t[3]);
        return j2(e, i, s) ? e * xo + i * _o + s * 1e3 : NaN;
      }
      function xc(n) {
        return n && parseFloat(n.replace(",", ".")) || 0;
      }
      function H2(n) {
        if (n === "Z") return 0;
        const t = n.match(F2);
        if (!t) return 0;
        const e = t[1] === "+" ? -1 : 1, i = parseInt(t[2]), s = t[3] && parseInt(t[3]) || 0;
        return q2(i, s) ? e * (i * xo + s * _o) : NaN;
      }
      function V2(n, t, e) {
        const i = /* @__PURE__ */ new Date(0);
        i.setUTCFullYear(n, 0, 4);
        const s = i.getUTCDay() || 7, r = (t - 1) * 7 + e + 1 - s;
        return i.setUTCDate(i.getUTCDate() + r), i;
      }
      const W2 = [
        31,
        null,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
      ];
      function F_(n) {
        return n % 400 === 0 || n % 4 === 0 && n % 100 !== 0;
      }
      function G2(n, t, e) {
        return t >= 0 && t <= 11 && e >= 1 && e <= (W2[t] || (F_(n) ? 29 : 28));
      }
      function X2(n, t) {
        return t >= 1 && t <= (F_(n) ? 366 : 365);
      }
      function Y2(n, t, e) {
        return t >= 1 && t <= 53 && e >= 0 && e <= 6;
      }
      function j2(n, t, e) {
        return n === 24 ? t === 0 && e === 0 : e >= 0 && e < 60 && t >= 0 && t < 60 && n >= 0 && n < 25;
      }
      function q2(n, t) {
        return t >= 0 && t <= 59;
      }
      const $2 = {
        datetime: "MMM d, yyyy, h:mm:ss aaaa",
        millisecond: "h:mm:ss.SSS aaaa",
        second: "h:mm:ss aaaa",
        minute: "h:mm aaaa",
        hour: "ha",
        day: "MMM d",
        week: "PP",
        month: "MMM yyyy",
        quarter: "qqq - yyyy",
        year: "yyyy"
      };
      Eg._date.override({
        _id: "date-fns",
        formats: function() {
          return $2;
        },
        parse: function(n, t) {
          if (n === null || typeof n > "u") return null;
          const e = typeof n;
          return e === "number" || n instanceof Date ? n = Vt(n) : e === "string" && (typeof t == "string" ? n = C2(n, t, /* @__PURE__ */ new Date(), this.options) : n = I2(n, this.options)), b_(n) ? n.getTime() : null;
        },
        format: function(n, t) {
          return D_(n, t, this.options);
        },
        add: function(n, t, e) {
          switch (e) {
            case "millisecond":
              return wu(n, t);
            case "second":
              return yP(n, t);
            case "minute":
              return xP(n, t);
            case "hour":
              return mP(n, t);
            case "day":
              return _l(n, t);
            case "week":
              return vP(n, t);
            case "month":
              return Su(n, t);
            case "quarter":
              return bP(n, t);
            case "year":
              return MP(n, t);
            default:
              return n;
          }
        },
        diff: function(n, t, e) {
          switch (e) {
            case "millisecond":
              return Eu(n, t);
            case "second":
              return PP(n, t);
            case "minute":
              return AP(n, t);
            case "hour":
              return TP(n, t);
            case "day":
              return y_(n, t);
            case "week":
              return DP(n, t);
            case "month":
              return S_(n, t);
            case "quarter":
              return RP(n, t);
            case "year":
              return LP(n, t);
            default:
              return 0;
          }
        },
        startOf: function(n, t, e) {
          switch (t) {
            case "second":
              return L2(n);
            case "minute":
              return D2(n);
            case "hour":
              return P2(n);
            case "day":
              return Rh(n);
            case "week":
              return Gn(n);
            case "isoWeek":
              return Gn(n, {
                weekStartsOn: +e
              });
            case "month":
              return OP(n);
            case "quarter":
              return IP(n);
            case "year":
              return w_(n);
            default:
              return n;
          }
        },
        endOf: function(n, t) {
          switch (t) {
            case "second":
              return zP(n);
            case "minute":
              return UP(n);
            case "hour":
              return FP(n);
            case "day":
              return v_(n);
            case "week":
              return NP(n);
            case "month":
              return M_(n);
            case "quarter":
              return BP(n);
            case "year":
              return kP(n);
            default:
              return n;
          }
        }
      });
      Ri.register(hP);
      const K2 = ({ data: n, strikePrice: t, callBreakeven: e, putBreakeven: i, purchaseDate: s, expirationDate: r }) => {
        const o = Zs(null), a = Zs(null);
        return Xs(() => {
          var _a2;
          (!(n == null ? void 0 : n.data) || a.current) && ((_a2 = a.current) == null ? void 0 : _a2.destroy());
          const l = o.current.getContext("2d"), c = n.data.map((u) => ({
            x: new Date(u.date),
            y: parseFloat(u.close)
          })).sort((u, d) => u.x - d.x), h = n.data.map((u) => ({
            x: new Date(u.date),
            y: parseInt(u.volume)
          })).sort((u, d) => u.x - d.x);
          return a.current = new Ri(l, {
            type: "line",
            data: {
              datasets: [
                {
                  label: "Stock Price",
                  data: c,
                  borderColor: "#2196f3",
                  borderWidth: 1,
                  pointRadius: 0,
                  fill: false,
                  yAxisID: "y"
                },
                {
                  label: "Volume",
                  data: h,
                  type: "bar",
                  backgroundColor: "rgba(169, 169, 169, 0.3)",
                  borderColor: "rgba(169, 169, 169, 0.5)",
                  yAxisID: "y1"
                },
                {
                  label: "Strike Price",
                  data: c.map((u) => ({
                    x: u.x,
                    y: t
                  })),
                  borderColor: "rgba(255, 99, 132, 0.8)",
                  borderWidth: 1,
                  borderDash: [
                    10,
                    5
                  ],
                  pointRadius: 0,
                  yAxisID: "y"
                },
                {
                  label: "Call Breakeven",
                  data: c.map((u) => ({
                    x: u.x,
                    y: e
                  })),
                  borderColor: "rgba(75, 192, 192, 0.8)",
                  borderWidth: 1,
                  borderDash: [
                    10,
                    5
                  ],
                  pointRadius: 0,
                  yAxisID: "y"
                },
                {
                  label: "Put Breakeven",
                  data: c.map((u) => ({
                    x: u.x,
                    y: i
                  })),
                  borderColor: "rgba(153, 102, 255, 0.8)",
                  borderWidth: 1,
                  borderDash: [
                    10,
                    5
                  ],
                  pointRadius: 0,
                  yAxisID: "y"
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: "index",
                intersect: false
              },
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "month",
                    stepSize: 3,
                    displayFormats: {
                      month: "MMM yyyy"
                    }
                  },
                  ticks: {
                    maxTicksLimit: 12,
                    autoSkip: true
                  }
                },
                y: {
                  type: "linear",
                  display: true,
                  position: "left",
                  title: {
                    display: true,
                    text: "Price ($)"
                  }
                },
                y1: {
                  type: "linear",
                  display: true,
                  position: "right",
                  title: {
                    display: true,
                    text: "Volume"
                  },
                  grid: {
                    drawOnChartArea: false
                  }
                }
              },
              plugins: {
                tooltip: {
                  callbacks: {
                    title: (u) => D_(new Date(u[0].parsed.x), "MMM d, yyyy"),
                    label: (u) => {
                      const d = u.dataset.label, f = u.parsed.y;
                      return `${d}: ${d === "Volume" ? f.toLocaleString() : f.toFixed(2)}`;
                    }
                  }
                },
                annotation: {
                  common: {
                    drawTime: "afterDraw"
                  },
                  annotations: {
                    purchaseDate: {
                      type: "line",
                      scaleID: "x",
                      value: s,
                      borderColor: "rgba(75, 192, 75, 0.8)",
                      borderWidth: 2,
                      borderDash: [
                        20,
                        5
                      ],
                      label: {
                        content: "Purchase",
                        display: true,
                        position: "start"
                      }
                    },
                    expirationDate: {
                      type: "line",
                      scaleID: "x",
                      value: r,
                      borderColor: "rgba(75, 192, 75, 0.8)",
                      borderWidth: 2,
                      borderDash: [
                        20,
                        5
                      ],
                      label: {
                        content: "Expiry",
                        display: true,
                        position: "start"
                      }
                    }
                  }
                }
              }
            }
          }), () => {
            a.current && a.current.destroy();
          };
        }, [
          n,
          t,
          e,
          i,
          s,
          r
        ]), $("div", {
          class: "github-card p-4",
          children: $("div", {
            style: "height: 400px",
            children: $("canvas", {
              ref: o
            })
          })
        });
      };
      function Z2(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
      }
      var Ra = {
        exports: {}
      };
      var Q2 = Ra.exports, tm;
      function J2() {
        return tm || (tm = 1, function(n, t) {
          ((e, i) => {
            n.exports = i();
          })(Q2, function e() {
            var i = typeof self < "u" ? self : typeof window < "u" ? window : i !== void 0 ? i : {}, s, r = !i.document && !!i.postMessage, o = i.IS_PAPA_WORKER || false, a = {}, l = 0, c = {};
            function h(v) {
              this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = {
                data: [],
                errors: [],
                meta: {}
              }, (function(x) {
                var b = C(x);
                b.chunkSize = parseInt(b.chunkSize), x.step || x.chunk || (b.chunkSize = null), this._handle = new _(b), (this._handle.streamer = this)._config = b;
              }).call(this, v), this.parseChunk = function(x, b) {
                var A = parseInt(this._config.skipFirstNLines) || 0;
                if (this.isFirstChunk && 0 < A) {
                  let I = this._config.newline;
                  I || (L = this._config.quoteChar || '"', I = this._handle.guessLineEndings(x, L)), x = [
                    ...x.split(I).slice(A)
                  ].join(I);
                }
                this.isFirstChunk && T(this._config.beforeFirstChunk) && (L = this._config.beforeFirstChunk(x)) !== void 0 && (x = L), this.isFirstChunk = false, this._halted = false;
                var A = this._partialLine + x, L = (this._partialLine = "", this._handle.parse(A, this._baseIndex, !this._finished));
                if (!this._handle.paused() && !this._handle.aborted()) {
                  if (x = L.meta.cursor, A = (this._finished || (this._partialLine = A.substring(x - this._baseIndex), this._baseIndex = x), L && L.data && (this._rowCount += L.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), o) i.postMessage({
                    results: L,
                    workerId: c.WORKER_ID,
                    finished: A
                  });
                  else if (T(this._config.chunk) && !b) {
                    if (this._config.chunk(L, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = true);
                    this._completeResults = L = void 0;
                  }
                  return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(L.data), this._completeResults.errors = this._completeResults.errors.concat(L.errors), this._completeResults.meta = L.meta), this._completed || !A || !T(this._config.complete) || L && L.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), A || L && L.meta.paused || this._nextChunk(), L;
                }
                this._halted = true;
              }, this._sendError = function(x) {
                T(this._config.error) ? this._config.error(x) : o && this._config.error && i.postMessage({
                  workerId: c.WORKER_ID,
                  error: x,
                  finished: false
                });
              };
            }
            function u(v) {
              var x;
              (v = v || {}).chunkSize || (v.chunkSize = c.RemoteChunkSize), h.call(this, v), this._nextChunk = r ? function() {
                this._readChunk(), this._chunkLoaded();
              } : function() {
                this._readChunk();
              }, this.stream = function(b) {
                this._input = b, this._nextChunk();
              }, this._readChunk = function() {
                if (this._finished) this._chunkLoaded();
                else {
                  if (x = new XMLHttpRequest(), this._config.withCredentials && (x.withCredentials = this._config.withCredentials), r || (x.onload = R(this._chunkLoaded, this), x.onerror = R(this._chunkError, this)), x.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !r), this._config.downloadRequestHeaders) {
                    var b, A = this._config.downloadRequestHeaders;
                    for (b in A) x.setRequestHeader(b, A[b]);
                  }
                  var L;
                  this._config.chunkSize && (L = this._start + this._config.chunkSize - 1, x.setRequestHeader("Range", "bytes=" + this._start + "-" + L));
                  try {
                    x.send(this._config.downloadRequestBody);
                  } catch (I) {
                    this._chunkError(I.message);
                  }
                  r && x.status === 0 && this._chunkError();
                }
              }, this._chunkLoaded = function() {
                x.readyState === 4 && (x.status < 200 || 400 <= x.status ? this._chunkError() : (this._start += this._config.chunkSize || x.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((b) => (b = b.getResponseHeader("Content-Range")) !== null ? parseInt(b.substring(b.lastIndexOf("/") + 1)) : -1)(x), this.parseChunk(x.responseText)));
              }, this._chunkError = function(b) {
                b = x.statusText || b, this._sendError(new Error(b));
              };
            }
            function d(v) {
              (v = v || {}).chunkSize || (v.chunkSize = c.LocalChunkSize), h.call(this, v);
              var x, b, A = typeof FileReader < "u";
              this.stream = function(L) {
                this._input = L, b = L.slice || L.webkitSlice || L.mozSlice, A ? ((x = new FileReader()).onload = R(this._chunkLoaded, this), x.onerror = R(this._chunkError, this)) : x = new FileReaderSync(), this._nextChunk();
              }, this._nextChunk = function() {
                this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
              }, this._readChunk = function() {
                var L = this._input, I = (this._config.chunkSize && (I = Math.min(this._start + this._config.chunkSize, this._input.size), L = b.call(L, this._start, I)), x.readAsText(L, this._config.encoding));
                A || this._chunkLoaded({
                  target: {
                    result: I
                  }
                });
              }, this._chunkLoaded = function(L) {
                this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(L.target.result);
              }, this._chunkError = function() {
                this._sendError(x.error);
              };
            }
            function f(v) {
              var x;
              h.call(this, v = v || {}), this.stream = function(b) {
                return x = b, this._nextChunk();
              }, this._nextChunk = function() {
                var b, A;
                if (!this._finished) return b = this._config.chunkSize, x = b ? (A = x.substring(0, b), x.substring(b)) : (A = x, ""), this._finished = !x, this.parseChunk(A);
              };
            }
            function g(v) {
              h.call(this, v = v || {});
              var x = [], b = true, A = false;
              this.pause = function() {
                h.prototype.pause.apply(this, arguments), this._input.pause();
              }, this.resume = function() {
                h.prototype.resume.apply(this, arguments), this._input.resume();
              }, this.stream = function(L) {
                this._input = L, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
              }, this._checkIsFinished = function() {
                A && x.length === 1 && (this._finished = true);
              }, this._nextChunk = function() {
                this._checkIsFinished(), x.length ? this.parseChunk(x.shift()) : b = true;
              }, this._streamData = R(function(L) {
                try {
                  x.push(typeof L == "string" ? L : L.toString(this._config.encoding)), b && (b = false, this._checkIsFinished(), this.parseChunk(x.shift()));
                } catch (I) {
                  this._streamError(I);
                }
              }, this), this._streamError = R(function(L) {
                this._streamCleanUp(), this._sendError(L);
              }, this), this._streamEnd = R(function() {
                this._streamCleanUp(), A = true, this._streamData("");
              }, this), this._streamCleanUp = R(function() {
                this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
              }, this);
            }
            function _(v) {
              var x, b, A, L, I = Math.pow(2, 53), H = -I, j = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, z = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, V = this, U = 0, q = 0, rt = false, et = false, ut = [], ot = {
                data: [],
                errors: [],
                meta: {}
              };
              function W(it) {
                return v.skipEmptyLines === "greedy" ? it.join("").trim() === "" : it.length === 1 && it[0].length === 0;
              }
              function J() {
                if (ot && A && (ht("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + c.DefaultDelimiter + "'"), A = false), v.skipEmptyLines && (ot.data = ot.data.filter(function(dt) {
                  return !W(dt);
                })), ct()) {
                  let dt = function(wt, bt) {
                    T(v.transformHeader) && (wt = v.transformHeader(wt, bt)), ut.push(wt);
                  };
                  if (ot) if (Array.isArray(ot.data[0])) {
                    for (var it = 0; ct() && it < ot.data.length; it++) ot.data[it].forEach(dt);
                    ot.data.splice(0, 1);
                  } else ot.data.forEach(dt);
                }
                function St(dt, wt) {
                  for (var bt = v.header ? {} : [], D = 0; D < dt.length; D++) {
                    var zt = D, ft = dt[D], ft = ((Lt, st) => ((Rt) => (v.dynamicTypingFunction && v.dynamicTyping[Rt] === void 0 && (v.dynamicTyping[Rt] = v.dynamicTypingFunction(Rt)), (v.dynamicTyping[Rt] || v.dynamicTyping) === true))(Lt) ? st === "true" || st === "TRUE" || st !== "false" && st !== "FALSE" && (((Rt) => {
                      if (j.test(Rt) && (Rt = parseFloat(Rt), H < Rt && Rt < I)) return 1;
                    })(st) ? parseFloat(st) : z.test(st) ? new Date(st) : st === "" ? null : st) : st)(zt = v.header ? D >= ut.length ? "__parsed_extra" : ut[D] : zt, ft = v.transform ? v.transform(ft, zt) : ft);
                    zt === "__parsed_extra" ? (bt[zt] = bt[zt] || [], bt[zt].push(ft)) : bt[zt] = ft;
                  }
                  return v.header && (D > ut.length ? ht("FieldMismatch", "TooManyFields", "Too many fields: expected " + ut.length + " fields but parsed " + D, q + wt) : D < ut.length && ht("FieldMismatch", "TooFewFields", "Too few fields: expected " + ut.length + " fields but parsed " + D, q + wt)), bt;
                }
                var lt;
                ot && (v.header || v.dynamicTyping || v.transform) && (lt = 1, !ot.data.length || Array.isArray(ot.data[0]) ? (ot.data = ot.data.map(St), lt = ot.data.length) : ot.data = St(ot.data, 0), v.header && ot.meta && (ot.meta.fields = ut), q += lt);
              }
              function ct() {
                return v.header && ut.length === 0;
              }
              function ht(it, St, lt, dt) {
                it = {
                  type: it,
                  code: St,
                  message: lt
                }, dt !== void 0 && (it.row = dt), ot.errors.push(it);
              }
              T(v.step) && (L = v.step, v.step = function(it) {
                ot = it, ct() ? J() : (J(), ot.data.length !== 0 && (U += it.data.length, v.preview && U > v.preview ? b.abort() : (ot.data = ot.data[0], L(ot, V))));
              }), this.parse = function(it, St, lt) {
                var dt = v.quoteChar || '"', dt = (v.newline || (v.newline = this.guessLineEndings(it, dt)), A = false, v.delimiter ? T(v.delimiter) && (v.delimiter = v.delimiter(it), ot.meta.delimiter = v.delimiter) : ((dt = ((wt, bt, D, zt, ft) => {
                  var Lt, st, Rt, Et;
                  ft = ft || [
                    ",",
                    "	",
                    "|",
                    ";",
                    c.RECORD_SEP,
                    c.UNIT_SEP
                  ];
                  for (var P = 0; P < ft.length; P++) {
                    for (var S, B = ft[P], K = 0, Q = 0, X = 0, _t = (Rt = void 0, new p({
                      comments: zt,
                      delimiter: B,
                      newline: bt,
                      preview: 10
                    }).parse(wt)), pt = 0; pt < _t.data.length; pt++) D && W(_t.data[pt]) ? X++ : (S = _t.data[pt].length, Q += S, Rt === void 0 ? Rt = S : 0 < S && (K += Math.abs(S - Rt), Rt = S));
                    0 < _t.data.length && (Q /= _t.data.length - X), (st === void 0 || K <= st) && (Et === void 0 || Et < Q) && 1.99 < Q && (st = K, Lt = B, Et = Q);
                  }
                  return {
                    successful: !!(v.delimiter = Lt),
                    bestDelimiter: Lt
                  };
                })(it, v.newline, v.skipEmptyLines, v.comments, v.delimitersToGuess)).successful ? v.delimiter = dt.bestDelimiter : (A = true, v.delimiter = c.DefaultDelimiter), ot.meta.delimiter = v.delimiter), C(v));
                return v.preview && v.header && dt.preview++, x = it, b = new p(dt), ot = b.parse(x, St, lt), J(), rt ? {
                  meta: {
                    paused: true
                  }
                } : ot || {
                  meta: {
                    paused: false
                  }
                };
              }, this.paused = function() {
                return rt;
              }, this.pause = function() {
                rt = true, b.abort(), x = T(v.chunk) ? "" : x.substring(b.getCharIndex());
              }, this.resume = function() {
                V.streamer._halted ? (rt = false, V.streamer.parseChunk(x, true)) : setTimeout(V.resume, 3);
              }, this.aborted = function() {
                return et;
              }, this.abort = function() {
                et = true, b.abort(), ot.meta.aborted = true, T(v.complete) && v.complete(ot), x = "";
              }, this.guessLineEndings = function(wt, dt) {
                wt = wt.substring(0, 1048576);
                var dt = new RegExp(m(dt) + "([^]*?)" + m(dt), "gm"), lt = (wt = wt.replace(dt, "")).split("\r"), dt = wt.split(`
`), wt = 1 < dt.length && dt[0].length < lt[0].length;
                if (lt.length === 1 || wt) return `
`;
                for (var bt = 0, D = 0; D < lt.length; D++) lt[D][0] === `
` && bt++;
                return bt >= lt.length / 2 ? `\r
` : "\r";
              };
            }
            function m(v) {
              return v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }
            function p(v) {
              var x = (v = v || {}).delimiter, b = v.newline, A = v.comments, L = v.step, I = v.preview, H = v.fastMode, j = null, z = false, V = v.quoteChar == null ? '"' : v.quoteChar, U = V;
              if (v.escapeChar !== void 0 && (U = v.escapeChar), (typeof x != "string" || -1 < c.BAD_DELIMITERS.indexOf(x)) && (x = ","), A === x) throw new Error("Comment character same as delimiter");
              A === true ? A = "#" : (typeof A != "string" || -1 < c.BAD_DELIMITERS.indexOf(A)) && (A = false), b !== `
` && b !== "\r" && b !== `\r
` && (b = `
`);
              var q = 0, rt = false;
              this.parse = function(et, ut, ot) {
                if (typeof et != "string") throw new Error("Input must be a string");
                var W = et.length, J = x.length, ct = b.length, ht = A.length, it = T(L), St = [], lt = [], dt = [], wt = q = 0;
                if (!et) return K();
                if (H || H !== false && et.indexOf(V) === -1) {
                  for (var bt = et.split(b), D = 0; D < bt.length; D++) {
                    if (dt = bt[D], q += dt.length, D !== bt.length - 1) q += b.length;
                    else if (ot) return K();
                    if (!A || dt.substring(0, ht) !== A) {
                      if (it) {
                        if (St = [], Et(dt.split(x)), Q(), rt) return K();
                      } else Et(dt.split(x));
                      if (I && I <= D) return St = St.slice(0, I), K(true);
                    }
                  }
                  return K();
                }
                for (var zt = et.indexOf(x, q), ft = et.indexOf(b, q), Lt = new RegExp(m(U) + m(V), "g"), st = et.indexOf(V, q); ; ) if (et[q] === V) for (st = q, q++; ; ) {
                  if ((st = et.indexOf(V, st + 1)) === -1) return ot || lt.push({
                    type: "Quotes",
                    code: "MissingQuotes",
                    message: "Quoted field unterminated",
                    row: St.length,
                    index: q
                  }), S();
                  if (st === W - 1) return S(et.substring(q, st).replace(Lt, V));
                  if (V === U && et[st + 1] === U) st++;
                  else if (V === U || st === 0 || et[st - 1] !== U) {
                    zt !== -1 && zt < st + 1 && (zt = et.indexOf(x, st + 1));
                    var Rt = P((ft = ft !== -1 && ft < st + 1 ? et.indexOf(b, st + 1) : ft) === -1 ? zt : Math.min(zt, ft));
                    if (et.substr(st + 1 + Rt, J) === x) {
                      dt.push(et.substring(q, st).replace(Lt, V)), et[q = st + 1 + Rt + J] !== V && (st = et.indexOf(V, q)), zt = et.indexOf(x, q), ft = et.indexOf(b, q);
                      break;
                    }
                    if (Rt = P(ft), et.substring(st + 1 + Rt, st + 1 + Rt + ct) === b) {
                      if (dt.push(et.substring(q, st).replace(Lt, V)), B(st + 1 + Rt + ct), zt = et.indexOf(x, q), st = et.indexOf(V, q), it && (Q(), rt)) return K();
                      if (I && St.length >= I) return K(true);
                      break;
                    }
                    lt.push({
                      type: "Quotes",
                      code: "InvalidQuotes",
                      message: "Trailing quote on quoted field is malformed",
                      row: St.length,
                      index: q
                    }), st++;
                  }
                }
                else if (A && dt.length === 0 && et.substring(q, q + ht) === A) {
                  if (ft === -1) return K();
                  q = ft + ct, ft = et.indexOf(b, q), zt = et.indexOf(x, q);
                } else if (zt !== -1 && (zt < ft || ft === -1)) dt.push(et.substring(q, zt)), q = zt + J, zt = et.indexOf(x, q);
                else {
                  if (ft === -1) break;
                  if (dt.push(et.substring(q, ft)), B(ft + ct), it && (Q(), rt)) return K();
                  if (I && St.length >= I) return K(true);
                }
                return S();
                function Et(X) {
                  St.push(X), wt = q;
                }
                function P(X) {
                  var _t = 0;
                  return _t = X !== -1 && (X = et.substring(st + 1, X)) && X.trim() === "" ? X.length : _t;
                }
                function S(X) {
                  return ot || (X === void 0 && (X = et.substring(q)), dt.push(X), q = W, Et(dt), it && Q()), K();
                }
                function B(X) {
                  q = X, Et(dt), dt = [], ft = et.indexOf(b, q);
                }
                function K(X) {
                  if (v.header && !ut && St.length && !z) {
                    var _t = St[0], pt = /* @__PURE__ */ Object.create(null), Pt = new Set(_t);
                    let kt = false;
                    for (let nt = 0; nt < _t.length; nt++) {
                      let gt = _t[nt];
                      if (pt[gt = T(v.transformHeader) ? v.transformHeader(gt, nt) : gt]) {
                        let Dt, Nt = pt[gt];
                        for (; Dt = gt + "_" + Nt, Nt++, Pt.has(Dt); ) ;
                        Pt.add(Dt), _t[nt] = Dt, pt[gt]++, kt = true, (j = j === null ? {} : j)[Dt] = gt;
                      } else pt[gt] = 1, _t[nt] = gt;
                      Pt.add(gt);
                    }
                    kt && console.warn("Duplicate headers found and renamed."), z = true;
                  }
                  return {
                    data: St,
                    errors: lt,
                    meta: {
                      delimiter: x,
                      linebreak: b,
                      aborted: rt,
                      truncated: !!X,
                      cursor: wt + (ut || 0),
                      renamedHeaders: j
                    }
                  };
                }
                function Q() {
                  L(K()), St = [], lt = [];
                }
              }, this.abort = function() {
                rt = true;
              }, this.getCharIndex = function() {
                return q;
              };
            }
            function y(v) {
              var x = v.data, b = a[x.workerId], A = false;
              if (x.error) b.userError(x.error, x.file);
              else if (x.results && x.results.data) {
                var L = {
                  abort: function() {
                    A = true, w(x.workerId, {
                      data: [],
                      errors: [],
                      meta: {
                        aborted: true
                      }
                    });
                  },
                  pause: M,
                  resume: M
                };
                if (T(b.userStep)) {
                  for (var I = 0; I < x.results.data.length && (b.userStep({
                    data: x.results.data[I],
                    errors: x.results.errors,
                    meta: x.results.meta
                  }, L), !A); I++) ;
                  delete x.results;
                } else T(b.userChunk) && (b.userChunk(x.results, L, x.file), delete x.results);
              }
              x.finished && !A && w(x.workerId, x.results);
            }
            function w(v, x) {
              var b = a[v];
              T(b.userComplete) && b.userComplete(x), b.terminate(), delete a[v];
            }
            function M() {
              throw new Error("Not implemented.");
            }
            function C(v) {
              if (typeof v != "object" || v === null) return v;
              var x, b = Array.isArray(v) ? [] : {};
              for (x in v) b[x] = C(v[x]);
              return b;
            }
            function R(v, x) {
              return function() {
                v.apply(x, arguments);
              };
            }
            function T(v) {
              return typeof v == "function";
            }
            return c.parse = function(v, x) {
              var b = (x = x || {}).dynamicTyping || false;
              if (T(b) && (x.dynamicTypingFunction = b, b = {}), x.dynamicTyping = b, x.transform = !!T(x.transform) && x.transform, !x.worker || !c.WORKERS_SUPPORTED) return b = null, c.NODE_STREAM_INPUT, typeof v == "string" ? (v = ((A) => A.charCodeAt(0) !== 65279 ? A : A.slice(1))(v), b = new (x.download ? u : f)(x)) : v.readable === true && T(v.read) && T(v.on) ? b = new g(x) : (i.File && v instanceof File || v instanceof Object) && (b = new d(x)), b.stream(v);
              (b = (() => {
                var A;
                return !!c.WORKERS_SUPPORTED && (A = (() => {
                  var L = i.URL || i.webkitURL || null, I = e.toString();
                  return c.BLOB_URL || (c.BLOB_URL = L.createObjectURL(new Blob([
                    "var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ",
                    "(",
                    I,
                    ")();"
                  ], {
                    type: "text/javascript"
                  })));
                })(), (A = new i.Worker(A)).onmessage = y, A.id = l++, a[A.id] = A);
              })()).userStep = x.step, b.userChunk = x.chunk, b.userComplete = x.complete, b.userError = x.error, x.step = T(x.step), x.chunk = T(x.chunk), x.complete = T(x.complete), x.error = T(x.error), delete x.worker, b.postMessage({
                input: v,
                config: x,
                workerId: b.id
              });
            }, c.unparse = function(v, x) {
              var b = false, A = true, L = ",", I = `\r
`, H = '"', j = H + H, z = false, V = null, U = false, q = ((() => {
                if (typeof x == "object") {
                  if (typeof x.delimiter != "string" || c.BAD_DELIMITERS.filter(function(ut) {
                    return x.delimiter.indexOf(ut) !== -1;
                  }).length || (L = x.delimiter), typeof x.quotes != "boolean" && typeof x.quotes != "function" && !Array.isArray(x.quotes) || (b = x.quotes), typeof x.skipEmptyLines != "boolean" && typeof x.skipEmptyLines != "string" || (z = x.skipEmptyLines), typeof x.newline == "string" && (I = x.newline), typeof x.quoteChar == "string" && (H = x.quoteChar), typeof x.header == "boolean" && (A = x.header), Array.isArray(x.columns)) {
                    if (x.columns.length === 0) throw new Error("Option columns is empty");
                    V = x.columns;
                  }
                  x.escapeChar !== void 0 && (j = x.escapeChar + H), x.escapeFormulae instanceof RegExp ? U = x.escapeFormulae : typeof x.escapeFormulae == "boolean" && x.escapeFormulae && (U = /^[=+\-@\t\r].*$/);
                }
              })(), new RegExp(m(H), "g"));
              if (typeof v == "string" && (v = JSON.parse(v)), Array.isArray(v)) {
                if (!v.length || Array.isArray(v[0])) return rt(null, v, z);
                if (typeof v[0] == "object") return rt(V || Object.keys(v[0]), v, z);
              } else if (typeof v == "object") return typeof v.data == "string" && (v.data = JSON.parse(v.data)), Array.isArray(v.data) && (v.fields || (v.fields = v.meta && v.meta.fields || V), v.fields || (v.fields = Array.isArray(v.data[0]) ? v.fields : typeof v.data[0] == "object" ? Object.keys(v.data[0]) : []), Array.isArray(v.data[0]) || typeof v.data[0] == "object" || (v.data = [
                v.data
              ])), rt(v.fields || [], v.data || [], z);
              throw new Error("Unable to serialize unrecognized input");
              function rt(ut, ot, W) {
                var J = "", ct = (typeof ut == "string" && (ut = JSON.parse(ut)), typeof ot == "string" && (ot = JSON.parse(ot)), Array.isArray(ut) && 0 < ut.length), ht = !Array.isArray(ot[0]);
                if (ct && A) {
                  for (var it = 0; it < ut.length; it++) 0 < it && (J += L), J += et(ut[it], it);
                  0 < ot.length && (J += I);
                }
                for (var St = 0; St < ot.length; St++) {
                  var lt = (ct ? ut : ot[St]).length, dt = false, wt = ct ? Object.keys(ot[St]).length === 0 : ot[St].length === 0;
                  if (W && !ct && (dt = W === "greedy" ? ot[St].join("").trim() === "" : ot[St].length === 1 && ot[St][0].length === 0), W === "greedy" && ct) {
                    for (var bt = [], D = 0; D < lt; D++) {
                      var zt = ht ? ut[D] : D;
                      bt.push(ot[St][zt]);
                    }
                    dt = bt.join("").trim() === "";
                  }
                  if (!dt) {
                    for (var ft = 0; ft < lt; ft++) {
                      0 < ft && !wt && (J += L);
                      var Lt = ct && ht ? ut[ft] : ft;
                      J += et(ot[St][Lt], ft);
                    }
                    St < ot.length - 1 && (!W || 0 < lt && !wt) && (J += I);
                  }
                }
                return J;
              }
              function et(ut, ot) {
                var W, J;
                return ut == null ? "" : ut.constructor === Date ? JSON.stringify(ut).slice(1, 25) : (J = false, U && typeof ut == "string" && U.test(ut) && (ut = "'" + ut, J = true), W = ut.toString().replace(q, j), (J = J || b === true || typeof b == "function" && b(ut, ot) || Array.isArray(b) && b[ot] || ((ct, ht) => {
                  for (var it = 0; it < ht.length; it++) if (-1 < ct.indexOf(ht[it])) return true;
                  return false;
                })(W, c.BAD_DELIMITERS) || -1 < W.indexOf(L) || W.charAt(0) === " " || W.charAt(W.length - 1) === " ") ? H + W + H : W);
              }
            }, c.RECORD_SEP = "", c.UNIT_SEP = "", c.BYTE_ORDER_MARK = "\uFEFF", c.BAD_DELIMITERS = [
              "\r",
              `
`,
              '"',
              c.BYTE_ORDER_MARK
            ], c.WORKERS_SUPPORTED = !r && !!i.Worker, c.NODE_STREAM_INPUT = 1, c.LocalChunkSize = 10485760, c.RemoteChunkSize = 5242880, c.DefaultDelimiter = ",", c.Parser = p, c.ParserHandle = _, c.NetworkStreamer = u, c.FileStreamer = d, c.StringStreamer = f, c.ReadableStreamStreamer = g, i.jQuery && ((s = i.jQuery).fn.parse = function(v) {
              var x = v.config || {}, b = [];
              return this.each(function(I) {
                if (!(s(this).prop("tagName").toUpperCase() === "INPUT" && s(this).attr("type").toLowerCase() === "file" && i.FileReader) || !this.files || this.files.length === 0) return true;
                for (var H = 0; H < this.files.length; H++) b.push({
                  file: this.files[H],
                  inputElem: this,
                  instanceConfig: s.extend({}, x)
                });
              }), A(), this;
              function A() {
                if (b.length === 0) T(v.complete) && v.complete();
                else {
                  var I, H, j, z, V = b[0];
                  if (T(v.before)) {
                    var U = v.before(V.file, V.inputElem);
                    if (typeof U == "object") {
                      if (U.action === "abort") return I = "AbortError", H = V.file, j = V.inputElem, z = U.reason, void (T(v.error) && v.error({
                        name: I
                      }, H, j, z));
                      if (U.action === "skip") return void L();
                      typeof U.config == "object" && (V.instanceConfig = s.extend(V.instanceConfig, U.config));
                    } else if (U === "skip") return void L();
                  }
                  var q = V.instanceConfig.complete;
                  V.instanceConfig.complete = function(rt) {
                    T(q) && q(rt, V.file, V.inputElem), L();
                  }, c.parse(V.file, V.instanceConfig);
                }
              }
              function L() {
                b.splice(0, 1), A();
              }
            }), o && (i.onmessage = function(v) {
              v = v.data, c.WORKER_ID === void 0 && v && (c.WORKER_ID = v.workerId), typeof v.input == "string" ? i.postMessage({
                workerId: c.WORKER_ID,
                results: c.parse(v.input, v.config),
                finished: true
              }) : (i.File && v.input instanceof File || v.input instanceof Object) && (v = c.parse(v.input, v.config)) && i.postMessage({
                workerId: c.WORKER_ID,
                results: v,
                finished: true
              });
            }), (u.prototype = Object.create(h.prototype)).constructor = u, (d.prototype = Object.create(h.prototype)).constructor = d, (f.prototype = Object.create(f.prototype)).constructor = f, (g.prototype = Object.create(h.prototype)).constructor = g, c;
          });
        }(Ra)), Ra.exports;
      }
      var tL = J2();
      const eL = Z2(tL), nL = eL.parse(await fetch("./data/IBM.csv").then((n) => n.text()), {
        header: true,
        dynamicTyping: true
      }), em = (n, t) => Array.from({
        length: 50
      }, (i, s) => 50 + s * 2).map((i) => ({
        x: i,
        y: Mc(100, i, 1, 0.05, 0.2, t)[n]
      })), iL = () => {
        const [n, t] = Vs({
          minStrike: 80,
          maxStrike: 120,
          strikeStep: 5,
          minVol: 0.1,
          maxVol: 0.5,
          volStep: 0.05,
          spot: 100,
          time: 1,
          rate: 0.05
        }), [e, i] = Vs("prices"), [s, r] = Vs(null), [o, a] = Vs(new Date((/* @__PURE__ */ new Date()).setFullYear((/* @__PURE__ */ new Date()).getFullYear() - 2))), [l] = Vs(nL), c = () => {
          const d = Array.from({
            length: Math.floor((n.maxStrike - n.minStrike) / n.strikeStep) + 1
          }, (_, m) => n.minStrike + m * n.strikeStep), f = Array.from({
            length: Math.floor((n.maxVol - n.minVol) / n.volStep) + 1
          }, (_, m) => n.minVol + m * n.volStep), g = (_) => ({
            prices: f.map((m) => d.map((p) => pr(n.spot, p, n.time, n.rate, m, _).toFixed(2))),
            greeks: f.map((m) => d.map((p) => {
              const y = Mc(n.spot, p, n.time, n.rate, m, _);
              return {
                delta: y.delta.toFixed(3),
                gamma: y.gamma.toFixed(3),
                theta: y.theta.toFixed(3),
                vega: y.vega.toFixed(3),
                rho: y.rho.toFixed(3)
              };
            }))
          });
          r({
            strikes: d,
            volatilities: f,
            puts: g(Yn.Put),
            calls: g(Yn.Call)
          });
        };
        Xs(() => {
          c();
        }, [
          n
        ]);
        const h = [
          "prices",
          "delta",
          "gamma",
          "theta",
          "vega",
          "rho"
        ], u = () => {
          const d = pr(n.spot, n.spot, n.time, n.rate, n.minVol, Yn.Call).toFixed(4), f = pr(n.spot, n.spot, n.time, n.rate, n.minVol, Yn.Put).toFixed(4), g = Mc(n.spot, n.spot, n.time, n.rate, n.minVol, Yn.Call);
          return {
            callPrice: d,
            putPrice: f,
            greeks: g
          };
        };
        return $("div", {
          class: "min-h-screen flex bg-[#0d1117] text-gray-100",
          children: [
            $("div", {
              class: "w-64 fixed top-0 bottom-0 flex-none px-4 py-6 overflow-y-auto border-r bg-[#161b22] border-gray-700",
              children: [
                $("h2", {
                  class: "px-2 text-sm font-semibold mb-4 text-gray-600 dark:text-gray-400",
                  children: "Parameters"
                }),
                $("div", {
                  class: "space-y-4",
                  children: [
                    $("div", {
                      class: "github-card p-3",
                      children: [
                        $("label", {
                          class: "block text-xs font-medium mb-2",
                          children: "Strike Price Range"
                        }),
                        $("input", {
                          type: "range",
                          min: "50",
                          max: "300",
                          step: "1",
                          value: n.spot,
                          onChange: (d) => t({
                            ...n,
                            spot: Number(d.target.value)
                          }),
                          class: "w-full github-input"
                        }),
                        $("div", {
                          class: "flex justify-between text-xs mt-1",
                          children: [
                            $("span", {
                              children: "50"
                            }),
                            $("span", {
                              children: n.spot
                            }),
                            $("span", {
                              children: "300"
                            })
                          ]
                        })
                      ]
                    }),
                    $("div", {
                      class: "github-card p-3",
                      children: [
                        $("label", {
                          class: "block text-xs font-medium mb-2",
                          children: "Volatility"
                        }),
                        $("input", {
                          type: "range",
                          min: "0.1",
                          max: "0.5",
                          step: "0.01",
                          value: n.minVol,
                          onChange: (d) => t({
                            ...n,
                            minVol: Number(d.target.value)
                          }),
                          class: "w-full github-input"
                        }),
                        $("div", {
                          class: "flex justify-between text-xs mt-1",
                          children: [
                            $("span", {
                              children: "10%"
                            }),
                            $("span", {
                              children: [
                                (n.minVol * 100).toFixed(0),
                                "%"
                              ]
                            }),
                            $("span", {
                              children: "50%"
                            })
                          ]
                        })
                      ]
                    }),
                    $("div", {
                      class: "github-card p-3",
                      children: [
                        $("label", {
                          class: "block text-xs font-medium mb-2",
                          children: "Time to Expiry (Years)"
                        }),
                        $("input", {
                          type: "range",
                          min: "0.25",
                          max: "10",
                          step: "0.25",
                          value: n.time,
                          onChange: (d) => t({
                            ...n,
                            time: Number(d.target.value)
                          }),
                          class: "w-full github-input"
                        }),
                        $("div", {
                          class: "flex justify-between text-xs mt-1",
                          children: [
                            $("span", {
                              children: "0.25"
                            }),
                            $("span", {
                              children: n.time.toFixed(2)
                            }),
                            $("span", {
                              children: "10.0"
                            })
                          ]
                        })
                      ]
                    })
                  ]
                }),
                $("div", {
                  class: "mt-6",
                  children: [
                    $("h2", {
                      class: "px-2 text-sm font-semibold mb-2 text-gray-600 dark:text-gray-400",
                      children: "Current Values"
                    }),
                    $("div", {
                      class: "github-card p-3 space-y-2 text-xs",
                      children: [
                        $("div", {
                          class: "grid grid-cols-2 gap-2",
                          children: [
                            $("div", {
                              class: "font-medium",
                              children: "Call Price:"
                            }),
                            $("div", {
                              class: "text-right",
                              children: u().callPrice
                            }),
                            $("div", {
                              class: "font-medium",
                              children: "Put Price:"
                            }),
                            $("div", {
                              class: "text-right",
                              children: u().putPrice
                            })
                          ]
                        }),
                        $("div", {
                          class: "border-t border-gray-200 dark:border-gray-700 my-2"
                        }),
                        $("div", {
                          class: "grid grid-cols-2 gap-2",
                          children: [
                            $("div", {
                              class: "font-medium",
                              children: "Delta:"
                            }),
                            $("div", {
                              class: "text-right",
                              children: u().greeks.delta.toFixed(4)
                            }),
                            $("div", {
                              class: "font-medium",
                              children: "Gamma:"
                            }),
                            $("div", {
                              class: "text-right",
                              children: u().greeks.gamma.toFixed(4)
                            }),
                            $("div", {
                              class: "font-medium",
                              children: "Theta:"
                            }),
                            $("div", {
                              class: "text-right",
                              children: u().greeks.theta.toFixed(4)
                            }),
                            $("div", {
                              class: "font-medium",
                              children: "Vega:"
                            }),
                            $("div", {
                              class: "text-right",
                              children: u().greeks.vega.toFixed(4)
                            }),
                            $("div", {
                              class: "font-medium",
                              children: "Rho:"
                            }),
                            $("div", {
                              class: "text-right",
                              children: u().greeks.rho.toFixed(4)
                            })
                          ]
                        })
                      ]
                    })
                  ]
                }),
                $("nav", {
                  class: "mt-6",
                  children: [
                    $("h2", {
                      class: "px-2 text-sm font-semibold mb-2 text-gray-600 dark:text-gray-400",
                      children: "Views"
                    }),
                    $("div", {
                      class: "space-y-1",
                      children: h.map((d) => $("button", {
                        onClick: () => i(d),
                        class: `w-full px-2 py-1.5 text-sm rounded-md text-left transition-colors ${e === d ? "bg-purple-100 dark:bg-purple-900/30 text-purple-600 dark:text-purple-300 font-medium" : "hover:bg-gray-100 dark:hover:bg-gray-800"}`,
                        children: d.charAt(0).toUpperCase() + d.slice(1)
                      }))
                    })
                  ]
                })
              ]
            }),
            $("div", {
              class: "flex-1 min-w-0 px-6 py-4 ml-64",
              children: [
                $("header", {
                  class: "mb-6 pb-4 border-b border-gray-200 dark:border-gray-700",
                  children: $("h1", {
                    class: "text-2xl font-semibold",
                    children: "Black-Scholes Option Visualizer"
                  })
                }),
                s && $(ro, {
                  children: [
                    $("div", {
                      class: "mb-6",
                      children: $("div", {
                        class: "github-card p-4",
                        children: [
                          $("h3", {
                            class: "text-sm font-medium text-gray-600 dark:text-gray-400 mb-2",
                            children: "How to read the 3D surface:"
                          }),
                          $("ul", {
                            class: "list-disc list-inside space-y-1 text-sm",
                            children: [
                              $("li", {
                                children: "X-axis: Strike Price (horizontal)"
                              }),
                              $("li", {
                                children: "Y-axis: Option Value/Greek (height)"
                              }),
                              $("li", {
                                children: "Z-axis: Volatility (depth)"
                              }),
                              $("li", {
                                children: "Colors: Green = higher values, Red = lower values"
                              }),
                              $("li", {
                                children: "Use mouse to rotate, scroll to zoom, right-click to pan"
                              })
                            ]
                          })
                        ]
                      })
                    }),
                    $("div", {
                      class: "grid grid-cols-2 gap-6 mb-8",
                      children: [
                        $("div", {
                          class: "github-card p-4",
                          children: [
                            $("h2", {
                              class: "text-base font-semibold mb-2",
                              children: "Put Options"
                            }),
                            $("div", {
                              class: "text-sm text-gray-600 dark:text-gray-400 mb-4",
                              children: [
                                "Visualization of put option ",
                                e === "prices" ? "prices" : e,
                                " across different strikes and volatilities"
                              ]
                            }),
                            $("div", {
                              class: "aspect-[4/3] w-full",
                              children: $(sf, {
                                data: s.puts[e === "prices" ? "prices" : "greeks"].map((d) => d.map((f) => e === "prices" ? f : f[e])),
                                strikes: s.strikes,
                                volatilities: s.volatilities,
                                colorType: e
                              })
                            })
                          ]
                        }),
                        $("div", {
                          class: "github-card p-4",
                          children: [
                            $("h2", {
                              class: "text-base font-semibold mb-2",
                              children: "Call Options"
                            }),
                            $("div", {
                              class: "text-sm text-gray-600 dark:text-gray-400 mb-4",
                              children: [
                                "Visualization of call option ",
                                e === "prices" ? "prices" : e,
                                " across different strikes and volatilities"
                              ]
                            }),
                            $("div", {
                              class: "aspect-[4/3] w-full",
                              children: $(sf, {
                                data: s.calls[e === "prices" ? "prices" : "greeks"].map((d) => d.map((f) => e === "prices" ? f : f[e])),
                                strikes: s.strikes,
                                volatilities: s.volatilities,
                                colorType: e
                              })
                            })
                          ]
                        })
                      ]
                    })
                  ]
                }),
                $("section", {
                  class: "mb-8",
                  children: [
                    $("h2", {
                      class: "text-base font-semibold mb-4 pb-2 border-b border-gray-200 dark:border-gray-700",
                      children: "Option Greeks Analysis"
                    }),
                    $("div", {
                      class: "github-card p-4 mb-6",
                      children: [
                        $("h3", {
                          class: "text-sm font-medium mb-2",
                          children: "Current Parameters"
                        }),
                        $("div", {
                          class: "grid grid-cols-4 gap-4 text-sm",
                          children: [
                            $("div", {
                              children: [
                                $("span", {
                                  class: "font-medium",
                                  children: "Stock Price:"
                                }),
                                " $",
                                n.spot
                              ]
                            }),
                            $("div", {
                              children: [
                                $("span", {
                                  class: "font-medium",
                                  children: "Time to Expiry:"
                                }),
                                " ",
                                n.time,
                                " years"
                              ]
                            }),
                            $("div", {
                              children: [
                                $("span", {
                                  class: "font-medium",
                                  children: "Risk-free Rate:"
                                }),
                                " ",
                                (n.rate * 100).toFixed(1),
                                "%"
                              ]
                            }),
                            $("div", {
                              children: [
                                $("span", {
                                  class: "font-medium",
                                  children: "Volatility:"
                                }),
                                " ",
                                (n.minVol * 100).toFixed(1),
                                "%"
                              ]
                            })
                          ]
                        })
                      ]
                    }),
                    $("div", {
                      class: "flex justify-center space-x-8 mb-6",
                      children: [
                        $("div", {
                          class: "flex items-center",
                          children: [
                            $("div", {
                              class: "w-4 h-4 rounded bg-[#e91e63] mr-2"
                            }),
                            $("span", {
                              class: "text-sm",
                              children: "Put Option"
                            })
                          ]
                        }),
                        $("div", {
                          class: "flex items-center",
                          children: [
                            $("div", {
                              class: "w-4 h-4 rounded bg-[#2196f3] mr-2"
                            }),
                            $("span", {
                              class: "text-sm",
                              children: "Call Option"
                            })
                          ]
                        })
                      ]
                    }),
                    $("div", {
                      class: "grid grid-cols-2 gap-6",
                      children: [
                        "delta",
                        "gamma",
                        "theta",
                        "vega"
                      ].map((d) => $("div", {
                        class: "github-card p-4",
                        children: $("div", {
                          class: "grid grid-cols-2 gap-6",
                          children: [
                            $("div", {
                              children: [
                                $("h3", {
                                  class: "text-xl font-semibold mb-4",
                                  children: "Put Option"
                                }),
                                $(Ap, {
                                  data: em(d, Yn.Put),
                                  title: d.charAt(0).toUpperCase() + d.slice(1),
                                  xLabel: "Strike Price",
                                  yLabel: d.charAt(0).toUpperCase() + d.slice(1),
                                  width: 300,
                                  height: 200,
                                  color: "#e91e63",
                                  spot: n.spot,
                                  annotations: {
                                    lines: [
                                      {
                                        x: n.spot,
                                        color: "rgba(255, 255, 255, 0.5)",
                                        width: 1
                                      },
                                      ...pa[d].lines || []
                                    ],
                                    items: pa[d].items || []
                                  }
                                })
                              ]
                            }),
                            $("div", {
                              children: [
                                $("h3", {
                                  class: "text-xl font-semibold mb-4",
                                  children: "Call Option"
                                }),
                                $(Ap, {
                                  data: em(d, Yn.Call),
                                  title: d.charAt(0).toUpperCase() + d.slice(1),
                                  xLabel: "Strike Price",
                                  yLabel: d.charAt(0).toUpperCase() + d.slice(1),
                                  width: 300,
                                  height: 200,
                                  color: "#2196f3",
                                  spot: n.spot,
                                  annotations: {
                                    lines: [
                                      {
                                        x: n.spot,
                                        color: "rgba(255, 255, 255, 0.5)",
                                        width: 1
                                      },
                                      ...pa[d].lines || []
                                    ],
                                    items: pa[d].items || []
                                  }
                                })
                              ]
                            })
                          ]
                        })
                      }))
                    })
                  ]
                }),
                $("section", {
                  class: "mb-8",
                  children: [
                    $("h2", {
                      class: "text-base font-semibold mb-4 pb-2 border-b border-gray-200 dark:border-gray-700",
                      children: "Historical Price Analysis & Break-Even Points"
                    }),
                    $("div", {
                      class: "p-4 mb-6",
                      children: [
                        $("p", {
                          class: "text-sm mb-4",
                          children: "This chart displays IBM's historical stock price data with option break-even points overlaid. The break-even points show where the stock price needs to move for options to become profitable at expiration, accounting for the premium paid. The vertical lines indicate the option purchase date and expiration date, helping visualize the time window for the trade."
                        }),
                        $("ul", {
                          class: "list-disc list-inside space-y-1 text-sm",
                          children: [
                            $("li", {
                              children: "Green line: Call option break-even price (Strike + Premium)"
                            }),
                            $("li", {
                              children: "Red line: Put option break-even price (Strike - Premium)"
                            }),
                            $("li", {
                              children: "Blue line: Strike price"
                            })
                          ]
                        })
                      ]
                    }),
                    $("div", {
                      class: "mb-8",
                      children: (() => {
                        const d = pr(n.spot, n.spot, n.time, n.rate, n.minVol, Yn.Call), f = pr(n.spot, n.spot, n.time, n.rate, n.minVol, Yn.Put), g = /* @__PURE__ */ new Date("2025-02-28"), _ = new Date(g);
                        return _.setFullYear(_.getFullYear() - n.time), $(K2, {
                          data: l,
                          strikePrice: n.spot,
                          callBreakeven: n.spot + d,
                          putBreakeven: n.spot - f,
                          purchaseDate: _,
                          expirationDate: g
                        });
                      })()
                    })
                  ]
                }),
                $("footer", {
                  class: "mt-12 pt-8 pb-8 border-t border-gray-700",
                  children: $("div", {
                    class: "flex justify-between items-center text-base text-gray-400",
                    children: [
                      $("p", {
                        class: "text-lg",
                        children: [
                          "An interactive Black-Scholes option pricing model visualizer.",
                          $("br", {}),
                          "Built with Preact, Three.js, and Chart.js."
                        ]
                      }),
                      $("div", {
                        class: "space-x-6",
                        children: [
                          $("a", {
                            href: "https://github.com/s-mv/black-scholes-visualizer",
                            target: "_blank",
                            rel: "noopener",
                            class: "github-button text-base",
                            children: "GitHub"
                          }),
                          $("a", {
                            href: "https://linkedin.com/in/shreerang-vaidya",
                            target: "_blank",
                            rel: "noopener",
                            class: "github-button text-base",
                            children: "LinkedIn"
                          })
                        ]
                      })
                    ]
                  })
                })
              ]
            })
          ]
        });
      };
      $_($(iL, {}), document.getElementById("app"));
    })();
  }
});
export default require_stdin();
